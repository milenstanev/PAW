"bundle";
System.registerDynamic("lib/ionic/js/ionic.bundle.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function() {
    window.ionic = window.ionic || {};
    window.ionic.views = {};
    window.ionic.version = '1.2.4';
    (function(ionic) {
      ionic.DelegateService = function(methodNames) {
        if (methodNames.indexOf('$getByHandle') > -1) {
          throw new Error("Method '$getByHandle' is implicitly added to each delegate service. Do not list it as a method.");
        }
        function trueFn() {
          return true;
        }
        return ['$log', function($log) {
          function DelegateInstance(instances, handle) {
            this._instances = instances;
            this.handle = handle;
          }
          methodNames.forEach(function(methodName) {
            DelegateInstance.prototype[methodName] = instanceMethodCaller(methodName);
          });
          function DelegateService() {
            this._instances = [];
          }
          DelegateService.prototype = DelegateInstance.prototype;
          DelegateService.prototype._registerInstance = function(instance, handle, filterFn) {
            var instances = this._instances;
            instance.$$delegateHandle = handle;
            instance.$$filterFn = filterFn || trueFn;
            instances.push(instance);
            return function deregister() {
              var index = instances.indexOf(instance);
              if (index !== -1) {
                instances.splice(index, 1);
              }
            };
          };
          DelegateService.prototype.$getByHandle = function(handle) {
            return new DelegateInstance(this._instances, handle);
          };
          return new DelegateService();
          function instanceMethodCaller(methodName) {
            return function caller() {
              var handle = this.handle;
              var args = arguments;
              var foundInstancesCount = 0;
              var returnValue;
              this._instances.forEach(function(instance) {
                if ((!handle || handle == instance.$$delegateHandle) && instance.$$filterFn(instance)) {
                  foundInstancesCount++;
                  var ret = instance[methodName].apply(instance, args);
                  if (foundInstancesCount === 1) {
                    returnValue = ret;
                  }
                }
              });
              if (!foundInstancesCount && handle) {
                return $log.warn('Delegate for handle "' + handle + '" could not find a ' + 'corresponding element with delegate-handle="' + handle + '"! ' + methodName + '() was not called!\n' + 'Possible cause: If you are calling ' + methodName + '() immediately, and ' + 'your element with delegate-handle="' + handle + '" is a child of your ' + 'controller, then your element may not be compiled yet. Put a $timeout ' + 'around your call to ' + methodName + '() and try again.');
              }
              return returnValue;
            };
          }
        }];
      };
    })(window.ionic);
    (function(window, document, ionic) {
      var readyCallbacks = [];
      var isDomReady = document.readyState === 'complete' || document.readyState === 'interactive';
      function domReady() {
        isDomReady = true;
        for (var x = 0; x < readyCallbacks.length; x++) {
          ionic.requestAnimationFrame(readyCallbacks[x]);
        }
        readyCallbacks = [];
        document.removeEventListener('DOMContentLoaded', domReady);
      }
      if (!isDomReady) {
        document.addEventListener('DOMContentLoaded', domReady);
      }
      window._rAF = (function() {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
          window.setTimeout(callback, 16);
        };
      })();
      var cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;
      ionic.DomUtil = {
        requestAnimationFrame: function(cb) {
          return window._rAF(cb);
        },
        cancelAnimationFrame: function(requestId) {
          cancelAnimationFrame(requestId);
        },
        animationFrameThrottle: function(cb) {
          var args,
              isQueued,
              context;
          return function() {
            args = arguments;
            context = this;
            if (!isQueued) {
              isQueued = true;
              ionic.requestAnimationFrame(function() {
                cb.apply(context, args);
                isQueued = false;
              });
            }
          };
        },
        contains: function(parentNode, otherNode) {
          var current = otherNode;
          while (current) {
            if (current === parentNode)
              return true;
            current = current.parentNode;
          }
        },
        getPositionInParent: function(el) {
          return {
            left: el.offsetLeft,
            top: el.offsetTop
          };
        },
        getOffsetTop: function(el) {
          var curtop = 0;
          if (el.offsetParent) {
            do {
              curtop += el.offsetTop;
              el = el.offsetParent;
            } while (el);
            return curtop;
          }
        },
        ready: function(cb) {
          if (isDomReady) {
            ionic.requestAnimationFrame(cb);
          } else {
            readyCallbacks.push(cb);
          }
        },
        getTextBounds: function(textNode) {
          if (document.createRange) {
            var range = document.createRange();
            range.selectNodeContents(textNode);
            if (range.getBoundingClientRect) {
              var rect = range.getBoundingClientRect();
              if (rect) {
                var sx = window.scrollX;
                var sy = window.scrollY;
                return {
                  top: rect.top + sy,
                  left: rect.left + sx,
                  right: rect.left + sx + rect.width,
                  bottom: rect.top + sy + rect.height,
                  width: rect.width,
                  height: rect.height
                };
              }
            }
          }
          return null;
        },
        getChildIndex: function(element, type) {
          if (type) {
            var ch = element.parentNode.children;
            var c;
            for (var i = 0,
                k = 0,
                j = ch.length; i < j; i++) {
              c = ch[i];
              if (c.nodeName && c.nodeName.toLowerCase() == type) {
                if (c == element) {
                  return k;
                }
                k++;
              }
            }
          }
          return Array.prototype.slice.call(element.parentNode.children).indexOf(element);
        },
        swapNodes: function(src, dest) {
          dest.parentNode.insertBefore(src, dest);
        },
        elementIsDescendant: function(el, parent, stopAt) {
          var current = el;
          do {
            if (current === parent)
              return true;
            current = current.parentNode;
          } while (current && current !== stopAt);
          return false;
        },
        getParentWithClass: function(e, className, depth) {
          depth = depth || 10;
          while (e.parentNode && depth--) {
            if (e.parentNode.classList && e.parentNode.classList.contains(className)) {
              return e.parentNode;
            }
            e = e.parentNode;
          }
          return null;
        },
        getParentOrSelfWithClass: function(e, className, depth) {
          depth = depth || 10;
          while (e && depth--) {
            if (e.classList && e.classList.contains(className)) {
              return e;
            }
            e = e.parentNode;
          }
          return null;
        },
        rectContains: function(x, y, x1, y1, x2, y2) {
          if (x < x1 || x > x2)
            return false;
          if (y < y1 || y > y2)
            return false;
          return true;
        },
        blurAll: function() {
          if (document.activeElement && document.activeElement != document.body) {
            document.activeElement.blur();
            return document.activeElement;
          }
          return null;
        },
        cachedAttr: function(ele, key, value) {
          ele = ele && ele.length && ele[0] || ele;
          if (ele && ele.setAttribute) {
            var dataKey = '$attr-' + key;
            if (arguments.length > 2) {
              if (ele[dataKey] !== value) {
                ele.setAttribute(key, value);
                ele[dataKey] = value;
              }
            } else if (typeof ele[dataKey] == 'undefined') {
              ele[dataKey] = ele.getAttribute(key);
            }
            return ele[dataKey];
          }
        },
        cachedStyles: function(ele, styles) {
          ele = ele && ele.length && ele[0] || ele;
          if (ele && ele.style) {
            for (var prop in styles) {
              if (ele['$style-' + prop] !== styles[prop]) {
                ele.style[prop] = ele['$style-' + prop] = styles[prop];
              }
            }
          }
        }
      };
      ionic.requestAnimationFrame = ionic.DomUtil.requestAnimationFrame;
      ionic.cancelAnimationFrame = ionic.DomUtil.cancelAnimationFrame;
      ionic.animationFrameThrottle = ionic.DomUtil.animationFrameThrottle;
    })(window, document, ionic);
    (function(ionic) {
      ionic.CustomEvent = (function() {
        if (typeof window.CustomEvent === 'function')
          return CustomEvent;
        var customEvent = function(event, params) {
          var evt;
          params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
          };
          try {
            evt = document.createEvent("CustomEvent");
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
          } catch (error) {
            evt = document.createEvent("Event");
            for (var param in params) {
              evt[param] = params[param];
            }
            evt.initEvent(event, params.bubbles, params.cancelable);
          }
          return evt;
        };
        customEvent.prototype = window.Event.prototype;
        return customEvent;
      })();
      ionic.EventController = {
        VIRTUALIZED_EVENTS: ['tap', 'swipe', 'swiperight', 'swipeleft', 'drag', 'hold', 'release'],
        trigger: function(eventType, data, bubbles, cancelable) {
          var event = new ionic.CustomEvent(eventType, {
            detail: data,
            bubbles: !!bubbles,
            cancelable: !!cancelable
          });
          data && data.target && data.target.dispatchEvent && data.target.dispatchEvent(event) || window.dispatchEvent(event);
        },
        on: function(type, callback, element) {
          var e = element || window;
          for (var i = 0,
              j = this.VIRTUALIZED_EVENTS.length; i < j; i++) {
            if (type == this.VIRTUALIZED_EVENTS[i]) {
              var gesture = new ionic.Gesture(element);
              gesture.on(type, callback);
              return gesture;
            }
          }
          e.addEventListener(type, callback);
        },
        off: function(type, callback, element) {
          element.removeEventListener(type, callback);
        },
        onGesture: function(type, callback, element, options) {
          var gesture = new ionic.Gesture(element, options);
          gesture.on(type, callback);
          return gesture;
        },
        offGesture: function(gesture, type, callback) {
          gesture && gesture.off(type, callback);
        },
        handlePopState: function() {}
      };
      ionic.on = function() {
        ionic.EventController.on.apply(ionic.EventController, arguments);
      };
      ionic.off = function() {
        ionic.EventController.off.apply(ionic.EventController, arguments);
      };
      ionic.trigger = ionic.EventController.trigger;
      ionic.onGesture = function() {
        return ionic.EventController.onGesture.apply(ionic.EventController.onGesture, arguments);
      };
      ionic.offGesture = function() {
        return ionic.EventController.offGesture.apply(ionic.EventController.offGesture, arguments);
      };
    })(window.ionic);
    (function(ionic) {
      ionic.Gesture = function(element, options) {
        return new ionic.Gestures.Instance(element, options || {});
      };
      ionic.Gestures = {};
      ionic.Gestures.defaults = {stop_browser_behavior: 'disable-user-behavior'};
      ionic.Gestures.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;
      ionic.Gestures.HAS_TOUCHEVENTS = ('ontouchstart' in window);
      ionic.Gestures.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;
      ionic.Gestures.NO_MOUSEEVENTS = ionic.Gestures.HAS_TOUCHEVENTS && window.navigator.userAgent.match(ionic.Gestures.MOBILE_REGEX);
      ionic.Gestures.EVENT_TYPES = {};
      ionic.Gestures.DIRECTION_DOWN = 'down';
      ionic.Gestures.DIRECTION_LEFT = 'left';
      ionic.Gestures.DIRECTION_UP = 'up';
      ionic.Gestures.DIRECTION_RIGHT = 'right';
      ionic.Gestures.POINTER_MOUSE = 'mouse';
      ionic.Gestures.POINTER_TOUCH = 'touch';
      ionic.Gestures.POINTER_PEN = 'pen';
      ionic.Gestures.EVENT_START = 'start';
      ionic.Gestures.EVENT_MOVE = 'move';
      ionic.Gestures.EVENT_END = 'end';
      ionic.Gestures.DOCUMENT = window.document;
      ionic.Gestures.plugins = {};
      ionic.Gestures.READY = false;
      function setup() {
        if (ionic.Gestures.READY) {
          return;
        }
        ionic.Gestures.event.determineEventTypes();
        for (var name in ionic.Gestures.gestures) {
          if (ionic.Gestures.gestures.hasOwnProperty(name)) {
            ionic.Gestures.detection.register(ionic.Gestures.gestures[name]);
          }
        }
        ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_MOVE, ionic.Gestures.detection.detect);
        ionic.Gestures.event.onTouch(ionic.Gestures.DOCUMENT, ionic.Gestures.EVENT_END, ionic.Gestures.detection.detect);
        ionic.Gestures.READY = true;
      }
      ionic.Gestures.Instance = function(element, options) {
        var self = this;
        if (element === null) {
          void 0;
          return this;
        }
        setup();
        this.element = element;
        this.enabled = true;
        this.options = ionic.Gestures.utils.extend(ionic.Gestures.utils.extend({}, ionic.Gestures.defaults), options || {});
        if (this.options.stop_browser_behavior) {
          ionic.Gestures.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
        }
        ionic.Gestures.event.onTouch(element, ionic.Gestures.EVENT_START, function(ev) {
          if (self.enabled) {
            ionic.Gestures.detection.startDetect(self, ev);
          }
        });
        return this;
      };
      ionic.Gestures.Instance.prototype = {
        on: function onEvent(gesture, handler) {
          var gestures = gesture.split(' ');
          for (var t = 0; t < gestures.length; t++) {
            this.element.addEventListener(gestures[t], handler, false);
          }
          return this;
        },
        off: function offEvent(gesture, handler) {
          var gestures = gesture.split(' ');
          for (var t = 0; t < gestures.length; t++) {
            this.element.removeEventListener(gestures[t], handler, false);
          }
          return this;
        },
        trigger: function triggerEvent(gesture, eventData) {
          var event = ionic.Gestures.DOCUMENT.createEvent('Event');
          event.initEvent(gesture, true, true);
          event.gesture = eventData;
          var element = this.element;
          if (ionic.Gestures.utils.hasParent(eventData.target, element)) {
            element = eventData.target;
          }
          element.dispatchEvent(event);
          return this;
        },
        enable: function enable(state) {
          this.enabled = state;
          return this;
        }
      };
      var last_move_event = null;
      var enable_detect = false;
      var touch_triggered = false;
      ionic.Gestures.event = {
        bindDom: function(element, type, handler) {
          var types = type.split(' ');
          for (var t = 0; t < types.length; t++) {
            element.addEventListener(types[t], handler, false);
          }
        },
        onTouch: function onTouch(element, eventType, handler) {
          var self = this;
          this.bindDom(element, ionic.Gestures.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
            var sourceEventType = ev.type.toLowerCase();
            if (sourceEventType.match(/mouse/) && touch_triggered) {
              return;
            } else if (sourceEventType.match(/touch/) || sourceEventType.match(/pointerdown/) || (sourceEventType.match(/mouse/) && ev.which === 1)) {
              enable_detect = true;
            } else if (sourceEventType.match(/mouse/) && ev.which !== 1) {
              enable_detect = false;
            }
            if (sourceEventType.match(/touch|pointer/)) {
              touch_triggered = true;
            }
            var count_touches = 0;
            if (enable_detect) {
              if (ionic.Gestures.HAS_POINTEREVENTS && eventType != ionic.Gestures.EVENT_END) {
                count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
              } else if (sourceEventType.match(/touch/)) {
                count_touches = ev.touches.length;
              } else if (!touch_triggered) {
                count_touches = sourceEventType.match(/up/) ? 0 : 1;
              }
              if (count_touches > 0 && eventType == ionic.Gestures.EVENT_END) {
                eventType = ionic.Gestures.EVENT_MOVE;
              } else if (!count_touches) {
                eventType = ionic.Gestures.EVENT_END;
              }
              if (count_touches || last_move_event === null) {
                last_move_event = ev;
              }
              handler.call(ionic.Gestures.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));
              if (ionic.Gestures.HAS_POINTEREVENTS && eventType == ionic.Gestures.EVENT_END) {
                count_touches = ionic.Gestures.PointerEvent.updatePointer(eventType, ev);
              }
            }
            if (!count_touches) {
              last_move_event = null;
              enable_detect = false;
              touch_triggered = false;
              ionic.Gestures.PointerEvent.reset();
            }
          });
        },
        determineEventTypes: function determineEventTypes() {
          var types;
          if (ionic.Gestures.HAS_POINTEREVENTS) {
            types = ionic.Gestures.PointerEvent.getEvents();
          } else if (ionic.Gestures.NO_MOUSEEVENTS) {
            types = ['touchstart', 'touchmove', 'touchend touchcancel'];
          } else {
            types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
          }
          ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_START] = types[0];
          ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_MOVE] = types[1];
          ionic.Gestures.EVENT_TYPES[ionic.Gestures.EVENT_END] = types[2];
        },
        getTouchList: function getTouchList(ev) {
          if (ionic.Gestures.HAS_POINTEREVENTS) {
            return ionic.Gestures.PointerEvent.getTouchList();
          } else if (ev.touches) {
            return ev.touches;
          } else {
            ev.identifier = 1;
            return [ev];
          }
        },
        collectEventData: function collectEventData(element, eventType, touches, ev) {
          var pointerType = ionic.Gestures.POINTER_TOUCH;
          if (ev.type.match(/mouse/) || ionic.Gestures.PointerEvent.matchType(ionic.Gestures.POINTER_MOUSE, ev)) {
            pointerType = ionic.Gestures.POINTER_MOUSE;
          }
          return {
            center: ionic.Gestures.utils.getCenter(touches),
            timeStamp: new Date().getTime(),
            target: ev.target,
            touches: touches,
            eventType: eventType,
            pointerType: pointerType,
            srcEvent: ev,
            preventDefault: function() {
              if (this.srcEvent.preventManipulation) {
                this.srcEvent.preventManipulation();
              }
              if (this.srcEvent.preventDefault) {}
            },
            stopPropagation: function() {
              this.srcEvent.stopPropagation();
            },
            stopDetect: function() {
              return ionic.Gestures.detection.stopDetect();
            }
          };
        }
      };
      ionic.Gestures.PointerEvent = {
        pointers: {},
        getTouchList: function() {
          var self = this;
          var touchlist = [];
          Object.keys(self.pointers).sort().forEach(function(id) {
            touchlist.push(self.pointers[id]);
          });
          return touchlist;
        },
        updatePointer: function(type, pointerEvent) {
          if (type == ionic.Gestures.EVENT_END) {
            this.pointers = {};
          } else {
            pointerEvent.identifier = pointerEvent.pointerId;
            this.pointers[pointerEvent.pointerId] = pointerEvent;
          }
          return Object.keys(this.pointers).length;
        },
        matchType: function(pointerType, ev) {
          if (!ev.pointerType) {
            return false;
          }
          var types = {};
          types[ionic.Gestures.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == ionic.Gestures.POINTER_MOUSE);
          types[ionic.Gestures.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == ionic.Gestures.POINTER_TOUCH);
          types[ionic.Gestures.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == ionic.Gestures.POINTER_PEN);
          return types[pointerType];
        },
        getEvents: function() {
          return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];
        },
        reset: function() {
          this.pointers = {};
        }
      };
      ionic.Gestures.utils = {
        extend: function extend(dest, src, merge) {
          for (var key in src) {
            if (dest[key] !== undefined && merge) {
              continue;
            }
            dest[key] = src[key];
          }
          return dest;
        },
        hasParent: function(node, parent) {
          while (node) {
            if (node == parent) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        },
        getCenter: function getCenter(touches) {
          var valuesX = [],
              valuesY = [];
          for (var t = 0,
              len = touches.length; t < len; t++) {
            valuesX.push(touches[t].pageX);
            valuesY.push(touches[t].pageY);
          }
          return {
            pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
            pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
          };
        },
        getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
          return {
            x: Math.abs(delta_x / delta_time) || 0,
            y: Math.abs(delta_y / delta_time) || 0
          };
        },
        getAngle: function getAngle(touch1, touch2) {
          var y = touch2.pageY - touch1.pageY,
              x = touch2.pageX - touch1.pageX;
          return Math.atan2(y, x) * 180 / Math.PI;
        },
        getDirection: function getDirection(touch1, touch2) {
          var x = Math.abs(touch1.pageX - touch2.pageX),
              y = Math.abs(touch1.pageY - touch2.pageY);
          if (x >= y) {
            return touch1.pageX - touch2.pageX > 0 ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
          } else {
            return touch1.pageY - touch2.pageY > 0 ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
          }
        },
        getDistance: function getDistance(touch1, touch2) {
          var x = touch2.pageX - touch1.pageX,
              y = touch2.pageY - touch1.pageY;
          return Math.sqrt((x * x) + (y * y));
        },
        getScale: function getScale(start, end) {
          if (start.length >= 2 && end.length >= 2) {
            return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
          }
          return 1;
        },
        getRotation: function getRotation(start, end) {
          if (start.length >= 2 && end.length >= 2) {
            return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
          }
          return 0;
        },
        isVertical: function isVertical(direction) {
          return (direction == ionic.Gestures.DIRECTION_UP || direction == ionic.Gestures.DIRECTION_DOWN);
        },
        stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_class) {
          if (element && element.classList) {
            element.classList.add(css_class);
            element.onselectstart = function() {
              return false;
            };
          }
        }
      };
      ionic.Gestures.detection = {
        gestures: [],
        current: null,
        previous: null,
        stopped: false,
        startDetect: function startDetect(inst, eventData) {
          if (this.current) {
            return;
          }
          this.stopped = false;
          this.current = {
            inst: inst,
            startEvent: ionic.Gestures.utils.extend({}, eventData),
            lastEvent: false,
            name: ''
          };
          this.detect(eventData);
        },
        detect: function detect(eventData) {
          if (!this.current || this.stopped) {
            return null;
          }
          eventData = this.extendEventData(eventData);
          var inst_options = this.current.inst.options;
          for (var g = 0,
              len = this.gestures.length; g < len; g++) {
            var gesture = this.gestures[g];
            if (!this.stopped && inst_options[gesture.name] !== false) {
              if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                this.stopDetect();
                break;
              }
            }
          }
          if (this.current) {
            this.current.lastEvent = eventData;
          }
          if (eventData.eventType == ionic.Gestures.EVENT_END && !eventData.touches.length - 1) {
            this.stopDetect();
          }
          return eventData;
        },
        stopDetect: function stopDetect() {
          this.previous = ionic.Gestures.utils.extend({}, this.current);
          this.current = null;
          this.stopped = true;
        },
        extendEventData: function extendEventData(ev) {
          var startEv = this.current.startEvent;
          if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
            startEv.touches = [];
            for (var i = 0,
                len = ev.touches.length; i < len; i++) {
              startEv.touches.push(ionic.Gestures.utils.extend({}, ev.touches[i]));
            }
          }
          var delta_time = ev.timeStamp - startEv.timeStamp,
              delta_x = ev.center.pageX - startEv.center.pageX,
              delta_y = ev.center.pageY - startEv.center.pageY,
              velocity = ionic.Gestures.utils.getVelocity(delta_time, delta_x, delta_y);
          ionic.Gestures.utils.extend(ev, {
            deltaTime: delta_time,
            deltaX: delta_x,
            deltaY: delta_y,
            velocityX: velocity.x,
            velocityY: velocity.y,
            distance: ionic.Gestures.utils.getDistance(startEv.center, ev.center),
            angle: ionic.Gestures.utils.getAngle(startEv.center, ev.center),
            direction: ionic.Gestures.utils.getDirection(startEv.center, ev.center),
            scale: ionic.Gestures.utils.getScale(startEv.touches, ev.touches),
            rotation: ionic.Gestures.utils.getRotation(startEv.touches, ev.touches),
            startEvent: startEv
          });
          return ev;
        },
        register: function register(gesture) {
          var options = gesture.defaults || {};
          if (options[gesture.name] === undefined) {
            options[gesture.name] = true;
          }
          ionic.Gestures.utils.extend(ionic.Gestures.defaults, options, true);
          gesture.index = gesture.index || 1000;
          this.gestures.push(gesture);
          this.gestures.sort(function(a, b) {
            if (a.index < b.index) {
              return -1;
            }
            if (a.index > b.index) {
              return 1;
            }
            return 0;
          });
          return this.gestures;
        }
      };
      ionic.Gestures.gestures = ionic.Gestures.gestures || {};
      ionic.Gestures.gestures.Hold = {
        name: 'hold',
        index: 10,
        defaults: {
          hold_timeout: 500,
          hold_threshold: 9
        },
        timer: null,
        handler: function holdGesture(ev, inst) {
          switch (ev.eventType) {
            case ionic.Gestures.EVENT_START:
              clearTimeout(this.timer);
              ionic.Gestures.detection.current.name = this.name;
              this.timer = setTimeout(function() {
                if (ionic.Gestures.detection.current.name == 'hold') {
                  ionic.tap.cancelClick();
                  inst.trigger('hold', ev);
                }
              }, inst.options.hold_timeout);
              break;
            case ionic.Gestures.EVENT_MOVE:
              if (ev.distance > inst.options.hold_threshold) {
                clearTimeout(this.timer);
              }
              break;
            case ionic.Gestures.EVENT_END:
              clearTimeout(this.timer);
              break;
          }
        }
      };
      ionic.Gestures.gestures.Tap = {
        name: 'tap',
        index: 100,
        defaults: {
          tap_max_touchtime: 250,
          tap_max_distance: 10,
          tap_always: true,
          doubletap_distance: 20,
          doubletap_interval: 300
        },
        handler: function tapGesture(ev, inst) {
          if (ev.eventType == ionic.Gestures.EVENT_END && ev.srcEvent.type != 'touchcancel') {
            var prev = ionic.Gestures.detection.previous,
                did_doubletap = false;
            if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {
              return;
            }
            if (prev && prev.name == 'tap' && (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {
              inst.trigger('doubletap', ev);
              did_doubletap = true;
            }
            if (!did_doubletap || inst.options.tap_always) {
              ionic.Gestures.detection.current.name = 'tap';
              inst.trigger('tap', ev);
            }
          }
        }
      };
      ionic.Gestures.gestures.Swipe = {
        name: 'swipe',
        index: 40,
        defaults: {
          swipe_max_touches: 1,
          swipe_velocity: 0.4
        },
        handler: function swipeGesture(ev, inst) {
          if (ev.eventType == ionic.Gestures.EVENT_END) {
            if (inst.options.swipe_max_touches > 0 && ev.touches.length > inst.options.swipe_max_touches) {
              return;
            }
            if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {
              inst.trigger(this.name, ev);
              inst.trigger(this.name + ev.direction, ev);
            }
          }
        }
      };
      ionic.Gestures.gestures.Drag = {
        name: 'drag',
        index: 50,
        defaults: {
          drag_min_distance: 10,
          correct_for_drag_min_distance: true,
          drag_max_touches: 1,
          drag_block_horizontal: true,
          drag_block_vertical: true,
          drag_lock_to_axis: false,
          drag_lock_min_distance: 25,
          prevent_default_directions: []
        },
        triggered: false,
        handler: function dragGesture(ev, inst) {
          if (ev.srcEvent.type == 'touchstart' || ev.srcEvent.type == 'touchend') {
            this.preventedFirstMove = false;
          } else if (!this.preventedFirstMove && ev.srcEvent.type == 'touchmove') {
            if (inst.options.prevent_default_directions.length > 0 && inst.options.prevent_default_directions.indexOf(ev.direction) != -1) {
              ev.srcEvent.preventDefault();
            }
            this.preventedFirstMove = true;
          }
          if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name + 'end', ev);
            this.triggered = false;
            return;
          }
          if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {
            return;
          }
          switch (ev.eventType) {
            case ionic.Gestures.EVENT_START:
              this.triggered = false;
              break;
            case ionic.Gestures.EVENT_MOVE:
              if (ev.distance < inst.options.drag_min_distance && ionic.Gestures.detection.current.name != this.name) {
                return;
              }
              if (ionic.Gestures.detection.current.name != this.name) {
                ionic.Gestures.detection.current.name = this.name;
                if (inst.options.correct_for_drag_min_distance) {
                  var factor = Math.abs(inst.options.drag_min_distance / ev.distance);
                  ionic.Gestures.detection.current.startEvent.center.pageX += ev.deltaX * factor;
                  ionic.Gestures.detection.current.startEvent.center.pageY += ev.deltaY * factor;
                  ev = ionic.Gestures.detection.extendEventData(ev);
                }
              }
              if (ionic.Gestures.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
                ev.drag_locked_to_axis = true;
              }
              var last_direction = ionic.Gestures.detection.current.lastEvent.direction;
              if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
                if (ionic.Gestures.utils.isVertical(last_direction)) {
                  ev.direction = (ev.deltaY < 0) ? ionic.Gestures.DIRECTION_UP : ionic.Gestures.DIRECTION_DOWN;
                } else {
                  ev.direction = (ev.deltaX < 0) ? ionic.Gestures.DIRECTION_LEFT : ionic.Gestures.DIRECTION_RIGHT;
                }
              }
              if (!this.triggered) {
                inst.trigger(this.name + 'start', ev);
                this.triggered = true;
              }
              inst.trigger(this.name, ev);
              inst.trigger(this.name + ev.direction, ev);
              if ((inst.options.drag_block_vertical && ionic.Gestures.utils.isVertical(ev.direction)) || (inst.options.drag_block_horizontal && !ionic.Gestures.utils.isVertical(ev.direction))) {
                ev.preventDefault();
              }
              break;
            case ionic.Gestures.EVENT_END:
              if (this.triggered) {
                inst.trigger(this.name + 'end', ev);
              }
              this.triggered = false;
              break;
          }
        }
      };
      ionic.Gestures.gestures.Transform = {
        name: 'transform',
        index: 45,
        defaults: {
          transform_min_scale: 0.01,
          transform_min_rotation: 1,
          transform_always_block: false
        },
        triggered: false,
        handler: function transformGesture(ev, inst) {
          if (ionic.Gestures.detection.current.name != this.name && this.triggered) {
            inst.trigger(this.name + 'end', ev);
            this.triggered = false;
            return;
          }
          if (ev.touches.length < 2) {
            return;
          }
          if (inst.options.transform_always_block) {
            ev.preventDefault();
          }
          switch (ev.eventType) {
            case ionic.Gestures.EVENT_START:
              this.triggered = false;
              break;
            case ionic.Gestures.EVENT_MOVE:
              var scale_threshold = Math.abs(1 - ev.scale);
              var rotation_threshold = Math.abs(ev.rotation);
              if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {
                return;
              }
              ionic.Gestures.detection.current.name = this.name;
              if (!this.triggered) {
                inst.trigger(this.name + 'start', ev);
                this.triggered = true;
              }
              inst.trigger(this.name, ev);
              if (rotation_threshold > inst.options.transform_min_rotation) {
                inst.trigger('rotate', ev);
              }
              if (scale_threshold > inst.options.transform_min_scale) {
                inst.trigger('pinch', ev);
                inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
              }
              break;
            case ionic.Gestures.EVENT_END:
              if (this.triggered) {
                inst.trigger(this.name + 'end', ev);
              }
              this.triggered = false;
              break;
          }
        }
      };
      ionic.Gestures.gestures.Touch = {
        name: 'touch',
        index: -Infinity,
        defaults: {
          prevent_default: false,
          prevent_mouseevents: false
        },
        handler: function touchGesture(ev, inst) {
          if (inst.options.prevent_mouseevents && ev.pointerType == ionic.Gestures.POINTER_MOUSE) {
            ev.stopDetect();
            return;
          }
          if (inst.options.prevent_default) {
            ev.preventDefault();
          }
          if (ev.eventType == ionic.Gestures.EVENT_START) {
            inst.trigger(this.name, ev);
          }
        }
      };
      ionic.Gestures.gestures.Release = {
        name: 'release',
        index: Infinity,
        handler: function releaseGesture(ev, inst) {
          if (ev.eventType == ionic.Gestures.EVENT_END) {
            inst.trigger(this.name, ev);
          }
        }
      };
    })(window.ionic);
    (function(window, document, ionic) {
      function getParameterByName(name) {
        name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
        var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
            results = regex.exec(location.search);
        return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
      }
      var IOS = 'ios';
      var ANDROID = 'android';
      var WINDOWS_PHONE = 'windowsphone';
      var EDGE = 'edge';
      var CROSSWALK = 'crosswalk';
      var requestAnimationFrame = ionic.requestAnimationFrame;
      var self = ionic.Platform = {
        navigator: window.navigator,
        isReady: false,
        isFullScreen: false,
        platforms: null,
        grade: null,
        ua: navigator.userAgent,
        ready: function(cb) {
          if (self.isReady) {
            cb();
          } else {
            readyCallbacks.push(cb);
          }
        },
        detect: function() {
          self._checkPlatforms();
          requestAnimationFrame(function() {
            for (var i = 0; i < self.platforms.length; i++) {
              document.body.classList.add('platform-' + self.platforms[i]);
            }
          });
        },
        setGrade: function(grade) {
          var oldGrade = self.grade;
          self.grade = grade;
          requestAnimationFrame(function() {
            if (oldGrade) {
              document.body.classList.remove('grade-' + oldGrade);
            }
            document.body.classList.add('grade-' + grade);
          });
        },
        device: function() {
          return window.device || {};
        },
        _checkPlatforms: function() {
          self.platforms = [];
          var grade = 'a';
          if (self.isWebView()) {
            self.platforms.push('webview');
            if (!(!window.cordova && !window.PhoneGap && !window.phonegap)) {
              self.platforms.push('cordova');
            } else if (window.forge) {
              self.platforms.push('trigger');
            }
          } else {
            self.platforms.push('browser');
          }
          if (self.isIPad())
            self.platforms.push('ipad');
          var platform = self.platform();
          if (platform) {
            self.platforms.push(platform);
            var version = self.version();
            if (version) {
              var v = version.toString();
              if (v.indexOf('.') > 0) {
                v = v.replace('.', '_');
              } else {
                v += '_0';
              }
              self.platforms.push(platform + v.split('_')[0]);
              self.platforms.push(platform + v);
              if (self.isAndroid() && version < 4.4) {
                grade = (version < 4 ? 'c' : 'b');
              } else if (self.isWindowsPhone()) {
                grade = 'b';
              }
            }
          }
          self.setGrade(grade);
        },
        isWebView: function() {
          return !(!window.cordova && !window.PhoneGap && !window.phonegap && !window.forge);
        },
        isIPad: function() {
          if (/iPad/i.test(self.navigator.platform)) {
            return true;
          }
          return /iPad/i.test(self.ua);
        },
        isIOS: function() {
          return self.is(IOS);
        },
        isAndroid: function() {
          return self.is(ANDROID);
        },
        isWindowsPhone: function() {
          return self.is(WINDOWS_PHONE);
        },
        isEdge: function() {
          return self.is(EDGE);
        },
        isCrosswalk: function() {
          return self.is(CROSSWALK);
        },
        platform: function() {
          if (platformName === null)
            self.setPlatform(self.device().platform);
          return platformName;
        },
        setPlatform: function(n) {
          if (typeof n != 'undefined' && n !== null && n.length) {
            platformName = n.toLowerCase();
          } else if (getParameterByName('ionicplatform')) {
            platformName = getParameterByName('ionicplatform');
          } else if (self.ua.indexOf('Edge') > -1) {
            platformName = EDGE;
          } else if (self.ua.indexOf('Windows Phone') > -1) {
            platformName = WINDOWS_PHONE;
          } else if (self.ua.indexOf('Android') > 0) {
            platformName = ANDROID;
          } else if (/iPhone|iPad|iPod/.test(self.ua)) {
            platformName = IOS;
          } else {
            platformName = self.navigator.platform && navigator.platform.toLowerCase().split(' ')[0] || '';
          }
        },
        version: function() {
          if (platformVersion === null)
            self.setVersion(self.device().version);
          return platformVersion;
        },
        setVersion: function(v) {
          if (typeof v != 'undefined' && v !== null) {
            v = v.split('.');
            v = parseFloat(v[0] + '.' + (v.length > 1 ? v[1] : 0));
            if (!isNaN(v)) {
              platformVersion = v;
              return;
            }
          }
          platformVersion = 0;
          var pName = self.platform();
          var versionMatch = {
            'android': /Android (\d+).(\d+)?/,
            'ios': /OS (\d+)_(\d+)?/,
            'windowsphone': /Windows Phone (\d+).(\d+)?/
          };
          if (versionMatch[pName]) {
            v = self.ua.match(versionMatch[pName]);
            if (v && v.length > 2) {
              platformVersion = parseFloat(v[1] + '.' + v[2]);
            }
          }
        },
        is: function(type) {
          type = type.toLowerCase();
          if (self.platforms) {
            for (var x = 0; x < self.platforms.length; x++) {
              if (self.platforms[x] === type)
                return true;
            }
          }
          var pName = self.platform();
          if (pName) {
            return pName === type.toLowerCase();
          }
          return self.ua.toLowerCase().indexOf(type) >= 0;
        },
        exitApp: function() {
          self.ready(function() {
            navigator.app && navigator.app.exitApp && navigator.app.exitApp();
          });
        },
        showStatusBar: function(val) {
          self._showStatusBar = val;
          self.ready(function() {
            requestAnimationFrame(function() {
              if (self._showStatusBar) {
                window.StatusBar && window.StatusBar.show();
                document.body.classList.remove('status-bar-hide');
              } else {
                window.StatusBar && window.StatusBar.hide();
                document.body.classList.add('status-bar-hide');
              }
            });
          });
        },
        fullScreen: function(showFullScreen, showStatusBar) {
          self.isFullScreen = (showFullScreen !== false);
          ionic.DomUtil.ready(function() {
            requestAnimationFrame(function() {
              if (self.isFullScreen) {
                document.body.classList.add('fullscreen');
              } else {
                document.body.classList.remove('fullscreen');
              }
            });
            self.showStatusBar((showStatusBar === true));
          });
        }
      };
      var platformName = null,
          platformVersion = null,
          readyCallbacks = [],
          windowLoadListenderAttached,
          platformReadyTimer = 2000;
      verifyPlatformReady();
      function verifyPlatformReady() {
        setTimeout(function() {
          if (!self.isReady && self.isWebView()) {
            void 0;
          }
        }, platformReadyTimer);
      }
      function onWindowLoad() {
        if (self.isWebView()) {
          document.addEventListener("deviceready", onPlatformReady, false);
        } else {
          onPlatformReady();
        }
        if (windowLoadListenderAttached) {
          window.removeEventListener("load", onWindowLoad, false);
        }
      }
      if (document.readyState === 'complete') {
        onWindowLoad();
      } else {
        windowLoadListenderAttached = true;
        window.addEventListener("load", onWindowLoad, false);
      }
      function onPlatformReady() {
        self.isReady = true;
        self.detect();
        for (var x = 0; x < readyCallbacks.length; x++) {
          readyCallbacks[x]();
        }
        readyCallbacks = [];
        ionic.trigger('platformready', {target: document});
        requestAnimationFrame(function() {
          document.body.classList.add('platform-ready');
        });
      }
    })(window, document, ionic);
    (function(document, ionic) {
      'use strict';
      ionic.CSS = {};
      ionic.CSS.TRANSITION = [];
      ionic.CSS.TRANSFORM = [];
      ionic.EVENTS = {};
      (function() {
        var i,
            keys = ['webkitTransform', 'transform', '-webkit-transform', 'webkit-transform', '-moz-transform', 'moz-transform', 'MozTransform', 'mozTransform', 'msTransform'];
        for (i = 0; i < keys.length; i++) {
          if (document.documentElement.style[keys[i]] !== undefined) {
            ionic.CSS.TRANSFORM = keys[i];
            break;
          }
        }
        keys = ['webkitTransition', 'mozTransition', 'msTransition', 'transition'];
        for (i = 0; i < keys.length; i++) {
          if (document.documentElement.style[keys[i]] !== undefined) {
            ionic.CSS.TRANSITION = keys[i];
            break;
          }
        }
        ionic.CSS.TRANSITION = ionic.CSS.TRANSITION || 'transition';
        var isWebkit = ionic.CSS.TRANSITION.indexOf('webkit') > -1;
        ionic.CSS.TRANSITION_DURATION = (isWebkit ? '-webkit-' : '') + 'transition-duration';
        ionic.CSS.TRANSITIONEND = (isWebkit ? 'webkitTransitionEnd ' : '') + 'transitionend';
      })();
      (function() {
        var touchStartEvent = 'touchstart';
        var touchMoveEvent = 'touchmove';
        var touchEndEvent = 'touchend';
        var touchCancelEvent = 'touchcancel';
        if (window.navigator.pointerEnabled) {
          touchStartEvent = 'pointerdown';
          touchMoveEvent = 'pointermove';
          touchEndEvent = 'pointerup';
          touchCancelEvent = 'pointercancel';
        } else if (window.navigator.msPointerEnabled) {
          touchStartEvent = 'MSPointerDown';
          touchMoveEvent = 'MSPointerMove';
          touchEndEvent = 'MSPointerUp';
          touchCancelEvent = 'MSPointerCancel';
        }
        ionic.EVENTS.touchstart = touchStartEvent;
        ionic.EVENTS.touchmove = touchMoveEvent;
        ionic.EVENTS.touchend = touchEndEvent;
        ionic.EVENTS.touchcancel = touchCancelEvent;
      })();
      if (!("classList" in document.documentElement) && Object.defineProperty && typeof HTMLElement !== 'undefined') {
        Object.defineProperty(HTMLElement.prototype, 'classList', {get: function() {
            var self = this;
            function update(fn) {
              return function() {
                var x,
                    classes = self.className.split(/\s+/);
                for (x = 0; x < arguments.length; x++) {
                  fn(classes, classes.indexOf(arguments[x]), arguments[x]);
                }
                self.className = classes.join(" ");
              };
            }
            return {
              add: update(function(classes, index, value) {
                ~index || classes.push(value);
              }),
              remove: update(function(classes, index) {
                ~index && classes.splice(index, 1);
              }),
              toggle: update(function(classes, index, value) {
                ~index ? classes.splice(index, 1) : classes.push(value);
              }),
              contains: function(value) {
                return !!~self.className.split(/\s+/).indexOf(value);
              },
              item: function(i) {
                return self.className.split(/\s+/)[i] || null;
              }
            };
          }});
      }
    })(document, ionic);
    var tapDoc;
    var tapActiveEle;
    var tapEnabledTouchEvents;
    var tapMouseResetTimer;
    var tapPointerMoved;
    var tapPointerStart;
    var tapTouchFocusedInput;
    var tapLastTouchTarget;
    var tapTouchMoveListener = 'touchmove';
    var TAP_RELEASE_TOLERANCE = 12;
    var TAP_RELEASE_BUTTON_TOLERANCE = 50;
    var tapEventListeners = {
      'click': tapClickGateKeeper,
      'mousedown': tapMouseDown,
      'mouseup': tapMouseUp,
      'mousemove': tapMouseMove,
      'touchstart': tapTouchStart,
      'touchend': tapTouchEnd,
      'touchcancel': tapTouchCancel,
      'touchmove': tapTouchMove,
      'pointerdown': tapTouchStart,
      'pointerup': tapTouchEnd,
      'pointercancel': tapTouchCancel,
      'pointermove': tapTouchMove,
      'MSPointerDown': tapTouchStart,
      'MSPointerUp': tapTouchEnd,
      'MSPointerCancel': tapTouchCancel,
      'MSPointerMove': tapTouchMove,
      'focusin': tapFocusIn,
      'focusout': tapFocusOut
    };
    ionic.tap = {
      register: function(ele) {
        tapDoc = ele;
        tapEventListener('click', true, true);
        tapEventListener('mouseup');
        tapEventListener('mousedown');
        if (window.navigator.pointerEnabled) {
          tapEventListener('pointerdown');
          tapEventListener('pointerup');
          tapEventListener('pointercancel');
          tapTouchMoveListener = 'pointermove';
        } else if (window.navigator.msPointerEnabled) {
          tapEventListener('MSPointerDown');
          tapEventListener('MSPointerUp');
          tapEventListener('MSPointerCancel');
          tapTouchMoveListener = 'MSPointerMove';
        } else {
          tapEventListener('touchstart');
          tapEventListener('touchend');
          tapEventListener('touchcancel');
        }
        tapEventListener('focusin');
        tapEventListener('focusout');
        return function() {
          for (var type in tapEventListeners) {
            tapEventListener(type, false);
          }
          tapDoc = null;
          tapActiveEle = null;
          tapEnabledTouchEvents = false;
          tapPointerMoved = false;
          tapPointerStart = null;
        };
      },
      ignoreScrollStart: function(e) {
        return (e.defaultPrevented) || (/^(file|range)$/i).test(e.target.type) || (e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll')) == 'true' || (!!(/^(object|embed)$/i).test(e.target.tagName)) || ionic.tap.isElementTapDisabled(e.target);
      },
      isTextInput: function(ele) {
        return !!ele && (ele.tagName == 'TEXTAREA' || ele.contentEditable === 'true' || (ele.tagName == 'INPUT' && !(/^(radio|checkbox|range|file|submit|reset|color|image|button)$/i).test(ele.type)));
      },
      isDateInput: function(ele) {
        return !!ele && (ele.tagName == 'INPUT' && (/^(date|time|datetime-local|month|week)$/i).test(ele.type));
      },
      isVideo: function(ele) {
        return !!ele && (ele.tagName == 'VIDEO');
      },
      isKeyboardElement: function(ele) {
        if (!ionic.Platform.isIOS() || ionic.Platform.isIPad()) {
          return ionic.tap.isTextInput(ele) && !ionic.tap.isDateInput(ele);
        } else {
          return ionic.tap.isTextInput(ele) || (!!ele && ele.tagName == "SELECT");
        }
      },
      isLabelWithTextInput: function(ele) {
        var container = tapContainingElement(ele, false);
        return !!container && ionic.tap.isTextInput(tapTargetElement(container));
      },
      containsOrIsTextInput: function(ele) {
        return ionic.tap.isTextInput(ele) || ionic.tap.isLabelWithTextInput(ele);
      },
      cloneFocusedInput: function(container) {
        if (ionic.tap.hasCheckedClone)
          return;
        ionic.tap.hasCheckedClone = true;
        ionic.requestAnimationFrame(function() {
          var focusInput = container.querySelector(':focus');
          if (ionic.tap.isTextInput(focusInput) && !ionic.tap.isDateInput(focusInput)) {
            var clonedInput = focusInput.cloneNode(true);
            clonedInput.value = focusInput.value;
            clonedInput.classList.add('cloned-text-input');
            clonedInput.readOnly = true;
            if (focusInput.isContentEditable) {
              clonedInput.contentEditable = focusInput.contentEditable;
              clonedInput.innerHTML = focusInput.innerHTML;
            }
            focusInput.parentElement.insertBefore(clonedInput, focusInput);
            focusInput.classList.add('previous-input-focus');
            clonedInput.scrollTop = focusInput.scrollTop;
          }
        });
      },
      hasCheckedClone: false,
      removeClonedInputs: function(container) {
        ionic.tap.hasCheckedClone = false;
        ionic.requestAnimationFrame(function() {
          var clonedInputs = container.querySelectorAll('.cloned-text-input');
          var previousInputFocus = container.querySelectorAll('.previous-input-focus');
          var x;
          for (x = 0; x < clonedInputs.length; x++) {
            clonedInputs[x].parentElement.removeChild(clonedInputs[x]);
          }
          for (x = 0; x < previousInputFocus.length; x++) {
            previousInputFocus[x].classList.remove('previous-input-focus');
            previousInputFocus[x].style.top = '';
            if (ionic.keyboard.isOpen && !ionic.keyboard.isClosing)
              previousInputFocus[x].focus();
          }
        });
      },
      requiresNativeClick: function(ele) {
        if (ionic.Platform.isWindowsPhone() && (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click') || (ele.tagName == 'INPUT' && (ele.type == 'button' || ele.type == 'submit')))) {
          return true;
        }
        if (!ele || ele.disabled || (/^(file|range)$/i).test(ele.type) || (/^(object|video)$/i).test(ele.tagName) || ionic.tap.isLabelContainingFileInput(ele)) {
          return true;
        }
        return ionic.tap.isElementTapDisabled(ele);
      },
      isLabelContainingFileInput: function(ele) {
        var lbl = tapContainingElement(ele);
        if (lbl.tagName !== 'LABEL')
          return false;
        var fileInput = lbl.querySelector('input[type=file]');
        if (fileInput && fileInput.disabled === false)
          return true;
        return false;
      },
      isElementTapDisabled: function(ele) {
        if (ele && ele.nodeType === 1) {
          var element = ele;
          while (element) {
            if ((element.dataset ? element.dataset.tapDisabled : element.getAttribute && element.getAttribute('data-tap-disabled')) == 'true') {
              return true;
            }
            element = element.parentElement;
          }
        }
        return false;
      },
      setTolerance: function(releaseTolerance, releaseButtonTolerance) {
        TAP_RELEASE_TOLERANCE = releaseTolerance;
        TAP_RELEASE_BUTTON_TOLERANCE = releaseButtonTolerance;
      },
      cancelClick: function() {
        tapPointerMoved = true;
      },
      pointerCoord: function(event) {
        var c = {
          x: 0,
          y: 0
        };
        if (event) {
          var touches = event.touches && event.touches.length ? event.touches : [event];
          var e = (event.changedTouches && event.changedTouches[0]) || touches[0];
          if (e) {
            c.x = e.clientX || e.pageX || 0;
            c.y = e.clientY || e.pageY || 0;
          }
        }
        return c;
      }
    };
    function tapEventListener(type, enable, useCapture) {
      if (enable !== false) {
        tapDoc.addEventListener(type, tapEventListeners[type], useCapture);
      } else {
        tapDoc.removeEventListener(type, tapEventListeners[type]);
      }
    }
    function tapClick(e) {
      var container = tapContainingElement(e.target);
      var ele = tapTargetElement(container);
      if (ionic.tap.requiresNativeClick(ele) || tapPointerMoved)
        return false;
      var c = ionic.tap.pointerCoord(e);
      triggerMouseEvent('click', ele, c.x, c.y);
      tapHandleFocus(ele);
    }
    function triggerMouseEvent(type, ele, x, y) {
      var clickEvent = document.createEvent("MouseEvents");
      clickEvent.initMouseEvent(type, true, true, window, 1, 0, 0, x, y, false, false, false, false, 0, null);
      clickEvent.isIonicTap = true;
      ele.dispatchEvent(clickEvent);
    }
    function tapClickGateKeeper(e) {
      if (e.target.type == 'submit' && e.detail === 0) {
        return null;
      }
      if ((ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) || (!e.isIonicTap && !ionic.tap.requiresNativeClick(e.target))) {
        e.stopPropagation();
        if (!ionic.tap.isLabelWithTextInput(e.target)) {
          e.preventDefault();
        }
        return false;
      }
    }
    function tapMouseDown(e) {
      if (e.isIonicTap || tapIgnoreEvent(e))
        return null;
      if (tapEnabledTouchEvents) {
        e.stopPropagation();
        if (!ionic.Platform.isEdge() && (!ionic.tap.isTextInput(e.target) || tapLastTouchTarget !== e.target) && !isSelectOrOption(e.target.tagName) && !ionic.tap.isVideo(e.target)) {
          e.preventDefault();
        }
        return false;
      }
      tapPointerMoved = false;
      tapPointerStart = ionic.tap.pointerCoord(e);
      tapEventListener('mousemove');
      ionic.activator.start(e);
    }
    function tapMouseUp(e) {
      if (tapEnabledTouchEvents) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      }
      if (tapIgnoreEvent(e) || isSelectOrOption(e.target.tagName))
        return false;
      if (!tapHasPointerMoved(e)) {
        tapClick(e);
      }
      tapEventListener('mousemove', false);
      ionic.activator.end();
      tapPointerMoved = false;
    }
    function tapMouseMove(e) {
      if (tapHasPointerMoved(e)) {
        tapEventListener('mousemove', false);
        ionic.activator.end();
        tapPointerMoved = true;
        return false;
      }
    }
    function tapTouchStart(e) {
      if (tapIgnoreEvent(e))
        return;
      tapPointerMoved = false;
      tapEnableTouchEvents();
      tapPointerStart = ionic.tap.pointerCoord(e);
      tapEventListener(tapTouchMoveListener);
      ionic.activator.start(e);
      if (ionic.Platform.isIOS() && ionic.tap.isLabelWithTextInput(e.target)) {
        var textInput = tapTargetElement(tapContainingElement(e.target));
        if (textInput !== tapActiveEle) {
          e.preventDefault();
        }
      }
    }
    function tapTouchEnd(e) {
      if (tapIgnoreEvent(e))
        return;
      tapEnableTouchEvents();
      if (!tapHasPointerMoved(e)) {
        tapClick(e);
        if (isSelectOrOption(e.target.tagName)) {
          e.preventDefault();
        }
      }
      tapLastTouchTarget = e.target;
      tapTouchCancel();
    }
    function tapTouchMove(e) {
      if (tapHasPointerMoved(e)) {
        tapPointerMoved = true;
        tapEventListener(tapTouchMoveListener, false);
        ionic.activator.end();
        return false;
      }
    }
    function tapTouchCancel() {
      tapEventListener(tapTouchMoveListener, false);
      ionic.activator.end();
      tapPointerMoved = false;
    }
    function tapEnableTouchEvents() {
      tapEnabledTouchEvents = true;
      clearTimeout(tapMouseResetTimer);
      tapMouseResetTimer = setTimeout(function() {
        tapEnabledTouchEvents = false;
      }, 600);
    }
    function tapIgnoreEvent(e) {
      if (e.isTapHandled)
        return true;
      e.isTapHandled = true;
      if (ionic.tap.isElementTapDisabled(e.target)) {
        return true;
      }
      if (ionic.scroll.isScrolling && ionic.tap.containsOrIsTextInput(e.target)) {
        e.preventDefault();
        return true;
      }
    }
    function tapHandleFocus(ele) {
      tapTouchFocusedInput = null;
      var triggerFocusIn = false;
      if (ele.tagName == 'SELECT') {
        triggerMouseEvent('mousedown', ele, 0, 0);
        ele.focus && ele.focus();
        triggerFocusIn = true;
      } else if (tapActiveElement() === ele) {
        triggerFocusIn = true;
      } else if ((/^(input|textarea|ion-label)$/i).test(ele.tagName) || ele.isContentEditable) {
        triggerFocusIn = true;
        ele.focus && ele.focus();
        ele.value = ele.value;
        if (tapEnabledTouchEvents) {
          tapTouchFocusedInput = ele;
        }
      } else {
        tapFocusOutActive();
      }
      if (triggerFocusIn) {
        tapActiveElement(ele);
        ionic.trigger('ionic.focusin', {target: ele}, true);
      }
    }
    function tapFocusOutActive() {
      var ele = tapActiveElement();
      if (ele && ((/^(input|textarea|select)$/i).test(ele.tagName) || ele.isContentEditable)) {
        ele.blur();
      }
      tapActiveElement(null);
    }
    function tapFocusIn(e) {
      if (tapEnabledTouchEvents && ionic.tap.isTextInput(tapActiveElement()) && ionic.tap.isTextInput(tapTouchFocusedInput) && tapTouchFocusedInput !== e.target) {
        tapTouchFocusedInput.focus();
        tapTouchFocusedInput = null;
      }
      ionic.scroll.isScrolling = false;
    }
    function tapFocusOut() {
      tapActiveElement(null);
    }
    function tapActiveElement(ele) {
      if (arguments.length) {
        tapActiveEle = ele;
      }
      return tapActiveEle || document.activeElement;
    }
    function tapHasPointerMoved(endEvent) {
      if (!endEvent || endEvent.target.nodeType !== 1 || !tapPointerStart || (tapPointerStart.x === 0 && tapPointerStart.y === 0)) {
        return false;
      }
      var endCoordinates = ionic.tap.pointerCoord(endEvent);
      var hasClassList = !!(endEvent.target.classList && endEvent.target.classList.contains && typeof endEvent.target.classList.contains === 'function');
      var releaseTolerance = hasClassList && endEvent.target.classList.contains('button') ? TAP_RELEASE_BUTTON_TOLERANCE : TAP_RELEASE_TOLERANCE;
      return Math.abs(tapPointerStart.x - endCoordinates.x) > releaseTolerance || Math.abs(tapPointerStart.y - endCoordinates.y) > releaseTolerance;
    }
    function tapContainingElement(ele, allowSelf) {
      var climbEle = ele;
      for (var x = 0; x < 6; x++) {
        if (!climbEle)
          break;
        if (climbEle.tagName === 'LABEL')
          return climbEle;
        climbEle = climbEle.parentElement;
      }
      if (allowSelf !== false)
        return ele;
    }
    function tapTargetElement(ele) {
      if (ele && ele.tagName === 'LABEL') {
        if (ele.control)
          return ele.control;
        if (ele.querySelector) {
          var control = ele.querySelector('input,textarea,select');
          if (control)
            return control;
        }
      }
      return ele;
    }
    function isSelectOrOption(tagName) {
      return (/^(select|option)$/i).test(tagName);
    }
    ionic.DomUtil.ready(function() {
      var ng = typeof angular !== 'undefined' ? angular : null;
      if (!ng || (ng && !ng.scenario)) {
        ionic.tap.register(document);
      }
    });
    (function(document, ionic) {
      'use strict';
      var queueElements = {};
      var activeElements = {};
      var keyId = 0;
      var ACTIVATED_CLASS = 'activated';
      ionic.activator = {
        start: function(e) {
          var hitX = ionic.tap.pointerCoord(e).x;
          if (hitX > 0 && hitX < 30) {
            return;
          }
          ionic.requestAnimationFrame(function() {
            if ((ionic.scroll && ionic.scroll.isScrolling) || ionic.tap.requiresNativeClick(e.target))
              return;
            var ele = e.target;
            var eleToActivate;
            for (var x = 0; x < 6; x++) {
              if (!ele || ele.nodeType !== 1)
                break;
              if (eleToActivate && ele.classList && ele.classList.contains('item')) {
                eleToActivate = ele;
                break;
              }
              if (ele.tagName == 'A' || ele.tagName == 'BUTTON' || ele.hasAttribute('ng-click')) {
                eleToActivate = ele;
                break;
              }
              if (ele.classList.contains('button')) {
                eleToActivate = ele;
                break;
              }
              if (ele.tagName == 'ION-CONTENT' || (ele.classList && ele.classList.contains('pane')) || ele.tagName == 'BODY') {
                break;
              }
              ele = ele.parentElement;
            }
            if (eleToActivate) {
              queueElements[keyId] = eleToActivate;
              ionic.requestAnimationFrame(activateElements);
              keyId = (keyId > 29 ? 0 : keyId + 1);
            }
          });
        },
        end: function() {
          setTimeout(clear, 200);
        }
      };
      function clear() {
        queueElements = {};
        ionic.requestAnimationFrame(deactivateElements);
      }
      function activateElements() {
        for (var key in queueElements) {
          if (queueElements[key]) {
            queueElements[key].classList.add(ACTIVATED_CLASS);
            activeElements[key] = queueElements[key];
          }
        }
        queueElements = {};
      }
      function deactivateElements() {
        if (ionic.transition && ionic.transition.isActive) {
          setTimeout(deactivateElements, 400);
          return;
        }
        for (var key in activeElements) {
          if (activeElements[key]) {
            activeElements[key].classList.remove(ACTIVATED_CLASS);
            delete activeElements[key];
          }
        }
      }
    })(document, ionic);
    (function(ionic) {
      var nextId = 0;
      ionic.Utils = {
        arrayMove: function(arr, oldIndex, newIndex) {
          if (newIndex >= arr.length) {
            var k = newIndex - arr.length;
            while ((k--) + 1) {
              arr.push(undefined);
            }
          }
          arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);
          return arr;
        },
        proxy: function(func, context) {
          var args = Array.prototype.slice.call(arguments, 2);
          return function() {
            return func.apply(context, args.concat(Array.prototype.slice.call(arguments)));
          };
        },
        debounce: function(func, wait, immediate) {
          var timeout,
              args,
              context,
              timestamp,
              result;
          return function() {
            context = this;
            args = arguments;
            timestamp = new Date();
            var later = function() {
              var last = (new Date()) - timestamp;
              if (last < wait) {
                timeout = setTimeout(later, wait - last);
              } else {
                timeout = null;
                if (!immediate)
                  result = func.apply(context, args);
              }
            };
            var callNow = immediate && !timeout;
            if (!timeout) {
              timeout = setTimeout(later, wait);
            }
            if (callNow)
              result = func.apply(context, args);
            return result;
          };
        },
        throttle: function(func, wait, options) {
          var context,
              args,
              result;
          var timeout = null;
          var previous = 0;
          options || (options = {});
          var later = function() {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            result = func.apply(context, args);
          };
          return function() {
            var now = Date.now();
            if (!previous && options.leading === false)
              previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
              clearTimeout(timeout);
              timeout = null;
              previous = now;
              result = func.apply(context, args);
            } else if (!timeout && options.trailing !== false) {
              timeout = setTimeout(later, remaining);
            }
            return result;
          };
        },
        inherit: function(protoProps, staticProps) {
          var parent = this;
          var child;
          if (protoProps && protoProps.hasOwnProperty('constructor')) {
            child = protoProps.constructor;
          } else {
            child = function() {
              return parent.apply(this, arguments);
            };
          }
          ionic.extend(child, parent, staticProps);
          var Surrogate = function() {
            this.constructor = child;
          };
          Surrogate.prototype = parent.prototype;
          child.prototype = new Surrogate();
          if (protoProps)
            ionic.extend(child.prototype, protoProps);
          child.__super__ = parent.prototype;
          return child;
        },
        extend: function(obj) {
          var args = Array.prototype.slice.call(arguments, 1);
          for (var i = 0; i < args.length; i++) {
            var source = args[i];
            if (source) {
              for (var prop in source) {
                obj[prop] = source[prop];
              }
            }
          }
          return obj;
        },
        nextUid: function() {
          return 'ion' + (nextId++);
        },
        disconnectScope: function disconnectScope(scope) {
          if (!scope)
            return;
          if (scope.$root === scope) {
            return;
          }
          var parent = scope.$parent;
          scope.$$disconnected = true;
          scope.$broadcast('$ionic.disconnectScope', scope);
          if (parent.$$childHead === scope) {
            parent.$$childHead = scope.$$nextSibling;
          }
          if (parent.$$childTail === scope) {
            parent.$$childTail = scope.$$prevSibling;
          }
          if (scope.$$prevSibling) {
            scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
          }
          if (scope.$$nextSibling) {
            scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
          }
          scope.$$nextSibling = scope.$$prevSibling = null;
        },
        reconnectScope: function reconnectScope(scope) {
          if (!scope)
            return;
          if (scope.$root === scope) {
            return;
          }
          if (!scope.$$disconnected) {
            return;
          }
          var parent = scope.$parent;
          scope.$$disconnected = false;
          scope.$broadcast('$ionic.reconnectScope', scope);
          scope.$$prevSibling = parent.$$childTail;
          if (parent.$$childHead) {
            parent.$$childTail.$$nextSibling = scope;
            parent.$$childTail = scope;
          } else {
            parent.$$childHead = parent.$$childTail = scope;
          }
        },
        isScopeDisconnected: function(scope) {
          var climbScope = scope;
          while (climbScope) {
            if (climbScope.$$disconnected)
              return true;
            climbScope = climbScope.$parent;
          }
          return false;
        }
      };
      ionic.inherit = ionic.Utils.inherit;
      ionic.extend = ionic.Utils.extend;
      ionic.throttle = ionic.Utils.throttle;
      ionic.proxy = ionic.Utils.proxy;
      ionic.debounce = ionic.Utils.debounce;
    })(window.ionic);
    var keyboardCurrentViewportHeight = 0;
    var keyboardPortraitViewportHeight = 0;
    var keyboardLandscapeViewportHeight = 0;
    var keyboardActiveElement;
    var lastKeyboardActiveElement;
    var scrollView;
    var waitForResizeTimer;
    var keyboardFocusOutTimer;
    var wasOrientationChange = false;
    var KEYBOARD_OPEN_CSS = 'keyboard-open';
    var SCROLL_CONTAINER_CSS = 'scroll-content';
    var debouncedKeyboardFocusIn = ionic.debounce(keyboardFocusIn, 200, true);
    var debouncedKeyboardNativeShow = ionic.debounce(keyboardNativeShow, 100, true);
    ionic.keyboard = {
      isOpen: false,
      isClosing: false,
      isOpening: false,
      height: 0,
      isLandscape: false,
      isInitialized: false,
      hide: function() {
        if (keyboardHasPlugin()) {
          cordova.plugins.Keyboard.close();
        }
        keyboardActiveElement && keyboardActiveElement.blur();
      },
      show: function() {
        if (keyboardHasPlugin()) {
          cordova.plugins.Keyboard.show();
        }
      },
      disable: function() {
        if (keyboardHasPlugin()) {
          window.removeEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
          window.removeEventListener('native.keyboardhide', keyboardFocusOut);
        } else {
          document.body.removeEventListener('focusout', keyboardFocusOut);
        }
        document.body.removeEventListener('ionic.focusin', debouncedKeyboardFocusIn);
        document.body.removeEventListener('focusin', debouncedKeyboardFocusIn);
        window.removeEventListener('orientationchange', keyboardOrientationChange);
        if (window.navigator.msPointerEnabled) {
          document.removeEventListener("MSPointerDown", keyboardInit);
        } else {
          document.removeEventListener('touchstart', keyboardInit);
        }
        ionic.keyboard.isInitialized = false;
      },
      enable: function() {
        keyboardInit();
      }
    };
    keyboardCurrentViewportHeight = getViewportHeight();
    function keyboardInit() {
      if (ionic.keyboard.isInitialized)
        return;
      if (keyboardHasPlugin()) {
        window.addEventListener('native.keyboardshow', debouncedKeyboardNativeShow);
        window.addEventListener('native.keyboardhide', keyboardFocusOut);
      } else {
        document.body.addEventListener('focusout', keyboardFocusOut);
      }
      document.body.addEventListener('ionic.focusin', debouncedKeyboardFocusIn);
      document.body.addEventListener('focusin', debouncedKeyboardFocusIn);
      if (window.navigator.msPointerEnabled) {
        document.removeEventListener("MSPointerDown", keyboardInit);
      } else {
        document.removeEventListener('touchstart', keyboardInit);
      }
      ionic.keyboard.isInitialized = true;
    }
    function keyboardNativeShow(e) {
      clearTimeout(keyboardFocusOutTimer);
      if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
        ionic.keyboard.isOpening = true;
        ionic.keyboard.isClosing = false;
      }
      ionic.keyboard.height = e.keyboardHeight;
      if (wasOrientationChange) {
        keyboardWaitForResize(keyboardUpdateViewportHeight, true);
      } else {
        keyboardWaitForResize(keyboardShow, true);
      }
    }
    function keyboardFocusIn(e) {
      clearTimeout(keyboardFocusOutTimer);
      if (!e.target || e.target.readOnly || !ionic.tap.isKeyboardElement(e.target) || !(scrollView = ionic.DomUtil.getParentWithClass(e.target, SCROLL_CONTAINER_CSS))) {
        if (keyboardActiveElement) {
          lastKeyboardActiveElement = keyboardActiveElement;
        }
        keyboardActiveElement = null;
        return;
      }
      keyboardActiveElement = e.target;
      if (!scrollView.classList.contains("overflow-scroll")) {
        document.body.scrollTop = 0;
        scrollView.scrollTop = 0;
        ionic.requestAnimationFrame(function() {
          document.body.scrollTop = 0;
          scrollView.scrollTop = 0;
        });
        if (window.navigator.msPointerEnabled) {
          document.addEventListener("MSPointerMove", keyboardPreventDefault, false);
        } else {
          document.addEventListener('touchmove', keyboardPreventDefault, false);
        }
      }
      if (!ionic.keyboard.isOpen || ionic.keyboard.isClosing) {
        ionic.keyboard.isOpening = true;
        ionic.keyboard.isClosing = false;
      }
      document.addEventListener('keydown', keyboardOnKeyDown, false);
      if (!ionic.keyboard.isOpen && !keyboardHasPlugin()) {
        keyboardWaitForResize(keyboardShow, true);
      } else if (ionic.keyboard.isOpen) {
        keyboardShow();
      }
    }
    function keyboardFocusOut() {
      clearTimeout(keyboardFocusOutTimer);
      if (ionic.keyboard.isOpen || ionic.keyboard.isOpening) {
        ionic.keyboard.isClosing = true;
        ionic.keyboard.isOpening = false;
      }
      keyboardFocusOutTimer = setTimeout(function() {
        ionic.requestAnimationFrame(function() {
          if (wasOrientationChange) {
            keyboardWaitForResize(function() {
              keyboardUpdateViewportHeight();
              keyboardHide();
            }, false);
          } else {
            keyboardWaitForResize(keyboardHide, false);
          }
        });
      }, 50);
    }
    function keyboardOrientationChange() {
      ionic.keyboard.isLandscape = !ionic.keyboard.isLandscape;
      if (ionic.Platform.isIOS()) {
        keyboardUpdateViewportHeight();
      }
      if (ionic.Platform.isAndroid()) {
        if (!ionic.keyboard.isOpen || !keyboardHasPlugin()) {
          keyboardWaitForResize(keyboardUpdateViewportHeight, false);
        } else {
          wasOrientationChange = true;
        }
      }
    }
    function keyboardOnKeyDown(e) {
      if (ionic.scroll.isScrolling) {
        keyboardPreventDefault(e);
      }
    }
    function keyboardPreventDefault(e) {
      if (e.target.tagName !== 'TEXTAREA') {
        e.preventDefault();
      }
    }
    function keyboardWaitForResize(callback, isOpening) {
      clearInterval(waitForResizeTimer);
      var count = 0;
      var maxCount;
      var initialHeight = getViewportHeight();
      var viewportHeight = initialHeight;
      if (ionic.Platform.isAndroid() && ionic.Platform.version() < 4.4) {
        maxCount = 30;
      } else if (ionic.Platform.isAndroid()) {
        maxCount = 10;
      } else {
        maxCount = 1;
      }
      waitForResizeTimer = setInterval(function() {
        viewportHeight = getViewportHeight();
        if (++count < maxCount && ((!isPortraitViewportHeight(viewportHeight) && !isLandscapeViewportHeight(viewportHeight)) || !ionic.keyboard.height)) {
          return;
        }
        if (!keyboardHasPlugin()) {
          ionic.keyboard.height = Math.abs(initialHeight - window.innerHeight);
        }
        ionic.keyboard.isOpen = isOpening;
        clearInterval(waitForResizeTimer);
        callback();
      }, 50);
      return maxCount;
    }
    function keyboardHide() {
      clearTimeout(keyboardFocusOutTimer);
      ionic.keyboard.isOpen = false;
      ionic.keyboard.isClosing = false;
      if (keyboardActiveElement || lastKeyboardActiveElement) {
        ionic.trigger('resetScrollView', {target: keyboardActiveElement || lastKeyboardActiveElement}, true);
      }
      ionic.requestAnimationFrame(function() {
        document.body.classList.remove(KEYBOARD_OPEN_CSS);
      });
      if (window.navigator.msPointerEnabled) {
        document.removeEventListener("MSPointerMove", keyboardPreventDefault);
      } else {
        document.removeEventListener('touchmove', keyboardPreventDefault);
      }
      document.removeEventListener('keydown', keyboardOnKeyDown);
      if (ionic.Platform.isAndroid()) {
        if (keyboardHasPlugin())
          cordova.plugins.Keyboard.close();
        keyboardActiveElement && keyboardActiveElement.blur();
      }
      keyboardActiveElement = null;
      lastKeyboardActiveElement = null;
    }
    function keyboardShow() {
      ionic.keyboard.isOpen = true;
      ionic.keyboard.isOpening = false;
      var details = {
        keyboardHeight: keyboardGetHeight(),
        viewportHeight: keyboardCurrentViewportHeight
      };
      if (keyboardActiveElement) {
        details.target = keyboardActiveElement;
        var elementBounds = keyboardActiveElement.getBoundingClientRect();
        details.elementTop = Math.round(elementBounds.top);
        details.elementBottom = Math.round(elementBounds.bottom);
        details.windowHeight = details.viewportHeight - details.keyboardHeight;
        details.isElementUnderKeyboard = (details.elementBottom > details.windowHeight);
        ionic.trigger('scrollChildIntoView', details, true);
      }
      setTimeout(function() {
        document.body.classList.add(KEYBOARD_OPEN_CSS);
      }, 400);
      return details;
    }
    function keyboardGetHeight() {
      if (ionic.keyboard.height) {
        return ionic.keyboard.height;
      }
      if (ionic.Platform.isAndroid()) {
        if (ionic.Platform.isFullScreen) {
          return 275;
        }
        var contentHeight = window.innerHeight;
        if (contentHeight < keyboardCurrentViewportHeight) {
          return keyboardCurrentViewportHeight - contentHeight;
        } else {
          return 0;
        }
      }
      if (ionic.Platform.isIOS()) {
        if (ionic.keyboard.isLandscape) {
          return 206;
        }
        if (!ionic.Platform.isWebView()) {
          return 216;
        }
        return 260;
      }
      return 275;
    }
    function isPortraitViewportHeight(viewportHeight) {
      return !!(!ionic.keyboard.isLandscape && keyboardPortraitViewportHeight && (Math.abs(keyboardPortraitViewportHeight - viewportHeight) < 2));
    }
    function isLandscapeViewportHeight(viewportHeight) {
      return !!(ionic.keyboard.isLandscape && keyboardLandscapeViewportHeight && (Math.abs(keyboardLandscapeViewportHeight - viewportHeight) < 2));
    }
    function keyboardUpdateViewportHeight() {
      wasOrientationChange = false;
      keyboardCurrentViewportHeight = getViewportHeight();
      if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
        keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
      } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
        keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
      }
      if (keyboardActiveElement) {
        ionic.trigger('resetScrollView', {target: keyboardActiveElement}, true);
      }
      if (ionic.keyboard.isOpen && ionic.tap.isTextInput(keyboardActiveElement)) {
        keyboardShow();
      }
    }
    function keyboardInitViewportHeight() {
      var viewportHeight = getViewportHeight();
      if ((viewportHeight / window.innerWidth) < 1) {
        ionic.keyboard.isLandscape = true;
      }
      keyboardCurrentViewportHeight = viewportHeight;
      if (ionic.keyboard.isLandscape && !keyboardLandscapeViewportHeight) {
        keyboardLandscapeViewportHeight = keyboardCurrentViewportHeight;
      } else if (!ionic.keyboard.isLandscape && !keyboardPortraitViewportHeight) {
        keyboardPortraitViewportHeight = keyboardCurrentViewportHeight;
      }
    }
    function getViewportHeight() {
      var windowHeight = window.innerHeight;
      if (!(ionic.Platform.isAndroid() && ionic.Platform.isFullScreen) && (ionic.keyboard.isOpen || ionic.keyboard.isOpening) && !ionic.keyboard.isClosing) {
        return windowHeight + keyboardGetHeight();
      }
      return windowHeight;
    }
    function keyboardHasPlugin() {
      return !!(window.cordova && cordova.plugins && cordova.plugins.Keyboard);
    }
    ionic.Platform.ready(function() {
      keyboardInitViewportHeight();
      window.addEventListener('orientationchange', keyboardOrientationChange);
      setTimeout(keyboardInitViewportHeight, 999);
      if (window.navigator.msPointerEnabled) {
        document.addEventListener("MSPointerDown", keyboardInit, false);
      } else {
        document.addEventListener('touchstart', keyboardInit, false);
      }
    });
    var viewportTag;
    var viewportProperties = {};
    ionic.viewport = {orientation: function() {
        return (window.innerWidth > window.innerHeight ? 90 : 0);
      }};
    function viewportLoadTag() {
      var x;
      for (x = 0; x < document.head.children.length; x++) {
        if (document.head.children[x].name == 'viewport') {
          viewportTag = document.head.children[x];
          break;
        }
      }
      if (viewportTag) {
        var props = viewportTag.content.toLowerCase().replace(/\s+/g, '').split(',');
        var keyValue;
        for (x = 0; x < props.length; x++) {
          if (props[x]) {
            keyValue = props[x].split('=');
            viewportProperties[keyValue[0]] = (keyValue.length > 1 ? keyValue[1] : '_');
          }
        }
        viewportUpdate();
      }
    }
    function viewportUpdate() {
      var initWidth = viewportProperties.width;
      var initHeight = viewportProperties.height;
      var p = ionic.Platform;
      var version = p.version();
      var DEVICE_WIDTH = 'device-width';
      var DEVICE_HEIGHT = 'device-height';
      var orientation = ionic.viewport.orientation();
      delete viewportProperties.height;
      viewportProperties.width = DEVICE_WIDTH;
      if (p.isIPad()) {
        if (version > 7) {
          delete viewportProperties.width;
        } else {
          if (p.isWebView()) {
            if (orientation == 90) {
              viewportProperties.height = '0';
            } else if (version == 7) {
              viewportProperties.height = DEVICE_HEIGHT;
            }
          } else {
            if (version < 7) {
              viewportProperties.height = '0';
            }
          }
        }
      } else if (p.isIOS()) {
        if (p.isWebView()) {
          if (version > 7) {
            delete viewportProperties.width;
          } else if (version < 7) {
            if (initHeight)
              viewportProperties.height = '0';
          } else if (version == 7) {
            viewportProperties.height = DEVICE_HEIGHT;
          }
        } else {
          if (version < 7) {
            if (initHeight)
              viewportProperties.height = '0';
          }
        }
      }
      if (initWidth !== viewportProperties.width || initHeight !== viewportProperties.height) {
        viewportTagUpdate();
      }
    }
    function viewportTagUpdate() {
      var key,
          props = [];
      for (key in viewportProperties) {
        if (viewportProperties[key]) {
          props.push(key + (viewportProperties[key] == '_' ? '' : '=' + viewportProperties[key]));
        }
      }
      viewportTag.content = props.join(', ');
    }
    ionic.Platform.ready(function() {
      viewportLoadTag();
      window.addEventListener("orientationchange", function() {
        setTimeout(viewportUpdate, 1000);
      }, false);
    });
    (function(ionic) {
      'use strict';
      ionic.views.View = function() {
        this.initialize.apply(this, arguments);
      };
      ionic.views.View.inherit = ionic.inherit;
      ionic.extend(ionic.views.View.prototype, {initialize: function() {}});
    })(window.ionic);
    var zyngaCore = {effect: {}};
    (function(global) {
      var time = Date.now || function() {
        return +new Date();
      };
      var desiredFrames = 60;
      var millisecondsPerSecond = 1000;
      var running = {};
      var counter = 1;
      zyngaCore.effect.Animate = {
        requestAnimationFrame: (function() {
          var requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;
          var isNative = !!requestFrame;
          if (requestFrame && !/requestAnimationFrame\(\)\s*\{\s*\[native code\]\s*\}/i.test(requestFrame.toString())) {
            isNative = false;
          }
          if (isNative) {
            return function(callback, root) {
              requestFrame(callback, root);
            };
          }
          var TARGET_FPS = 60;
          var requests = {};
          var requestCount = 0;
          var rafHandle = 1;
          var intervalHandle = null;
          var lastActive = +new Date();
          return function(callback) {
            var callbackHandle = rafHandle++;
            requests[callbackHandle] = callback;
            requestCount++;
            if (intervalHandle === null) {
              intervalHandle = setInterval(function() {
                var time = +new Date();
                var currentRequests = requests;
                requests = {};
                requestCount = 0;
                for (var key in currentRequests) {
                  if (currentRequests.hasOwnProperty(key)) {
                    currentRequests[key](time);
                    lastActive = time;
                  }
                }
                if (time - lastActive > 2500) {
                  clearInterval(intervalHandle);
                  intervalHandle = null;
                }
              }, 1000 / TARGET_FPS);
            }
            return callbackHandle;
          };
        })(),
        stop: function(id) {
          var cleared = running[id] != null;
          if (cleared) {
            running[id] = null;
          }
          return cleared;
        },
        isRunning: function(id) {
          return running[id] != null;
        },
        start: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {
          var start = time();
          var lastFrame = start;
          var percent = 0;
          var dropCounter = 0;
          var id = counter++;
          if (!root) {
            root = document.body;
          }
          if (id % 20 === 0) {
            var newRunning = {};
            for (var usedId in running) {
              newRunning[usedId] = true;
            }
            running = newRunning;
          }
          var step = function(virtual) {
            var render = virtual !== true;
            var now = time();
            if (!running[id] || (verifyCallback && !verifyCallback(id))) {
              running[id] = null;
              completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);
              return;
            }
            if (render) {
              var droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;
              for (var j = 0; j < Math.min(droppedFrames, 4); j++) {
                step(true);
                dropCounter++;
              }
            }
            if (duration) {
              percent = (now - start) / duration;
              if (percent > 1) {
                percent = 1;
              }
            }
            var value = easingMethod ? easingMethod(percent) : percent;
            if ((stepCallback(value, now, render) === false || percent === 1) && render) {
              running[id] = null;
              completedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);
            } else if (render) {
              lastFrame = now;
              zyngaCore.effect.Animate.requestAnimationFrame(step, root);
            }
          };
          running[id] = true;
          zyngaCore.effect.Animate.requestAnimationFrame(step, root);
          return id;
        }
      };
    })(window);
    (function(ionic) {
      var NOOP = function() {};
      var easeOutCubic = function(pos) {
        return (Math.pow((pos - 1), 3) + 1);
      };
      var easeInOutCubic = function(pos) {
        if ((pos /= 0.5) < 1) {
          return 0.5 * Math.pow(pos, 3);
        }
        return 0.5 * (Math.pow((pos - 2), 3) + 2);
      };
      ionic.views.Scroll = ionic.views.View.inherit({
        initialize: function(options) {
          var self = this;
          self.__container = options.el;
          self.__content = options.el.firstElementChild;
          setTimeout(function() {
            if (self.__container && self.__content) {
              self.__container.scrollTop = 0;
              self.__content.scrollTop = 0;
            }
          });
          self.options = {
            scrollingX: false,
            scrollbarX: true,
            scrollingY: true,
            scrollbarY: true,
            startX: 0,
            startY: 0,
            wheelDampen: 6,
            minScrollbarSizeX: 5,
            minScrollbarSizeY: 5,
            scrollbarsFade: true,
            scrollbarFadeDelay: 300,
            scrollbarResizeFadeDelay: 1000,
            animating: true,
            animationDuration: 250,
            decelVelocityThreshold: 4,
            decelVelocityThresholdPaging: 4,
            bouncing: true,
            locking: true,
            paging: false,
            snapping: false,
            zooming: false,
            minZoom: 0.5,
            maxZoom: 3,
            speedMultiplier: 1,
            deceleration: 0.97,
            preventDefault: false,
            scrollingComplete: NOOP,
            penetrationDeceleration: 0.03,
            penetrationAcceleration: 0.08,
            scrollEventInterval: 10,
            freeze: false,
            getContentWidth: function() {
              return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
            },
            getContentHeight: function() {
              return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
            }
          };
          for (var key in options) {
            self.options[key] = options[key];
          }
          self.hintResize = ionic.debounce(function() {
            self.resize();
          }, 1000, true);
          self.onScroll = function() {
            if (!ionic.scroll.isScrolling) {
              setTimeout(self.setScrollStart, 50);
            } else {
              clearTimeout(self.scrollTimer);
              self.scrollTimer = setTimeout(self.setScrollStop, 80);
            }
          };
          self.freeze = function(shouldFreeze) {
            if (arguments.length) {
              self.options.freeze = shouldFreeze;
            }
            return self.options.freeze;
          };
          self.freezeShut = self.freeze;
          self.setScrollStart = function() {
            ionic.scroll.isScrolling = Math.abs(ionic.scroll.lastTop - self.__scrollTop) > 1;
            clearTimeout(self.scrollTimer);
            self.scrollTimer = setTimeout(self.setScrollStop, 80);
          };
          self.setScrollStop = function() {
            ionic.scroll.isScrolling = false;
            ionic.scroll.lastTop = self.__scrollTop;
          };
          self.triggerScrollEvent = ionic.throttle(function() {
            self.onScroll();
            ionic.trigger('scroll', {
              scrollTop: self.__scrollTop,
              scrollLeft: self.__scrollLeft,
              target: self.__container
            });
          }, self.options.scrollEventInterval);
          self.triggerScrollEndEvent = function() {
            ionic.trigger('scrollend', {
              scrollTop: self.__scrollTop,
              scrollLeft: self.__scrollLeft,
              target: self.__container
            });
          };
          self.__scrollLeft = self.options.startX;
          self.__scrollTop = self.options.startY;
          self.__callback = self.getRenderFn();
          self.__initEventHandlers();
          self.__createScrollbars();
        },
        run: function() {
          this.resize();
          this.__fadeScrollbars('out', this.options.scrollbarResizeFadeDelay);
        },
        __isSingleTouch: false,
        __isTracking: false,
        __didDecelerationComplete: false,
        __isGesturing: false,
        __isDragging: false,
        __isDecelerating: false,
        __isAnimating: false,
        __clientLeft: 0,
        __clientTop: 0,
        __clientWidth: 0,
        __clientHeight: 0,
        __contentWidth: 0,
        __contentHeight: 0,
        __snapWidth: 100,
        __snapHeight: 100,
        __refreshHeight: null,
        __refreshActive: false,
        __refreshActivate: null,
        __refreshDeactivate: null,
        __refreshStart: null,
        __zoomLevel: 1,
        __scrollLeft: 0,
        __scrollTop: 0,
        __maxScrollLeft: 0,
        __maxScrollTop: 0,
        __scheduledLeft: 0,
        __scheduledTop: 0,
        __scheduledZoom: 0,
        __lastTouchLeft: null,
        __lastTouchTop: null,
        __lastTouchMove: null,
        __positions: null,
        __minDecelerationScrollLeft: null,
        __minDecelerationScrollTop: null,
        __maxDecelerationScrollLeft: null,
        __maxDecelerationScrollTop: null,
        __decelerationVelocityX: null,
        __decelerationVelocityY: null,
        __transformProperty: null,
        __perspectiveProperty: null,
        __indicatorX: null,
        __indicatorY: null,
        __scrollbarFadeTimeout: null,
        __didWaitForSize: null,
        __sizerTimeout: null,
        __initEventHandlers: function() {
          var self = this;
          var container = self.__container;
          var scrollViewOffsetHeight;
          self.scrollChildIntoView = function(e) {
            var scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
            scrollViewOffsetHeight = container.offsetHeight;
            var alreadyShrunk = self.isShrunkForKeyboard;
            var isModal = container.parentNode.classList.contains('modal');
            var isInsetModal = isModal && window.innerWidth >= 680;
            if (!alreadyShrunk) {
              if (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal) {
                var scrollBottomOffsetToBottom = e.detail.viewportHeight - scrollBottomOffsetToTop;
                var keyboardOffset = Math.max(0, e.detail.keyboardHeight - scrollBottomOffsetToBottom);
                ionic.requestAnimationFrame(function() {
                  scrollViewOffsetHeight = scrollViewOffsetHeight - keyboardOffset;
                  container.style.height = scrollViewOffsetHeight + "px";
                  container.style.overflow = "visible";
                  self.resize();
                });
              }
              self.isShrunkForKeyboard = true;
            }
            if (e.detail.isElementUnderKeyboard) {
              ionic.requestAnimationFrame(function() {
                container.scrollTop = 0;
                if (self.isShrunkForKeyboard && !alreadyShrunk) {
                  scrollBottomOffsetToTop = container.getBoundingClientRect().bottom;
                }
                var scrollMidpointOffset = scrollViewOffsetHeight * 0.5;
                var inputMidpoint = ((e.detail.elementBottom + e.detail.elementTop) / 2);
                var inputMidpointOffsetToScrollBottom = inputMidpoint - scrollBottomOffsetToTop;
                var scrollTop = inputMidpointOffsetToScrollBottom + scrollMidpointOffset;
                if (scrollTop > 0) {
                  if (ionic.Platform.isIOS())
                    ionic.tap.cloneFocusedInput(container, self);
                  self.scrollBy(0, scrollTop, true);
                  self.onScroll();
                }
              });
            }
            e.stopPropagation();
          };
          self.resetScrollView = function() {
            if (self.isShrunkForKeyboard) {
              self.isShrunkForKeyboard = false;
              container.style.height = "";
              container.style.overflow = "";
            }
            self.resize();
          };
          container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
          document.addEventListener('resetScrollView', self.resetScrollView);
          function getEventTouches(e) {
            return e.touches && e.touches.length ? e.touches : [{
              pageX: e.pageX,
              pageY: e.pageY
            }];
          }
          self.touchStart = function(e) {
            self.startCoordinates = ionic.tap.pointerCoord(e);
            if (ionic.tap.ignoreScrollStart(e)) {
              return;
            }
            self.__isDown = true;
            if (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT') {
              self.__hasStarted = false;
              return;
            }
            self.__isSelectable = true;
            self.__enableScrollY = true;
            self.__hasStarted = true;
            self.doTouchStart(getEventTouches(e), e.timeStamp);
            e.preventDefault();
          };
          self.touchMove = function(e) {
            if (self.options.freeze || !self.__isDown || (!self.__isDown && e.defaultPrevented) || (e.target.tagName === 'TEXTAREA' && e.target.parentElement.querySelector(':focus'))) {
              return;
            }
            if (!self.__hasStarted && (ionic.tap.containsOrIsTextInput(e.target) || e.target.tagName === 'SELECT')) {
              self.__hasStarted = true;
              self.doTouchStart(getEventTouches(e), e.timeStamp);
              e.preventDefault();
              return;
            }
            if (self.startCoordinates) {
              var currentCoordinates = ionic.tap.pointerCoord(e);
              if (self.__isSelectable && ionic.tap.isTextInput(e.target) && Math.abs(self.startCoordinates.x - currentCoordinates.x) > 20) {
                self.__enableScrollY = false;
                self.__isSelectable = true;
              }
              if (self.__enableScrollY && Math.abs(self.startCoordinates.y - currentCoordinates.y) > 10) {
                self.__isSelectable = false;
                ionic.tap.cloneFocusedInput(container, self);
              }
            }
            self.doTouchMove(getEventTouches(e), e.timeStamp, e.scale);
            self.__isDown = true;
          };
          self.touchMoveBubble = function(e) {
            if (self.__isDown && self.options.preventDefault) {
              e.preventDefault();
            }
          };
          self.touchEnd = function(e) {
            if (!self.__isDown)
              return;
            self.doTouchEnd(e, e.timeStamp);
            self.__isDown = false;
            self.__hasStarted = false;
            self.__isSelectable = true;
            self.__enableScrollY = true;
            if (!self.__isDragging && !self.__isDecelerating && !self.__isAnimating) {
              ionic.tap.removeClonedInputs(container, self);
            }
          };
          self.mouseWheel = ionic.animationFrameThrottle(function(e) {
            var scrollParent = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'ionic-scroll');
            if (!self.options.freeze && scrollParent === self.__container) {
              self.hintResize();
              self.scrollBy((e.wheelDeltaX || e.deltaX || 0) / self.options.wheelDampen, (-e.wheelDeltaY || e.deltaY || 0) / self.options.wheelDampen);
              self.__fadeScrollbars('in');
              clearTimeout(self.__wheelHideBarTimeout);
              self.__wheelHideBarTimeout = setTimeout(function() {
                self.__fadeScrollbars('out');
              }, 100);
            }
          });
          if ('ontouchstart' in window) {
            container.addEventListener("touchstart", self.touchStart, false);
            if (self.options.preventDefault)
              container.addEventListener("touchmove", self.touchMoveBubble, false);
            document.addEventListener("touchmove", self.touchMove, false);
            document.addEventListener("touchend", self.touchEnd, false);
            document.addEventListener("touchcancel", self.touchEnd, false);
            document.addEventListener("wheel", self.mouseWheel, false);
          } else if (window.navigator.pointerEnabled) {
            container.addEventListener("pointerdown", self.touchStart, false);
            if (self.options.preventDefault)
              container.addEventListener("pointermove", self.touchMoveBubble, false);
            document.addEventListener("pointermove", self.touchMove, false);
            document.addEventListener("pointerup", self.touchEnd, false);
            document.addEventListener("pointercancel", self.touchEnd, false);
            document.addEventListener("wheel", self.mouseWheel, false);
          } else if (window.navigator.msPointerEnabled) {
            container.addEventListener("MSPointerDown", self.touchStart, false);
            if (self.options.preventDefault)
              container.addEventListener("MSPointerMove", self.touchMoveBubble, false);
            document.addEventListener("MSPointerMove", self.touchMove, false);
            document.addEventListener("MSPointerUp", self.touchEnd, false);
            document.addEventListener("MSPointerCancel", self.touchEnd, false);
            document.addEventListener("wheel", self.mouseWheel, false);
          } else {
            var mousedown = false;
            self.mouseDown = function(e) {
              if (ionic.tap.ignoreScrollStart(e) || e.target.tagName === 'SELECT') {
                return;
              }
              self.doTouchStart(getEventTouches(e), e.timeStamp);
              if (!ionic.tap.isTextInput(e.target)) {
                e.preventDefault();
              }
              mousedown = true;
            };
            self.mouseMove = function(e) {
              if (self.options.freeze || !mousedown || (!mousedown && e.defaultPrevented)) {
                return;
              }
              self.doTouchMove(getEventTouches(e), e.timeStamp);
              mousedown = true;
            };
            self.mouseMoveBubble = function(e) {
              if (mousedown && self.options.preventDefault) {
                e.preventDefault();
              }
            };
            self.mouseUp = function(e) {
              if (!mousedown) {
                return;
              }
              self.doTouchEnd(e, e.timeStamp);
              mousedown = false;
            };
            container.addEventListener("mousedown", self.mouseDown, false);
            if (self.options.preventDefault)
              container.addEventListener("mousemove", self.mouseMoveBubble, false);
            document.addEventListener("mousemove", self.mouseMove, false);
            document.addEventListener("mouseup", self.mouseUp, false);
            document.addEventListener('mousewheel', self.mouseWheel, false);
            document.addEventListener('wheel', self.mouseWheel, false);
          }
        },
        __cleanup: function() {
          var self = this;
          var container = self.__container;
          container.removeEventListener('touchstart', self.touchStart);
          container.removeEventListener('touchmove', self.touchMoveBubble);
          document.removeEventListener('touchmove', self.touchMove);
          document.removeEventListener('touchend', self.touchEnd);
          document.removeEventListener('touchcancel', self.touchEnd);
          container.removeEventListener("pointerdown", self.touchStart);
          container.removeEventListener("pointermove", self.touchMoveBubble);
          document.removeEventListener("pointermove", self.touchMove);
          document.removeEventListener("pointerup", self.touchEnd);
          document.removeEventListener("pointercancel", self.touchEnd);
          container.removeEventListener("MSPointerDown", self.touchStart);
          container.removeEventListener("MSPointerMove", self.touchMoveBubble);
          document.removeEventListener("MSPointerMove", self.touchMove);
          document.removeEventListener("MSPointerUp", self.touchEnd);
          document.removeEventListener("MSPointerCancel", self.touchEnd);
          container.removeEventListener("mousedown", self.mouseDown);
          container.removeEventListener("mousemove", self.mouseMoveBubble);
          document.removeEventListener("mousemove", self.mouseMove);
          document.removeEventListener("mouseup", self.mouseUp);
          document.removeEventListener('mousewheel', self.mouseWheel);
          document.removeEventListener('wheel', self.mouseWheel);
          container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
          document.removeEventListener('resetScrollView', self.resetScrollView);
          ionic.tap.removeClonedInputs(container, self);
          delete self.__container;
          delete self.__content;
          delete self.__indicatorX;
          delete self.__indicatorY;
          delete self.options.el;
          self.__callback = self.scrollChildIntoView = self.resetScrollView = NOOP;
          self.mouseMove = self.mouseDown = self.mouseUp = self.mouseWheel = self.touchStart = self.touchMove = self.touchEnd = self.touchCancel = NOOP;
          self.resize = self.scrollTo = self.zoomTo = self.__scrollingComplete = NOOP;
          container = null;
        },
        __createScrollbar: function(direction) {
          var bar = document.createElement('div'),
              indicator = document.createElement('div');
          indicator.className = 'scroll-bar-indicator scroll-bar-fade-out';
          if (direction == 'h') {
            bar.className = 'scroll-bar scroll-bar-h';
          } else {
            bar.className = 'scroll-bar scroll-bar-v';
          }
          bar.appendChild(indicator);
          return bar;
        },
        __createScrollbars: function() {
          var self = this;
          var indicatorX,
              indicatorY;
          if (self.options.scrollingX) {
            indicatorX = {
              el: self.__createScrollbar('h'),
              sizeRatio: 1
            };
            indicatorX.indicator = indicatorX.el.children[0];
            if (self.options.scrollbarX) {
              self.__container.appendChild(indicatorX.el);
            }
            self.__indicatorX = indicatorX;
          }
          if (self.options.scrollingY) {
            indicatorY = {
              el: self.__createScrollbar('v'),
              sizeRatio: 1
            };
            indicatorY.indicator = indicatorY.el.children[0];
            if (self.options.scrollbarY) {
              self.__container.appendChild(indicatorY.el);
            }
            self.__indicatorY = indicatorY;
          }
        },
        __resizeScrollbars: function() {
          var self = this;
          if (self.__indicatorX) {
            var width = Math.max(Math.round(self.__clientWidth * self.__clientWidth / (self.__contentWidth)), 20);
            if (width > self.__contentWidth) {
              width = 0;
            }
            if (width !== self.__indicatorX.size) {
              ionic.requestAnimationFrame(function() {
                self.__indicatorX.indicator.style.width = width + 'px';
              });
            }
            self.__indicatorX.size = width;
            self.__indicatorX.minScale = self.options.minScrollbarSizeX / width;
            self.__indicatorX.maxPos = self.__clientWidth - width;
            self.__indicatorX.sizeRatio = self.__maxScrollLeft ? self.__indicatorX.maxPos / self.__maxScrollLeft : 1;
          }
          if (self.__indicatorY) {
            var height = Math.max(Math.round(self.__clientHeight * self.__clientHeight / (self.__contentHeight)), 20);
            if (height > self.__contentHeight) {
              height = 0;
            }
            if (height !== self.__indicatorY.size) {
              ionic.requestAnimationFrame(function() {
                self.__indicatorY && (self.__indicatorY.indicator.style.height = height + 'px');
              });
            }
            self.__indicatorY.size = height;
            self.__indicatorY.minScale = self.options.minScrollbarSizeY / height;
            self.__indicatorY.maxPos = self.__clientHeight - height;
            self.__indicatorY.sizeRatio = self.__maxScrollTop ? self.__indicatorY.maxPos / self.__maxScrollTop : 1;
          }
        },
        __repositionScrollbars: function() {
          var self = this,
              heightScale,
              widthScale,
              widthDiff,
              heightDiff,
              x,
              y,
              xstop = 0,
              ystop = 0;
          if (self.__indicatorX) {
            if (self.__indicatorY)
              xstop = 10;
            x = Math.round(self.__indicatorX.sizeRatio * self.__scrollLeft) || 0;
            widthDiff = self.__scrollLeft - (self.__maxScrollLeft - xstop);
            if (self.__scrollLeft < 0) {
              widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - Math.abs(self.__scrollLeft)) / self.__indicatorX.size);
              x = 0;
              self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'left center';
            } else if (widthDiff > 0) {
              widthScale = Math.max(self.__indicatorX.minScale, (self.__indicatorX.size - widthDiff) / self.__indicatorX.size);
              x = self.__indicatorX.maxPos - xstop;
              self.__indicatorX.indicator.style[self.__transformOriginProperty] = 'right center';
            } else {
              x = Math.min(self.__maxScrollLeft, Math.max(0, x));
              widthScale = 1;
            }
            var translate3dX = 'translate3d(' + x + 'px, 0, 0) scaleX(' + widthScale + ')';
            if (self.__indicatorX.transformProp !== translate3dX) {
              self.__indicatorX.indicator.style[self.__transformProperty] = translate3dX;
              self.__indicatorX.transformProp = translate3dX;
            }
          }
          if (self.__indicatorY) {
            y = Math.round(self.__indicatorY.sizeRatio * self.__scrollTop) || 0;
            if (self.__indicatorX)
              ystop = 10;
            heightDiff = self.__scrollTop - (self.__maxScrollTop - ystop);
            if (self.__scrollTop < 0) {
              heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - Math.abs(self.__scrollTop)) / self.__indicatorY.size);
              y = 0;
              if (self.__indicatorY.originProp !== 'center top') {
                self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center top';
                self.__indicatorY.originProp = 'center top';
              }
            } else if (heightDiff > 0) {
              heightScale = Math.max(self.__indicatorY.minScale, (self.__indicatorY.size - heightDiff) / self.__indicatorY.size);
              y = self.__indicatorY.maxPos - ystop;
              if (self.__indicatorY.originProp !== 'center bottom') {
                self.__indicatorY.indicator.style[self.__transformOriginProperty] = 'center bottom';
                self.__indicatorY.originProp = 'center bottom';
              }
            } else {
              y = Math.min(self.__maxScrollTop, Math.max(0, y));
              heightScale = 1;
            }
            var translate3dY = 'translate3d(0,' + y + 'px, 0) scaleY(' + heightScale + ')';
            if (self.__indicatorY.transformProp !== translate3dY) {
              self.__indicatorY.indicator.style[self.__transformProperty] = translate3dY;
              self.__indicatorY.transformProp = translate3dY;
            }
          }
        },
        __fadeScrollbars: function(direction, delay) {
          var self = this;
          if (!self.options.scrollbarsFade) {
            return;
          }
          var className = 'scroll-bar-fade-out';
          if (self.options.scrollbarsFade === true) {
            clearTimeout(self.__scrollbarFadeTimeout);
            if (direction == 'in') {
              if (self.__indicatorX) {
                self.__indicatorX.indicator.classList.remove(className);
              }
              if (self.__indicatorY) {
                self.__indicatorY.indicator.classList.remove(className);
              }
            } else {
              self.__scrollbarFadeTimeout = setTimeout(function() {
                if (self.__indicatorX) {
                  self.__indicatorX.indicator.classList.add(className);
                }
                if (self.__indicatorY) {
                  self.__indicatorY.indicator.classList.add(className);
                }
              }, delay || self.options.scrollbarFadeDelay);
            }
          }
        },
        __scrollingComplete: function() {
          this.options.scrollingComplete();
          ionic.tap.removeClonedInputs(this.__container, this);
          this.__fadeScrollbars('out');
        },
        resize: function(continueScrolling) {
          var self = this;
          if (!self.__container || !self.options)
            return;
          self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
        },
        getRenderFn: function() {
          var self = this;
          var content = self.__content;
          var docStyle = document.documentElement.style;
          var engine;
          if ('MozAppearance' in docStyle) {
            engine = 'gecko';
          } else if ('WebkitAppearance' in docStyle) {
            engine = 'webkit';
          } else if (typeof navigator.cpuClass === 'string') {
            engine = 'trident';
          }
          var vendorPrefix = {
            trident: 'ms',
            gecko: 'Moz',
            webkit: 'Webkit',
            presto: 'O'
          }[engine];
          var helperElem = document.createElement("div");
          var undef;
          var perspectiveProperty = vendorPrefix + "Perspective";
          var transformProperty = vendorPrefix + "Transform";
          var transformOriginProperty = vendorPrefix + 'TransformOrigin';
          self.__perspectiveProperty = transformProperty;
          self.__transformProperty = transformProperty;
          self.__transformOriginProperty = transformOriginProperty;
          if (helperElem.style[perspectiveProperty] !== undef) {
            return function(left, top, zoom, wasResize) {
              var translate3d = 'translate3d(' + (-left) + 'px,' + (-top) + 'px,0) scale(' + zoom + ')';
              if (translate3d !== self.contentTransform) {
                content.style[transformProperty] = translate3d;
                self.contentTransform = translate3d;
              }
              self.__repositionScrollbars();
              if (!wasResize) {
                self.triggerScrollEvent();
              }
            };
          } else if (helperElem.style[transformProperty] !== undef) {
            return function(left, top, zoom, wasResize) {
              content.style[transformProperty] = 'translate(' + (-left) + 'px,' + (-top) + 'px) scale(' + zoom + ')';
              self.__repositionScrollbars();
              if (!wasResize) {
                self.triggerScrollEvent();
              }
            };
          } else {
            return function(left, top, zoom, wasResize) {
              content.style.marginLeft = left ? (-left / zoom) + 'px' : '';
              content.style.marginTop = top ? (-top / zoom) + 'px' : '';
              content.style.zoom = zoom || '';
              self.__repositionScrollbars();
              if (!wasResize) {
                self.triggerScrollEvent();
              }
            };
          }
        },
        setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight, continueScrolling) {
          var self = this;
          if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
            return;
          }
          if (clientWidth === +clientWidth) {
            self.__clientWidth = clientWidth;
          }
          if (clientHeight === +clientHeight) {
            self.__clientHeight = clientHeight;
          }
          if (contentWidth === +contentWidth) {
            self.__contentWidth = contentWidth;
          }
          if (contentHeight === +contentHeight) {
            self.__contentHeight = contentHeight;
          }
          self.__computeScrollMax();
          self.__resizeScrollbars();
          if (!continueScrolling) {
            self.scrollTo(self.__scrollLeft, self.__scrollTop, true, null, true);
          }
        },
        setPosition: function(left, top) {
          this.__clientLeft = left || 0;
          this.__clientTop = top || 0;
        },
        setSnapSize: function(width, height) {
          this.__snapWidth = width;
          this.__snapHeight = height;
        },
        activatePullToRefresh: function(height, refresherMethods) {
          var self = this;
          self.__refreshHeight = height;
          self.__refreshActivate = function() {
            ionic.requestAnimationFrame(refresherMethods.activate);
          };
          self.__refreshDeactivate = function() {
            ionic.requestAnimationFrame(refresherMethods.deactivate);
          };
          self.__refreshStart = function() {
            ionic.requestAnimationFrame(refresherMethods.start);
          };
          self.__refreshShow = function() {
            ionic.requestAnimationFrame(refresherMethods.show);
          };
          self.__refreshHide = function() {
            ionic.requestAnimationFrame(refresherMethods.hide);
          };
          self.__refreshTail = function() {
            ionic.requestAnimationFrame(refresherMethods.tail);
          };
          self.__refreshTailTime = 100;
          self.__minSpinTime = 600;
        },
        triggerPullToRefresh: function() {
          this.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);
          var d = new Date();
          this.refreshStartTime = d.getTime();
          if (this.__refreshStart) {
            this.__refreshStart();
          }
        },
        finishPullToRefresh: function() {
          var self = this;
          var d = new Date();
          var delay = 0;
          if (self.refreshStartTime + self.__minSpinTime > d.getTime()) {
            delay = self.refreshStartTime + self.__minSpinTime - d.getTime();
          }
          setTimeout(function() {
            if (self.__refreshTail) {
              self.__refreshTail();
            }
            setTimeout(function() {
              self.__refreshActive = false;
              if (self.__refreshDeactivate) {
                self.__refreshDeactivate();
              }
              if (self.__refreshHide) {
                self.__refreshHide();
              }
              self.scrollTo(self.__scrollLeft, self.__scrollTop, true);
            }, self.__refreshTailTime);
          }, delay);
        },
        getValues: function() {
          return {
            left: this.__scrollLeft,
            top: this.__scrollTop,
            zoom: this.__zoomLevel
          };
        },
        getScrollMax: function() {
          return {
            left: this.__maxScrollLeft,
            top: this.__maxScrollTop
          };
        },
        zoomTo: function(level, animate, originLeft, originTop) {
          var self = this;
          if (!self.options.zooming) {
            throw new Error("Zooming is not enabled!");
          }
          if (self.__isDecelerating) {
            zyngaCore.effect.Animate.stop(self.__isDecelerating);
            self.__isDecelerating = false;
          }
          var oldLevel = self.__zoomLevel;
          if (originLeft == null) {
            originLeft = self.__clientWidth / 2;
          }
          if (originTop == null) {
            originTop = self.__clientHeight / 2;
          }
          level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
          self.__computeScrollMax(level);
          var left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;
          var top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;
          if (left > self.__maxScrollLeft) {
            left = self.__maxScrollLeft;
          } else if (left < 0) {
            left = 0;
          }
          if (top > self.__maxScrollTop) {
            top = self.__maxScrollTop;
          } else if (top < 0) {
            top = 0;
          }
          self.__publish(left, top, level, animate);
        },
        zoomBy: function(factor, animate, originLeft, originTop) {
          this.zoomTo(this.__zoomLevel * factor, animate, originLeft, originTop);
        },
        scrollTo: function(left, top, animate, zoom, wasResize) {
          var self = this;
          if (self.__isDecelerating) {
            zyngaCore.effect.Animate.stop(self.__isDecelerating);
            self.__isDecelerating = false;
          }
          if (zoom != null && zoom !== self.__zoomLevel) {
            if (!self.options.zooming) {
              throw new Error("Zooming is not enabled!");
            }
            left *= zoom;
            top *= zoom;
            self.__computeScrollMax(zoom);
          } else {
            zoom = self.__zoomLevel;
          }
          if (!self.options.scrollingX) {
            left = self.__scrollLeft;
          } else {
            if (self.options.paging) {
              left = Math.round(left / self.__clientWidth) * self.__clientWidth;
            } else if (self.options.snapping) {
              left = Math.round(left / self.__snapWidth) * self.__snapWidth;
            }
          }
          if (!self.options.scrollingY) {
            top = self.__scrollTop;
          } else {
            if (self.options.paging) {
              top = Math.round(top / self.__clientHeight) * self.__clientHeight;
            } else if (self.options.snapping) {
              top = Math.round(top / self.__snapHeight) * self.__snapHeight;
            }
          }
          left = Math.max(Math.min(self.__maxScrollLeft, left), 0);
          top = Math.max(Math.min(self.__maxScrollTop, top), 0);
          if (left === self.__scrollLeft && top === self.__scrollTop) {
            animate = false;
          }
          self.__publish(left, top, zoom, animate, wasResize);
        },
        scrollBy: function(left, top, animate) {
          var self = this;
          var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
          var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
          self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
        },
        doMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {
          var change = wheelDelta > 0 ? 0.97 : 1.03;
          return this.zoomTo(this.__zoomLevel * change, false, pageX - this.__clientLeft, pageY - this.__clientTop);
        },
        doTouchStart: function(touches, timeStamp) {
          var self = this;
          self.__decStopped = !!(self.__isDecelerating || self.__isAnimating);
          self.hintResize();
          if (timeStamp instanceof Date) {
            timeStamp = timeStamp.valueOf();
          }
          if (typeof timeStamp !== "number") {
            timeStamp = Date.now();
          }
          self.__interruptedAnimation = true;
          if (self.__isDecelerating) {
            zyngaCore.effect.Animate.stop(self.__isDecelerating);
            self.__isDecelerating = false;
            self.__interruptedAnimation = true;
          }
          if (self.__isAnimating) {
            zyngaCore.effect.Animate.stop(self.__isAnimating);
            self.__isAnimating = false;
            self.__interruptedAnimation = true;
          }
          var currentTouchLeft,
              currentTouchTop;
          var isSingleTouch = touches.length === 1;
          if (isSingleTouch) {
            currentTouchLeft = touches[0].pageX;
            currentTouchTop = touches[0].pageY;
          } else {
            currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
            currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
          }
          self.__initialTouchLeft = currentTouchLeft;
          self.__initialTouchTop = currentTouchTop;
          self.__initialTouches = touches;
          self.__zoomLevelStart = self.__zoomLevel;
          self.__lastTouchLeft = currentTouchLeft;
          self.__lastTouchTop = currentTouchTop;
          self.__lastTouchMove = timeStamp;
          self.__lastScale = 1;
          self.__enableScrollX = !isSingleTouch && self.options.scrollingX;
          self.__enableScrollY = !isSingleTouch && self.options.scrollingY;
          self.__isTracking = true;
          self.__didDecelerationComplete = false;
          self.__isDragging = !isSingleTouch;
          self.__isSingleTouch = isSingleTouch;
          self.__positions = [];
        },
        doTouchMove: function(touches, timeStamp, scale) {
          if (timeStamp instanceof Date) {
            timeStamp = timeStamp.valueOf();
          }
          if (typeof timeStamp !== "number") {
            timeStamp = Date.now();
          }
          var self = this;
          if (!self.__isTracking) {
            return;
          }
          var currentTouchLeft,
              currentTouchTop;
          if (touches.length === 2) {
            currentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;
            currentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;
            if (!scale && self.options.zooming) {
              scale = self.__getScale(self.__initialTouches, touches);
            }
          } else {
            currentTouchLeft = touches[0].pageX;
            currentTouchTop = touches[0].pageY;
          }
          var positions = self.__positions;
          if (self.__isDragging) {
            self.__decStopped = false;
            var moveX = currentTouchLeft - self.__lastTouchLeft;
            var moveY = currentTouchTop - self.__lastTouchTop;
            var scrollLeft = self.__scrollLeft;
            var scrollTop = self.__scrollTop;
            var level = self.__zoomLevel;
            if (scale != null && self.options.zooming) {
              var oldLevel = level;
              level = level / self.__lastScale * scale;
              level = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);
              if (oldLevel !== level) {
                var currentTouchLeftRel = currentTouchLeft - self.__clientLeft;
                var currentTouchTopRel = currentTouchTop - self.__clientTop;
                scrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;
                scrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;
                self.__computeScrollMax(level);
              }
            }
            if (self.__enableScrollX) {
              scrollLeft -= moveX * self.options.speedMultiplier;
              var maxScrollLeft = self.__maxScrollLeft;
              if (scrollLeft > maxScrollLeft || scrollLeft < 0) {
                if (self.options.bouncing) {
                  scrollLeft += (moveX / 2 * self.options.speedMultiplier);
                } else if (scrollLeft > maxScrollLeft) {
                  scrollLeft = maxScrollLeft;
                } else {
                  scrollLeft = 0;
                }
              }
            }
            if (self.__enableScrollY) {
              scrollTop -= moveY * self.options.speedMultiplier;
              var maxScrollTop = self.__maxScrollTop;
              if (scrollTop > maxScrollTop || scrollTop < 0) {
                if (self.options.bouncing || (self.__refreshHeight && scrollTop < 0)) {
                  scrollTop += (moveY / 2 * self.options.speedMultiplier);
                  if (!self.__enableScrollX && self.__refreshHeight != null) {
                    if (scrollTop < 0) {
                      self.__refreshHidden = false;
                      self.__refreshShow();
                    } else {
                      self.__refreshHide();
                      self.__refreshHidden = true;
                    }
                    if (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {
                      self.__refreshActive = true;
                      if (self.__refreshActivate) {
                        self.__refreshActivate();
                      }
                    } else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {
                      self.__refreshActive = false;
                      if (self.__refreshDeactivate) {
                        self.__refreshDeactivate();
                      }
                    }
                  }
                } else if (scrollTop > maxScrollTop) {
                  scrollTop = maxScrollTop;
                } else {
                  scrollTop = 0;
                }
              } else if (self.__refreshHeight && !self.__refreshHidden) {
                self.__refreshHide();
                self.__refreshHidden = true;
              }
            }
            if (positions.length > 60) {
              positions.splice(0, 30);
            }
            positions.push(scrollLeft, scrollTop, timeStamp);
            self.__publish(scrollLeft, scrollTop, level);
          } else {
            var minimumTrackingForScroll = self.options.locking ? 3 : 0;
            var minimumTrackingForDrag = 5;
            var distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);
            var distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);
            self.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;
            self.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;
            positions.push(self.__scrollLeft, self.__scrollTop, timeStamp);
            self.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);
            if (self.__isDragging) {
              self.__interruptedAnimation = false;
              self.__fadeScrollbars('in');
            }
          }
          self.__lastTouchLeft = currentTouchLeft;
          self.__lastTouchTop = currentTouchTop;
          self.__lastTouchMove = timeStamp;
          self.__lastScale = scale;
        },
        doTouchEnd: function(e, timeStamp) {
          if (timeStamp instanceof Date) {
            timeStamp = timeStamp.valueOf();
          }
          if (typeof timeStamp !== "number") {
            timeStamp = Date.now();
          }
          var self = this;
          if (!self.__isTracking) {
            return;
          }
          self.__isTracking = false;
          if (self.__isDragging) {
            self.__isDragging = false;
            if (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {
              var positions = self.__positions;
              var endPos = positions.length - 1;
              var startPos = endPos;
              for (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {
                startPos = i;
              }
              if (startPos !== endPos) {
                var timeOffset = positions[endPos] - positions[startPos];
                var movedLeft = self.__scrollLeft - positions[startPos - 2];
                var movedTop = self.__scrollTop - positions[startPos - 1];
                self.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);
                self.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);
                var minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? self.options.decelVelocityThresholdPaging : self.options.decelVelocityThreshold;
                if (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {
                  if (!self.__refreshActive) {
                    self.__startDeceleration(timeStamp);
                  }
                }
              } else {
                self.__scrollingComplete();
              }
            } else if ((timeStamp - self.__lastTouchMove) > 100) {
              self.__scrollingComplete();
            }
          } else if (self.__decStopped) {
            e.isTapHandled = true;
            self.__decStopped = false;
          }
          if (!self.__isDecelerating) {
            if (self.__refreshActive && self.__refreshStart) {
              self.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);
              var d = new Date();
              self.refreshStartTime = d.getTime();
              if (self.__refreshStart) {
                self.__refreshStart();
              }
              if (!ionic.Platform.isAndroid())
                self.__startDeceleration();
            } else {
              if (self.__interruptedAnimation || self.__isDragging) {
                self.__scrollingComplete();
              }
              self.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);
              if (self.__refreshActive) {
                self.__refreshActive = false;
                if (self.__refreshDeactivate) {
                  self.__refreshDeactivate();
                }
              }
            }
          }
          self.__positions.length = 0;
        },
        __publish: function(left, top, zoom, animate, wasResize) {
          var self = this;
          var wasAnimating = self.__isAnimating;
          if (wasAnimating) {
            zyngaCore.effect.Animate.stop(wasAnimating);
            self.__isAnimating = false;
          }
          if (animate && self.options.animating) {
            self.__scheduledLeft = left;
            self.__scheduledTop = top;
            self.__scheduledZoom = zoom;
            var oldLeft = self.__scrollLeft;
            var oldTop = self.__scrollTop;
            var oldZoom = self.__zoomLevel;
            var diffLeft = left - oldLeft;
            var diffTop = top - oldTop;
            var diffZoom = zoom - oldZoom;
            var step = function(percent, now, render) {
              if (render) {
                self.__scrollLeft = oldLeft + (diffLeft * percent);
                self.__scrollTop = oldTop + (diffTop * percent);
                self.__zoomLevel = oldZoom + (diffZoom * percent);
                if (self.__callback) {
                  self.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel, wasResize);
                }
              }
            };
            var verify = function(id) {
              return self.__isAnimating === id;
            };
            var completed = function(renderedFramesPerSecond, animationId, wasFinished) {
              if (animationId === self.__isAnimating) {
                self.__isAnimating = false;
              }
              if (self.__didDecelerationComplete || wasFinished) {
                self.__scrollingComplete();
              }
              if (self.options.zooming) {
                self.__computeScrollMax();
              }
            };
            self.__isAnimating = zyngaCore.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);
          } else {
            self.__scheduledLeft = self.__scrollLeft = left;
            self.__scheduledTop = self.__scrollTop = top;
            self.__scheduledZoom = self.__zoomLevel = zoom;
            if (self.__callback) {
              self.__callback(left, top, zoom, wasResize);
            }
            if (self.options.zooming) {
              self.__computeScrollMax();
            }
          }
        },
        __computeScrollMax: function(zoomLevel) {
          var self = this;
          if (zoomLevel == null) {
            zoomLevel = self.__zoomLevel;
          }
          self.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);
          self.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);
          if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
            self.__didWaitForSize = true;
            self.__waitForSize();
          }
        },
        __waitForSize: function() {
          var self = this;
          clearTimeout(self.__sizerTimeout);
          var sizer = function() {
            self.resize(true);
          };
          sizer();
          self.__sizerTimeout = setTimeout(sizer, 500);
        },
        __startDeceleration: function() {
          var self = this;
          if (self.options.paging) {
            var scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);
            var scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);
            var clientWidth = self.__clientWidth;
            var clientHeight = self.__clientHeight;
            self.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;
            self.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;
            self.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;
            self.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;
          } else {
            self.__minDecelerationScrollLeft = 0;
            self.__minDecelerationScrollTop = 0;
            self.__maxDecelerationScrollLeft = self.__maxScrollLeft;
            self.__maxDecelerationScrollTop = self.__maxScrollTop;
            if (self.__refreshActive)
              self.__minDecelerationScrollTop = self.__refreshHeight * -1;
          }
          var step = function(percent, now, render) {
            self.__stepThroughDeceleration(render);
          };
          self.__minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.1;
          var verify = function() {
            var shouldContinue = Math.abs(self.__decelerationVelocityX) >= self.__minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= self.__minVelocityToKeepDecelerating;
            if (!shouldContinue) {
              self.__didDecelerationComplete = true;
              if (self.options.bouncing && !self.__refreshActive) {
                self.scrollTo(Math.min(Math.max(self.__scrollLeft, 0), self.__maxScrollLeft), Math.min(Math.max(self.__scrollTop, 0), self.__maxScrollTop), self.__refreshActive);
              }
            }
            return shouldContinue;
          };
          var completed = function() {
            self.__isDecelerating = false;
            if (self.__didDecelerationComplete) {
              self.__scrollingComplete();
            }
            if (self.options.paging) {
              self.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);
            }
          };
          self.__isDecelerating = zyngaCore.effect.Animate.start(step, verify, completed);
        },
        __stepThroughDeceleration: function(render) {
          var self = this;
          var scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;
          var scrollTop = self.__scrollTop + self.__decelerationVelocityY;
          if (!self.options.bouncing) {
            var scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);
            if (scrollLeftFixed !== scrollLeft) {
              scrollLeft = scrollLeftFixed;
              self.__decelerationVelocityX = 0;
            }
            var scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);
            if (scrollTopFixed !== scrollTop) {
              scrollTop = scrollTopFixed;
              self.__decelerationVelocityY = 0;
            }
          }
          if (render) {
            self.__publish(scrollLeft, scrollTop, self.__zoomLevel);
          } else {
            self.__scrollLeft = scrollLeft;
            self.__scrollTop = scrollTop;
          }
          if (!self.options.paging) {
            var frictionFactor = self.options.deceleration;
            self.__decelerationVelocityX *= frictionFactor;
            self.__decelerationVelocityY *= frictionFactor;
          }
          if (self.options.bouncing) {
            var scrollOutsideX = 0;
            var scrollOutsideY = 0;
            var penetrationDeceleration = self.options.penetrationDeceleration;
            var penetrationAcceleration = self.options.penetrationAcceleration;
            if (scrollLeft < self.__minDecelerationScrollLeft) {
              scrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;
            } else if (scrollLeft > self.__maxDecelerationScrollLeft) {
              scrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;
            }
            if (scrollTop < self.__minDecelerationScrollTop) {
              scrollOutsideY = self.__minDecelerationScrollTop - scrollTop;
            } else if (scrollTop > self.__maxDecelerationScrollTop) {
              scrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;
            }
            if (scrollOutsideX !== 0) {
              var isHeadingOutwardsX = scrollOutsideX * self.__decelerationVelocityX <= self.__minDecelerationScrollLeft;
              if (isHeadingOutwardsX) {
                self.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;
              }
              var isStoppedX = Math.abs(self.__decelerationVelocityX) <= self.__minVelocityToKeepDecelerating;
              if (!isHeadingOutwardsX || isStoppedX) {
                self.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;
              }
            }
            if (scrollOutsideY !== 0) {
              var isHeadingOutwardsY = scrollOutsideY * self.__decelerationVelocityY <= self.__minDecelerationScrollTop;
              if (isHeadingOutwardsY) {
                self.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;
              }
              var isStoppedY = Math.abs(self.__decelerationVelocityY) <= self.__minVelocityToKeepDecelerating;
              if (!isHeadingOutwardsY || isStoppedY) {
                self.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;
              }
            }
          }
        },
        __getDistance: function getDistance(touch1, touch2) {
          var x = touch2.pageX - touch1.pageX,
              y = touch2.pageY - touch1.pageY;
          return Math.sqrt((x * x) + (y * y));
        },
        __getScale: function getScale(start, end) {
          if (start.length >= 2 && end.length >= 2) {
            return this.__getDistance(end[0], end[1]) / this.__getDistance(start[0], start[1]);
          }
          return 1;
        }
      });
      ionic.scroll = {
        isScrolling: false,
        lastTop: 0
      };
    })(ionic);
    (function(ionic) {
      var NOOP = function() {};
      var deprecated = function(name) {
        void 0;
      };
      ionic.views.ScrollNative = ionic.views.View.inherit({
        initialize: function(options) {
          var self = this;
          self.__container = self.el = options.el;
          self.__content = options.el.firstElementChild;
          self.__frozen = false;
          self.isNative = true;
          self.__scrollTop = self.el.scrollTop;
          self.__scrollLeft = self.el.scrollLeft;
          self.__clientHeight = self.__content.clientHeight;
          self.__clientWidth = self.__content.clientWidth;
          self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
          self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
          if (options.startY >= 0 || options.startX >= 0) {
            ionic.requestAnimationFrame(function() {
              self.el.scrollTop = options.startY || 0;
              self.el.scrollLeft = options.startX || 0;
              self.__scrollTop = self.el.scrollTop;
              self.__scrollLeft = self.el.scrollLeft;
            });
          }
          self.options = {
            freeze: false,
            getContentWidth: function() {
              return Math.max(self.__content.scrollWidth, self.__content.offsetWidth);
            },
            getContentHeight: function() {
              return Math.max(self.__content.scrollHeight, self.__content.offsetHeight + (self.__content.offsetTop * 2));
            }
          };
          for (var key in options) {
            self.options[key] = options[key];
          }
          self.onScroll = function() {
            if (!ionic.scroll.isScrolling) {
              ionic.scroll.isScrolling = true;
            }
            clearTimeout(self.scrollTimer);
            self.scrollTimer = setTimeout(function() {
              ionic.scroll.isScrolling = false;
            }, 80);
          };
          self.freeze = function(shouldFreeze) {
            self.__frozen = shouldFreeze;
          };
          self.freezeShut = function(shouldFreezeShut) {
            self.__frozenShut = shouldFreezeShut;
          };
          self.__initEventHandlers();
        },
        __callback: function() {
          deprecated('__callback');
        },
        zoomTo: function() {
          deprecated('zoomTo');
        },
        zoomBy: function() {
          deprecated('zoomBy');
        },
        activatePullToRefresh: function() {
          deprecated('activatePullToRefresh');
        },
        resize: function(continueScrolling) {
          var self = this;
          if (!self.__container || !self.options)
            return;
          self.setDimensions(self.__container.clientWidth, self.__container.clientHeight, self.options.getContentWidth(), self.options.getContentHeight(), continueScrolling);
        },
        run: function() {
          this.resize();
        },
        getValues: function() {
          var self = this;
          self.update();
          return {
            left: self.__scrollLeft,
            top: self.__scrollTop,
            zoom: 1
          };
        },
        update: function() {
          var self = this;
          self.__scrollLeft = self.el.scrollLeft;
          self.__scrollTop = self.el.scrollTop;
        },
        setDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {
          var self = this;
          if (!clientWidth && !clientHeight && !contentWidth && !contentHeight) {
            return;
          }
          if (clientWidth === +clientWidth) {
            self.__clientWidth = clientWidth;
          }
          if (clientHeight === +clientHeight) {
            self.__clientHeight = clientHeight;
          }
          if (contentWidth === +contentWidth) {
            self.__contentWidth = contentWidth;
          }
          if (contentHeight === +contentHeight) {
            self.__contentHeight = contentHeight;
          }
          self.__computeScrollMax();
        },
        getScrollMax: function() {
          return {
            left: this.__maxScrollLeft,
            top: this.__maxScrollTop
          };
        },
        scrollBy: function(left, top, animate) {
          var self = this;
          self.update();
          var startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;
          var startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;
          self.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);
        },
        scrollTo: function(left, top, animate) {
          var self = this;
          if (!animate) {
            self.el.scrollTop = top;
            self.el.scrollLeft = left;
            self.resize();
            return;
          }
          var oldOverflowX = self.el.style.overflowX;
          var oldOverflowY = self.el.style.overflowY;
          clearTimeout(self.__scrollToCleanupTimeout);
          self.__scrollToCleanupTimeout = setTimeout(function() {
            self.el.style.overflowX = oldOverflowX;
            self.el.style.overflowY = oldOverflowY;
          }, 500);
          self.el.style.overflowY = 'hidden';
          self.el.style.overflowX = 'hidden';
          animateScroll(top, left);
          function animateScroll(Y, X) {
            var start = Date.now(),
                duration = 250,
                fromY = self.el.scrollTop,
                fromX = self.el.scrollLeft;
            if (fromY === Y && fromX === X) {
              self.el.style.overflowX = oldOverflowX;
              self.el.style.overflowY = oldOverflowY;
              self.resize();
              return;
            }
            function easeOutCubic(t) {
              return (--t) * t * t + 1;
            }
            function animateScrollStep() {
              var currentTime = Date.now(),
                  time = Math.min(1, ((currentTime - start) / duration)),
                  easedT = easeOutCubic(time);
              if (fromY != Y) {
                self.el.scrollTop = parseInt((easedT * (Y - fromY)) + fromY, 10);
              }
              if (fromX != X) {
                self.el.scrollLeft = parseInt((easedT * (X - fromX)) + fromX, 10);
              }
              if (time < 1) {
                ionic.requestAnimationFrame(animateScrollStep);
              } else {
                ionic.tap.removeClonedInputs(self.__container, self);
                self.el.style.overflowX = oldOverflowX;
                self.el.style.overflowY = oldOverflowY;
                self.resize();
              }
            }
            ionic.requestAnimationFrame(animateScrollStep);
          }
        },
        __waitForSize: function() {
          var self = this;
          clearTimeout(self.__sizerTimeout);
          var sizer = function() {
            self.resize(true);
          };
          sizer();
          self.__sizerTimeout = setTimeout(sizer, 500);
        },
        __computeScrollMax: function() {
          var self = this;
          self.__maxScrollLeft = Math.max((self.__contentWidth) - self.__clientWidth, 0);
          self.__maxScrollTop = Math.max((self.__contentHeight) - self.__clientHeight, 0);
          if (!self.__didWaitForSize && !self.__maxScrollLeft && !self.__maxScrollTop) {
            self.__didWaitForSize = true;
            self.__waitForSize();
          }
        },
        __initEventHandlers: function() {
          var self = this;
          var container = self.__container;
          var scrollViewOffsetHeight;
          var lastKeyboardHeight;
          self.scrollChildIntoView = function(e) {
            var rect = container.getBoundingClientRect();
            if (!self.__originalContainerHeight) {
              self.__originalContainerHeight = rect.height;
            }
            scrollViewOffsetHeight = self.__originalContainerHeight;
            var alreadyShrunk = self.isShrunkForKeyboard;
            var isModal = container.parentNode.classList.contains('modal');
            var isPopover = container.parentNode.classList.contains('popover');
            var isInsetModal = isModal && window.innerWidth >= 680;
            var changedKeyboardHeight = lastKeyboardHeight && (lastKeyboardHeight !== e.detail.keyboardHeight);
            if (!alreadyShrunk || changedKeyboardHeight) {
              if (!isPopover && (ionic.Platform.isIOS() || ionic.Platform.isFullScreen || isInsetModal)) {
                ionic.requestAnimationFrame(function() {
                  scrollViewOffsetHeight = Math.max(0, Math.min(self.__originalContainerHeight, self.__originalContainerHeight - (e.detail.keyboardHeight - 43)));
                  container.style.height = scrollViewOffsetHeight + "px";
                  container.classList.add('keyboard-up');
                  self.resize();
                });
              }
              self.isShrunkForKeyboard = true;
            }
            lastKeyboardHeight = e.detail.keyboardHeight;
            if (e.detail.isElementUnderKeyboard) {
              ionic.requestAnimationFrame(function() {
                var pos = ionic.DomUtil.getOffsetTop(e.detail.target);
                setTimeout(function() {
                  if (ionic.Platform.isIOS()) {
                    ionic.tap.cloneFocusedInput(container, self);
                  }
                  self.scrollTo(0, pos - (rect.top + 100), true);
                  self.onScroll();
                }, 32);
              });
            }
            e.stopPropagation();
          };
          self.resetScrollView = function() {
            if (self.isShrunkForKeyboard) {
              self.isShrunkForKeyboard = false;
              container.style.height = "";
              self.__originalContainerHeight = container.getBoundingClientRect().height;
              if (ionic.Platform.isIOS()) {
                ionic.requestAnimationFrame(function() {
                  container.classList.remove('keyboard-up');
                });
              }
            }
            self.resize();
          };
          self.handleTouchMove = function(e) {
            if (self.__frozenShut) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
          };
          container.addEventListener('scroll', self.onScroll);
          container.addEventListener('scrollChildIntoView', self.scrollChildIntoView);
          container.addEventListener(ionic.EVENTS.touchstart, self.handleTouchMove);
          container.addEventListener(ionic.EVENTS.touchmove, self.handleTouchMove);
          document.addEventListener('resetScrollView', self.resetScrollView);
        },
        __cleanup: function() {
          var self = this;
          var container = self.__container;
          container.removeEventListener('resetScrollView', self.resetScrollView);
          container.removeEventListener('scroll', self.onScroll);
          container.removeEventListener('scrollChildIntoView', self.scrollChildIntoView);
          container.removeEventListener('resetScrollView', self.resetScrollView);
          container.removeEventListener(ionic.EVENTS.touchstart, self.handleTouchMove);
          container.removeEventListener(ionic.EVENTS.touchmove, self.handleTouchMove);
          ionic.tap.removeClonedInputs(container, self);
          delete self.__container;
          delete self.__content;
          delete self.__indicatorX;
          delete self.__indicatorY;
          delete self.options.el;
          self.resize = self.scrollTo = self.onScroll = self.resetScrollView = NOOP;
          self.scrollChildIntoView = NOOP;
          container = null;
        }
      });
    })(ionic);
    (function(ionic) {
      'use strict';
      var ITEM_CLASS = 'item';
      var ITEM_CONTENT_CLASS = 'item-content';
      var ITEM_SLIDING_CLASS = 'item-sliding';
      var ITEM_OPTIONS_CLASS = 'item-options';
      var ITEM_PLACEHOLDER_CLASS = 'item-placeholder';
      var ITEM_REORDERING_CLASS = 'item-reordering';
      var ITEM_REORDER_BTN_CLASS = 'item-reorder';
      var DragOp = function() {};
      DragOp.prototype = {
        start: function() {},
        drag: function() {},
        end: function() {},
        isSameItem: function() {
          return false;
        }
      };
      var SlideDrag = function(opts) {
        this.dragThresholdX = opts.dragThresholdX || 10;
        this.el = opts.el;
        this.item = opts.item;
        this.canSwipe = opts.canSwipe;
      };
      SlideDrag.prototype = new DragOp();
      SlideDrag.prototype.start = function(e) {
        var content,
            buttons,
            offsetX,
            buttonsWidth;
        if (!this.canSwipe()) {
          return;
        }
        if (e.target.classList.contains(ITEM_CONTENT_CLASS)) {
          content = e.target;
        } else if (e.target.classList.contains(ITEM_CLASS)) {
          content = e.target.querySelector('.' + ITEM_CONTENT_CLASS);
        } else {
          content = ionic.DomUtil.getParentWithClass(e.target, ITEM_CONTENT_CLASS);
        }
        if (!content) {
          return;
        }
        content.classList.remove(ITEM_SLIDING_CLASS);
        offsetX = parseFloat(content.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]) || 0;
        buttons = content.parentNode.querySelector('.' + ITEM_OPTIONS_CLASS);
        if (!buttons) {
          return;
        }
        buttons.classList.remove('invisible');
        buttonsWidth = buttons.offsetWidth;
        this._currentDrag = {
          buttons: buttons,
          buttonsWidth: buttonsWidth,
          content: content,
          startOffsetX: offsetX
        };
      };
      SlideDrag.prototype.isSameItem = function(op) {
        if (op._lastDrag && this._currentDrag) {
          return this._currentDrag.content == op._lastDrag.content;
        }
        return false;
      };
      SlideDrag.prototype.clean = function(isInstant) {
        var lastDrag = this._lastDrag;
        if (!lastDrag || !lastDrag.content)
          return;
        lastDrag.content.style[ionic.CSS.TRANSITION] = '';
        lastDrag.content.style[ionic.CSS.TRANSFORM] = '';
        if (isInstant) {
          lastDrag.content.style[ionic.CSS.TRANSITION] = 'none';
          makeInvisible();
          ionic.requestAnimationFrame(function() {
            lastDrag.content.style[ionic.CSS.TRANSITION] = '';
          });
        } else {
          ionic.requestAnimationFrame(function() {
            setTimeout(makeInvisible, 250);
          });
        }
        function makeInvisible() {
          lastDrag.buttons && lastDrag.buttons.classList.add('invisible');
        }
      };
      SlideDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
        var buttonsWidth;
        if (!this._currentDrag) {
          return;
        }
        if (!this._isDragging && ((Math.abs(e.gesture.deltaX) > this.dragThresholdX) || (Math.abs(this._currentDrag.startOffsetX) > 0))) {
          this._isDragging = true;
        }
        if (this._isDragging) {
          buttonsWidth = this._currentDrag.buttonsWidth;
          var newX = Math.min(0, this._currentDrag.startOffsetX + e.gesture.deltaX);
          if (newX < -buttonsWidth) {
            newX = Math.min(-buttonsWidth, -buttonsWidth + (((e.gesture.deltaX + buttonsWidth) * 0.4)));
          }
          this._currentDrag.content.$$ionicOptionsOpen = newX !== 0;
          this._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + newX + 'px, 0, 0)';
          this._currentDrag.content.style[ionic.CSS.TRANSITION] = 'none';
        }
      });
      SlideDrag.prototype.end = function(e, doneCallback) {
        var self = this;
        if (!self._currentDrag) {
          doneCallback && doneCallback();
          return;
        }
        var restingPoint = -self._currentDrag.buttonsWidth;
        if (e.gesture.deltaX > -(self._currentDrag.buttonsWidth / 2)) {
          if (e.gesture.direction == "left" && Math.abs(e.gesture.velocityX) < 0.3) {
            restingPoint = 0;
          } else if (e.gesture.direction == "right") {
            restingPoint = 0;
          }
        }
        ionic.requestAnimationFrame(function() {
          if (restingPoint === 0) {
            self._currentDrag.content.style[ionic.CSS.TRANSFORM] = '';
            var buttons = self._currentDrag.buttons;
            setTimeout(function() {
              buttons && buttons.classList.add('invisible');
            }, 250);
          } else {
            self._currentDrag.content.style[ionic.CSS.TRANSFORM] = 'translate3d(' + restingPoint + 'px,0,0)';
          }
          self._currentDrag.content.style[ionic.CSS.TRANSITION] = '';
          if (!self._lastDrag) {
            self._lastDrag = {};
          }
          ionic.extend(self._lastDrag, self._currentDrag);
          if (self._currentDrag) {
            self._currentDrag.buttons = null;
            self._currentDrag.content = null;
          }
          self._currentDrag = null;
          doneCallback && doneCallback();
        });
      };
      var ReorderDrag = function(opts) {
        var self = this;
        self.dragThresholdY = opts.dragThresholdY || 0;
        self.onReorder = opts.onReorder;
        self.listEl = opts.listEl;
        self.el = self.item = opts.el;
        self.scrollEl = opts.scrollEl;
        self.scrollView = opts.scrollView;
        self.listElTrueTop = 0;
        if (self.listEl.offsetParent) {
          var obj = self.listEl;
          do {
            self.listElTrueTop += obj.offsetTop;
            obj = obj.offsetParent;
          } while (obj);
        }
      };
      ReorderDrag.prototype = new DragOp();
      ReorderDrag.prototype._moveElement = function(e) {
        var y = e.gesture.center.pageY + this.scrollView.getValues().top - (this._currentDrag.elementHeight / 2) - this.listElTrueTop;
        this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(0, ' + y + 'px, 0)';
      };
      ReorderDrag.prototype.deregister = function() {
        this.listEl = this.el = this.scrollEl = this.scrollView = null;
      };
      ReorderDrag.prototype.start = function(e) {
        var startIndex = ionic.DomUtil.getChildIndex(this.el, this.el.nodeName.toLowerCase());
        var elementHeight = this.el.scrollHeight;
        var placeholder = this.el.cloneNode(true);
        placeholder.classList.add(ITEM_PLACEHOLDER_CLASS);
        this.el.parentNode.insertBefore(placeholder, this.el);
        this.el.classList.add(ITEM_REORDERING_CLASS);
        this._currentDrag = {
          elementHeight: elementHeight,
          startIndex: startIndex,
          placeholder: placeholder,
          scrollHeight: scroll,
          list: placeholder.parentNode
        };
        this._moveElement(e);
      };
      ReorderDrag.prototype.drag = ionic.animationFrameThrottle(function(e) {
        var self = this;
        if (!this._currentDrag) {
          return;
        }
        var scrollY = 0;
        var pageY = e.gesture.center.pageY;
        var offset = this.listElTrueTop;
        if (this.scrollView) {
          var container = this.scrollView.__container;
          scrollY = this.scrollView.getValues().top;
          var containerTop = container.offsetTop;
          var pixelsPastTop = containerTop - pageY + this._currentDrag.elementHeight / 2;
          var pixelsPastBottom = pageY + this._currentDrag.elementHeight / 2 - containerTop - container.offsetHeight;
          if (e.gesture.deltaY < 0 && pixelsPastTop > 0 && scrollY > 0) {
            this.scrollView.scrollBy(null, -pixelsPastTop);
            ionic.requestAnimationFrame(function() {
              self.drag(e);
            });
          }
          if (e.gesture.deltaY > 0 && pixelsPastBottom > 0) {
            if (scrollY < this.scrollView.getScrollMax().top) {
              this.scrollView.scrollBy(null, pixelsPastBottom);
              ionic.requestAnimationFrame(function() {
                self.drag(e);
              });
            }
          }
        }
        if (!this._isDragging && Math.abs(e.gesture.deltaY) > this.dragThresholdY) {
          this._isDragging = true;
        }
        if (this._isDragging) {
          this._moveElement(e);
          this._currentDrag.currentY = scrollY + pageY - offset;
        }
      });
      ReorderDrag.prototype._getReorderIndex = function() {
        var self = this;
        var siblings = Array.prototype.slice.call(self._currentDrag.placeholder.parentNode.children).filter(function(el) {
          return el.nodeName === self.el.nodeName && el !== self.el;
        });
        var dragOffsetTop = self._currentDrag.currentY;
        var el;
        for (var i = 0,
            len = siblings.length; i < len; i++) {
          el = siblings[i];
          if (i === len - 1) {
            if (dragOffsetTop > el.offsetTop) {
              return i;
            }
          } else if (i === 0) {
            if (dragOffsetTop < el.offsetTop + el.offsetHeight) {
              return i;
            }
          } else if (dragOffsetTop > el.offsetTop - el.offsetHeight / 2 && dragOffsetTop < el.offsetTop + el.offsetHeight) {
            return i;
          }
        }
        return self._currentDrag.startIndex;
      };
      ReorderDrag.prototype.end = function(e, doneCallback) {
        if (!this._currentDrag) {
          doneCallback && doneCallback();
          return;
        }
        var placeholder = this._currentDrag.placeholder;
        var finalIndex = this._getReorderIndex();
        this.el.classList.remove(ITEM_REORDERING_CLASS);
        this.el.style[ionic.CSS.TRANSFORM] = '';
        placeholder.parentNode.insertBefore(this.el, placeholder);
        placeholder.parentNode.removeChild(placeholder);
        this.onReorder && this.onReorder(this.el, this._currentDrag.startIndex, finalIndex);
        this._currentDrag = {
          placeholder: null,
          content: null
        };
        this._currentDrag = null;
        doneCallback && doneCallback();
      };
      ionic.views.ListView = ionic.views.View.inherit({
        initialize: function(opts) {
          var self = this;
          opts = ionic.extend({
            onReorder: function() {},
            virtualRemoveThreshold: -200,
            virtualAddThreshold: 200,
            canSwipe: function() {
              return true;
            }
          }, opts);
          ionic.extend(self, opts);
          if (!self.itemHeight && self.listEl) {
            self.itemHeight = self.listEl.children[0] && parseInt(self.listEl.children[0].style.height, 10);
          }
          self.onRefresh = opts.onRefresh || function() {};
          self.onRefreshOpening = opts.onRefreshOpening || function() {};
          self.onRefreshHolding = opts.onRefreshHolding || function() {};
          var gestureOpts = {};
          if (ionic.DomUtil.getParentOrSelfWithClass(self.el, 'overflow-scroll')) {
            gestureOpts.prevent_default_directions = ['left', 'right'];
          }
          window.ionic.onGesture('release', function(e) {
            self._handleEndDrag(e);
          }, self.el, gestureOpts);
          window.ionic.onGesture('drag', function(e) {
            self._handleDrag(e);
          }, self.el, gestureOpts);
          self._initDrag();
        },
        deregister: function() {
          this.el = this.listEl = this.scrollEl = this.scrollView = null;
          if (this.isScrollFreeze) {
            self.scrollView.freeze(false);
          }
        },
        stopRefreshing: function() {
          var refresher = this.el.querySelector('.list-refresher');
          refresher.style.height = '0';
        },
        didScroll: function(e) {
          var self = this;
          if (self.isVirtual) {
            var itemHeight = self.itemHeight;
            var scrollHeight = e.target.scrollHeight;
            var viewportHeight = self.el.parentNode.offsetHeight;
            var highWater = Math.max(0, e.scrollTop + self.virtualRemoveThreshold);
            var lowWater = Math.min(scrollHeight, Math.abs(e.scrollTop) + viewportHeight + self.virtualAddThreshold);
            var first = parseInt(Math.abs(highWater / itemHeight), 10);
            var last = parseInt(Math.abs(lowWater / itemHeight), 10);
            self._virtualItemsToRemove = Array.prototype.slice.call(self.listEl.children, 0, first);
            self.renderViewport && self.renderViewport(highWater, lowWater, first, last);
          }
        },
        didStopScrolling: function() {
          if (this.isVirtual) {
            for (var i = 0; i < this._virtualItemsToRemove.length; i++) {
              this.didHideItem && this.didHideItem(i);
            }
          }
        },
        clearDragEffects: function(isInstant) {
          if (this._lastDragOp) {
            this._lastDragOp.clean && this._lastDragOp.clean(isInstant);
            this._lastDragOp.deregister && this._lastDragOp.deregister();
            this._lastDragOp = null;
          }
        },
        _initDrag: function() {
          if (this._lastDragOp) {
            this._lastDragOp.deregister && this._lastDragOp.deregister();
          }
          this._lastDragOp = this._dragOp;
          this._dragOp = null;
        },
        _getItem: function(target) {
          while (target) {
            if (target.classList && target.classList.contains(ITEM_CLASS)) {
              return target;
            }
            target = target.parentNode;
          }
          return null;
        },
        _startDrag: function(e) {
          var self = this;
          self._isDragging = false;
          var lastDragOp = self._lastDragOp;
          var item;
          if (self._didDragUpOrDown && lastDragOp instanceof SlideDrag) {
            lastDragOp.clean && lastDragOp.clean();
          }
          if (ionic.DomUtil.getParentOrSelfWithClass(e.target, ITEM_REORDER_BTN_CLASS) && (e.gesture.direction == 'up' || e.gesture.direction == 'down')) {
            item = self._getItem(e.target);
            if (item) {
              self._dragOp = new ReorderDrag({
                listEl: self.el,
                el: item,
                scrollEl: self.scrollEl,
                scrollView: self.scrollView,
                onReorder: function(el, start, end) {
                  self.onReorder && self.onReorder(el, start, end);
                }
              });
              self._dragOp.start(e);
              e.preventDefault();
            }
          } else if (!self._didDragUpOrDown && (e.gesture.direction == 'left' || e.gesture.direction == 'right') && Math.abs(e.gesture.deltaX) > 5) {
            item = self._getItem(e.target);
            if (item && item.querySelector('.item-options')) {
              self._dragOp = new SlideDrag({
                el: self.el,
                item: item,
                canSwipe: self.canSwipe
              });
              self._dragOp.start(e);
              e.preventDefault();
              self.isScrollFreeze = self.scrollView.freeze(true);
            }
          }
          if (lastDragOp && self._dragOp && !self._dragOp.isSameItem(lastDragOp) && e.defaultPrevented) {
            lastDragOp.clean && lastDragOp.clean();
          }
        },
        _handleEndDrag: function(e) {
          var self = this;
          if (self.scrollView) {
            self.isScrollFreeze = self.scrollView.freeze(false);
          }
          self._didDragUpOrDown = false;
          if (!self._dragOp) {
            return;
          }
          self._dragOp.end(e, function() {
            self._initDrag();
          });
        },
        _handleDrag: function(e) {
          var self = this;
          if (Math.abs(e.gesture.deltaY) > 5) {
            self._didDragUpOrDown = true;
          }
          if (!self.isDragging && !self._dragOp) {
            self._startDrag(e);
          }
          if (!self._dragOp) {
            return;
          }
          e.gesture.srcEvent.preventDefault();
          self._dragOp.drag(e);
        }
      });
    })(ionic);
    (function(ionic) {
      'use strict';
      ionic.views.Modal = ionic.views.View.inherit({
        initialize: function(opts) {
          opts = ionic.extend({
            focusFirstInput: false,
            unfocusOnHide: true,
            focusFirstDelay: 600,
            backdropClickToClose: true,
            hardwareBackButtonClose: true
          }, opts);
          ionic.extend(this, opts);
          this.el = opts.el;
        },
        show: function() {
          var self = this;
          if (self.focusFirstInput) {
            window.setTimeout(function() {
              var input = self.el.querySelector('input, textarea');
              input && input.focus && input.focus();
            }, self.focusFirstDelay);
          }
        },
        hide: function() {
          if (this.unfocusOnHide) {
            var inputs = this.el.querySelectorAll('input, textarea');
            window.setTimeout(function() {
              for (var i = 0; i < inputs.length; i++) {
                inputs[i].blur && inputs[i].blur();
              }
            });
          }
        }
      });
    })(ionic);
    (function(ionic) {
      'use strict';
      ionic.views.SideMenu = ionic.views.View.inherit({
        initialize: function(opts) {
          this.el = opts.el;
          this.isEnabled = (typeof opts.isEnabled === 'undefined') ? true : opts.isEnabled;
          this.setWidth(opts.width);
        },
        getFullWidth: function() {
          return this.width;
        },
        setWidth: function(width) {
          this.width = width;
          this.el.style.width = width + 'px';
        },
        setIsEnabled: function(isEnabled) {
          this.isEnabled = isEnabled;
        },
        bringUp: function() {
          if (this.el.style.zIndex !== '0') {
            this.el.style.zIndex = '0';
          }
        },
        pushDown: function() {
          if (this.el.style.zIndex !== '-1') {
            this.el.style.zIndex = '-1';
          }
        }
      });
      ionic.views.SideMenuContent = ionic.views.View.inherit({
        initialize: function(opts) {
          ionic.extend(this, {
            animationClass: 'menu-animated',
            onDrag: function() {},
            onEndDrag: function() {}
          }, opts);
          ionic.onGesture('drag', ionic.proxy(this._onDrag, this), this.el);
          ionic.onGesture('release', ionic.proxy(this._onEndDrag, this), this.el);
        },
        _onDrag: function(e) {
          this.onDrag && this.onDrag(e);
        },
        _onEndDrag: function(e) {
          this.onEndDrag && this.onEndDrag(e);
        },
        disableAnimation: function() {
          this.el.classList.remove(this.animationClass);
        },
        enableAnimation: function() {
          this.el.classList.add(this.animationClass);
        },
        getTranslateX: function() {
          return parseFloat(this.el.style[ionic.CSS.TRANSFORM].replace('translate3d(', '').split(',')[0]);
        },
        setTranslateX: ionic.animationFrameThrottle(function(x) {
          this.el.style[ionic.CSS.TRANSFORM] = 'translate3d(' + x + 'px, 0, 0)';
        })
      });
    })(ionic);
    (function(ionic) {
      'use strict';
      ionic.views.Slider = ionic.views.View.inherit({initialize: function(options) {
          var slider = this;
          var touchStartEvent,
              touchMoveEvent,
              touchEndEvent;
          if (window.navigator.pointerEnabled) {
            touchStartEvent = 'pointerdown';
            touchMoveEvent = 'pointermove';
            touchEndEvent = 'pointerup';
          } else if (window.navigator.msPointerEnabled) {
            touchStartEvent = 'MSPointerDown';
            touchMoveEvent = 'MSPointerMove';
            touchEndEvent = 'MSPointerUp';
          } else {
            touchStartEvent = 'touchstart';
            touchMoveEvent = 'touchmove';
            touchEndEvent = 'touchend';
          }
          var mouseStartEvent = 'mousedown';
          var mouseMoveEvent = 'mousemove';
          var mouseEndEvent = 'mouseup';
          var noop = function() {};
          var offloadFn = function(fn) {
            setTimeout(fn || noop, 0);
          };
          var browser = {
            addEventListener: !!window.addEventListener,
            transitions: (function(temp) {
              var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];
              for (var i in props)
                if (temp.style[props[i]] !== undefined)
                  return true;
              return false;
            })(document.createElement('swipe'))
          };
          var container = options.el;
          if (!container)
            return;
          var element = container.children[0];
          var slides,
              slidePos,
              width,
              length;
          options = options || {};
          var index = parseInt(options.startSlide, 10) || 0;
          var speed = options.speed || 300;
          options.continuous = options.continuous !== undefined ? options.continuous : true;
          function setup() {
            if (!container.offsetWidth) {
              return;
            }
            slides = element.children;
            length = slides.length;
            if (slides.length < 2)
              options.continuous = false;
            if (browser.transitions && options.continuous && slides.length < 3) {
              element.appendChild(slides[0].cloneNode(true));
              element.appendChild(element.children[1].cloneNode(true));
              slides = element.children;
            }
            slidePos = new Array(slides.length);
            width = container.offsetWidth || container.getBoundingClientRect().width;
            element.style.width = (slides.length * width) + 'px';
            var pos = slides.length;
            while (pos--) {
              var slide = slides[pos];
              slide.style.width = width + 'px';
              slide.setAttribute('data-index', pos);
              if (browser.transitions) {
                slide.style.left = (pos * -width) + 'px';
                move(pos, index > pos ? -width : (index < pos ? width : 0), 0);
              }
            }
            if (options.continuous && browser.transitions) {
              move(circle(index - 1), -width, 0);
              move(circle(index + 1), width, 0);
            }
            if (!browser.transitions)
              element.style.left = (index * -width) + 'px';
            container.style.visibility = 'visible';
            options.slidesChanged && options.slidesChanged();
          }
          function prev(slideSpeed) {
            if (options.continuous)
              slide(index - 1, slideSpeed);
            else if (index)
              slide(index - 1, slideSpeed);
          }
          function next(slideSpeed) {
            if (options.continuous)
              slide(index + 1, slideSpeed);
            else if (index < slides.length - 1)
              slide(index + 1, slideSpeed);
          }
          function circle(index) {
            return (slides.length + (index % slides.length)) % slides.length;
          }
          function slide(to, slideSpeed) {
            if (index == to)
              return;
            if (!slides) {
              index = to;
              return;
            }
            if (browser.transitions) {
              var direction = Math.abs(index - to) / (index - to);
              if (options.continuous) {
                var naturalDirection = direction;
                direction = -slidePos[circle(to)] / width;
                if (direction !== naturalDirection)
                  to = -direction * slides.length + to;
              }
              var diff = Math.abs(index - to) - 1;
              while (diff--)
                move(circle((to > index ? to : index) - diff - 1), width * direction, 0);
              to = circle(to);
              move(index, width * direction, slideSpeed || speed);
              move(to, 0, slideSpeed || speed);
              if (options.continuous)
                move(circle(to - direction), -(width * direction), 0);
            } else {
              to = circle(to);
              animate(index * -width, to * -width, slideSpeed || speed);
            }
            index = to;
            offloadFn(options.callback && options.callback(index, slides[index]));
          }
          function move(index, dist, speed) {
            translate(index, dist, speed);
            slidePos[index] = dist;
          }
          function translate(index, dist, speed) {
            var slide = slides[index];
            var style = slide && slide.style;
            if (!style)
              return;
            style.webkitTransitionDuration = style.MozTransitionDuration = style.msTransitionDuration = style.OTransitionDuration = style.transitionDuration = speed + 'ms';
            style.webkitTransform = 'translate(' + dist + 'px,0)' + 'translateZ(0)';
            style.msTransform = style.MozTransform = style.OTransform = 'translateX(' + dist + 'px)';
          }
          function animate(from, to, speed) {
            if (!speed) {
              element.style.left = to + 'px';
              return;
            }
            var start = +new Date();
            var timer = setInterval(function() {
              var timeElap = +new Date() - start;
              if (timeElap > speed) {
                element.style.left = to + 'px';
                if (delay)
                  begin();
                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
                clearInterval(timer);
                return;
              }
              element.style.left = (((to - from) * (Math.floor((timeElap / speed) * 100) / 100)) + from) + 'px';
            }, 4);
          }
          var delay = options.auto || 0;
          var interval;
          function begin() {
            interval = setTimeout(next, delay);
          }
          function stop() {
            delay = options.auto || 0;
            clearTimeout(interval);
          }
          var start = {};
          var delta = {};
          var isScrolling;
          var events = {
            handleEvent: function(event) {
              if (!event.touches && event.pageX && event.pageY) {
                event.touches = [{
                  pageX: event.pageX,
                  pageY: event.pageY
                }];
              }
              switch (event.type) {
                case touchStartEvent:
                  this.start(event);
                  break;
                case mouseStartEvent:
                  this.start(event);
                  break;
                case touchMoveEvent:
                  this.touchmove(event);
                  break;
                case mouseMoveEvent:
                  this.touchmove(event);
                  break;
                case touchEndEvent:
                  offloadFn(this.end(event));
                  break;
                case mouseEndEvent:
                  offloadFn(this.end(event));
                  break;
                case 'webkitTransitionEnd':
                case 'msTransitionEnd':
                case 'oTransitionEnd':
                case 'otransitionend':
                case 'transitionend':
                  offloadFn(this.transitionEnd(event));
                  break;
                case 'resize':
                  offloadFn(setup);
                  break;
              }
              if (options.stopPropagation)
                event.stopPropagation();
            },
            start: function(event) {
              if (!event.touches) {
                return;
              }
              var touches = event.touches[0];
              start = {
                x: touches.pageX,
                y: touches.pageY,
                time: +new Date()
              };
              isScrolling = undefined;
              delta = {};
              element.addEventListener(touchMoveEvent, this, false);
              element.addEventListener(mouseMoveEvent, this, false);
              element.addEventListener(touchEndEvent, this, false);
              element.addEventListener(mouseEndEvent, this, false);
              document.addEventListener(touchEndEvent, this, false);
              document.addEventListener(mouseEndEvent, this, false);
            },
            touchmove: function(event) {
              if (!event.touches || event.touches.length > 1 || event.scale && event.scale !== 1 || slider.slideIsDisabled) {
                return;
              }
              if (options.disableScroll)
                event.preventDefault();
              var touches = event.touches[0];
              delta = {
                x: touches.pageX - start.x,
                y: touches.pageY - start.y
              };
              if (typeof isScrolling == 'undefined') {
                isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
              }
              if (!isScrolling) {
                event.preventDefault();
                stop();
                if (options.continuous) {
                  translate(circle(index - 1), delta.x + slidePos[circle(index - 1)], 0);
                  translate(index, delta.x + slidePos[index], 0);
                  translate(circle(index + 1), delta.x + slidePos[circle(index + 1)], 0);
                } else {
                  if (options.bouncing) {
                    delta.x = delta.x / ((!index && delta.x > 0 || index == slides.length - 1 && delta.x < 0) ? (Math.abs(delta.x) / width + 1) : 1);
                  } else {
                    if (width * index - delta.x < 0) {
                      delta.x = Math.min(delta.x, width * index);
                    }
                    if (Math.abs(delta.x) > width * (slides.length - index - 1)) {
                      delta.x = Math.max(-width * (slides.length - index - 1), delta.x);
                    }
                  }
                  translate(index - 1, delta.x + slidePos[index - 1], 0);
                  translate(index, delta.x + slidePos[index], 0);
                  translate(index + 1, delta.x + slidePos[index + 1], 0);
                }
                options.onDrag && options.onDrag();
              }
            },
            end: function() {
              var duration = +new Date() - start.time;
              var isValidSlide = Number(duration) < 250 && Math.abs(delta.x) > 20 || Math.abs(delta.x) > width / 2;
              var isPastBounds = (!index && delta.x > 0) || (index == slides.length - 1 && delta.x < 0);
              if (options.continuous)
                isPastBounds = false;
              var direction = delta.x < 0;
              if (!isScrolling) {
                if (isValidSlide && !isPastBounds) {
                  if (direction) {
                    if (options.continuous) {
                      move(circle(index - 1), -width, 0);
                      move(circle(index + 2), width, 0);
                    } else {
                      move(index - 1, -width, 0);
                    }
                    move(index, slidePos[index] - width, speed);
                    move(circle(index + 1), slidePos[circle(index + 1)] - width, speed);
                    index = circle(index + 1);
                  } else {
                    if (options.continuous) {
                      move(circle(index + 1), width, 0);
                      move(circle(index - 2), -width, 0);
                    } else {
                      move(index + 1, width, 0);
                    }
                    move(index, slidePos[index] + width, speed);
                    move(circle(index - 1), slidePos[circle(index - 1)] + width, speed);
                    index = circle(index - 1);
                  }
                  options.callback && options.callback(index, slides[index]);
                } else {
                  if (options.continuous) {
                    move(circle(index - 1), -width, speed);
                    move(index, 0, speed);
                    move(circle(index + 1), width, speed);
                  } else {
                    move(index - 1, -width, speed);
                    move(index, 0, speed);
                    move(index + 1, width, speed);
                  }
                }
              }
              element.removeEventListener(touchMoveEvent, events, false);
              element.removeEventListener(mouseMoveEvent, events, false);
              element.removeEventListener(touchEndEvent, events, false);
              element.removeEventListener(mouseEndEvent, events, false);
              document.removeEventListener(touchEndEvent, events, false);
              document.removeEventListener(mouseEndEvent, events, false);
              options.onDragEnd && options.onDragEnd();
            },
            transitionEnd: function(event) {
              if (parseInt(event.target.getAttribute('data-index'), 10) == index) {
                if (delay)
                  begin();
                options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);
              }
            }
          };
          this.update = function() {
            setTimeout(setup);
          };
          this.setup = function() {
            setup();
          };
          this.loop = function(value) {
            if (arguments.length)
              options.continuous = !!value;
            return options.continuous;
          };
          this.enableSlide = function(shouldEnable) {
            if (arguments.length) {
              this.slideIsDisabled = !shouldEnable;
            }
            return !this.slideIsDisabled;
          };
          this.slide = this.select = function(to, speed) {
            stop();
            slide(to, speed);
          };
          this.prev = this.previous = function() {
            stop();
            prev();
          };
          this.next = function() {
            stop();
            next();
          };
          this.stop = function() {
            stop();
          };
          this.start = function() {
            begin();
          };
          this.autoPlay = function(newDelay) {
            if (!delay || delay < 0) {
              stop();
            } else {
              delay = newDelay;
              begin();
            }
          };
          this.currentIndex = this.selected = function() {
            return index;
          };
          this.slidesCount = this.count = function() {
            return length;
          };
          this.kill = function() {
            stop();
            element.style.width = '';
            element.style.left = '';
            slides && (slides = []);
            if (browser.addEventListener) {
              element.removeEventListener(touchStartEvent, events, false);
              element.removeEventListener(mouseStartEvent, events, false);
              element.removeEventListener('webkitTransitionEnd', events, false);
              element.removeEventListener('msTransitionEnd', events, false);
              element.removeEventListener('oTransitionEnd', events, false);
              element.removeEventListener('otransitionend', events, false);
              element.removeEventListener('transitionend', events, false);
              window.removeEventListener('resize', events, false);
            } else {
              window.onresize = null;
            }
          };
          this.load = function() {
            setup();
            if (delay)
              begin();
            if (browser.addEventListener) {
              element.addEventListener(touchStartEvent, events, false);
              element.addEventListener(mouseStartEvent, events, false);
              if (browser.transitions) {
                element.addEventListener('webkitTransitionEnd', events, false);
                element.addEventListener('msTransitionEnd', events, false);
                element.addEventListener('oTransitionEnd', events, false);
                element.addEventListener('otransitionend', events, false);
                element.addEventListener('transitionend', events, false);
              }
              window.addEventListener('resize', events, false);
            } else {
              window.onresize = function() {
                setup();
              };
            }
          };
        }});
    })(ionic);
    (function() {
      'use strict';
      var $;
      var Swiper = function(container, params, _scope, $compile) {
        if (!(this instanceof Swiper))
          return new Swiper(container, params);
        var defaults = {
          direction: 'horizontal',
          touchEventsTarget: 'container',
          initialSlide: 0,
          speed: 300,
          autoplay: false,
          autoplayDisableOnInteraction: true,
          iOSEdgeSwipeDetection: false,
          iOSEdgeSwipeThreshold: 20,
          freeMode: false,
          freeModeMomentum: true,
          freeModeMomentumRatio: 1,
          freeModeMomentumBounce: true,
          freeModeMomentumBounceRatio: 1,
          freeModeSticky: false,
          freeModeMinimumVelocity: 0.02,
          autoHeight: false,
          setWrapperSize: false,
          virtualTranslate: false,
          effect: 'slide',
          coverflow: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            modifier: 1,
            slideShadows: true
          },
          cube: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94
          },
          fade: {crossFade: false},
          parallax: false,
          scrollbar: null,
          scrollbarHide: true,
          scrollbarDraggable: false,
          scrollbarSnapOnRelease: false,
          keyboardControl: false,
          mousewheelControl: false,
          mousewheelReleaseOnEdges: false,
          mousewheelInvert: false,
          mousewheelForceToAxis: false,
          mousewheelSensitivity: 1,
          hashnav: false,
          breakpoints: undefined,
          spaceBetween: 0,
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerColumnFill: 'column',
          slidesPerGroup: 1,
          centeredSlides: false,
          slidesOffsetBefore: 0,
          slidesOffsetAfter: 0,
          roundLengths: false,
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: true,
          shortSwipes: true,
          longSwipes: true,
          longSwipesRatio: 0.5,
          longSwipesMs: 300,
          followFinger: true,
          onlyExternal: false,
          threshold: 0,
          touchMoveStopPropagation: true,
          pagination: null,
          paginationElement: 'span',
          paginationClickable: false,
          paginationHide: false,
          paginationBulletRender: null,
          resistance: true,
          resistanceRatio: 0.85,
          nextButton: null,
          prevButton: null,
          watchSlidesProgress: false,
          watchSlidesVisibility: false,
          grabCursor: false,
          preventClicks: true,
          preventClicksPropagation: true,
          slideToClickedSlide: false,
          lazyLoading: false,
          lazyLoadingInPrevNext: false,
          lazyLoadingOnTransitionStart: false,
          preloadImages: true,
          updateOnImagesReady: true,
          loop: false,
          loopAdditionalSlides: 0,
          loopedSlides: null,
          control: undefined,
          controlInverse: false,
          controlBy: 'slide',
          allowSwipeToPrev: true,
          allowSwipeToNext: true,
          swipeHandler: null,
          noSwiping: true,
          noSwipingClass: 'swiper-no-swiping',
          slideClass: 'swiper-slide',
          slideActiveClass: 'swiper-slide-active',
          slideVisibleClass: 'swiper-slide-visible',
          slideDuplicateClass: 'swiper-slide-duplicate',
          slideNextClass: 'swiper-slide-next',
          slidePrevClass: 'swiper-slide-prev',
          wrapperClass: 'swiper-wrapper',
          bulletClass: 'swiper-pagination-bullet',
          bulletActiveClass: 'swiper-pagination-bullet-active',
          buttonDisabledClass: 'swiper-button-disabled',
          paginationHiddenClass: 'swiper-pagination-hidden',
          observer: false,
          observeParents: false,
          a11y: false,
          prevSlideMessage: 'Previous slide',
          nextSlideMessage: 'Next slide',
          firstSlideMessage: 'This is the first slide',
          lastSlideMessage: 'This is the last slide',
          paginationBulletMessage: 'Go to slide {{index}}',
          runCallbacksOnInit: true
        };
        var initialVirtualTranslate = params && params.virtualTranslate;
        params = params || {};
        var originalParams = {};
        for (var param in params) {
          if (typeof params[param] === 'object' && !(params[param].nodeType || params[param] === window || params[param] === document || (typeof Dom7 !== 'undefined' && params[param] instanceof Dom7) || (typeof jQuery !== 'undefined' && params[param] instanceof jQuery))) {
            originalParams[param] = {};
            for (var deepParam in params[param]) {
              originalParams[param][deepParam] = params[param][deepParam];
            }
          } else {
            originalParams[param] = params[param];
          }
        }
        for (var def in defaults) {
          if (typeof params[def] === 'undefined') {
            params[def] = defaults[def];
          } else if (typeof params[def] === 'object') {
            for (var deepDef in defaults[def]) {
              if (typeof params[def][deepDef] === 'undefined') {
                params[def][deepDef] = defaults[def][deepDef];
              }
            }
          }
        }
        var s = this;
        s.params = params;
        s.originalParams = originalParams;
        s.classNames = [];
        if (typeof $ !== 'undefined' && typeof Dom7 !== 'undefined') {
          $ = Dom7;
        }
        if (typeof $ === 'undefined') {
          if (typeof Dom7 === 'undefined') {
            $ = window.Dom7 || window.Zepto || window.jQuery;
          } else {
            $ = Dom7;
          }
          if (!$)
            return;
        }
        s.$ = $;
        s.currentBreakpoint = undefined;
        s.getActiveBreakpoint = function() {
          if (!s.params.breakpoints)
            return false;
          var breakpoint = false;
          var points = [],
              point;
          for (point in s.params.breakpoints) {
            if (s.params.breakpoints.hasOwnProperty(point)) {
              points.push(point);
            }
          }
          points.sort(function(a, b) {
            return parseInt(a, 10) > parseInt(b, 10);
          });
          for (var i = 0; i < points.length; i++) {
            point = points[i];
            if (point >= window.innerWidth && !breakpoint) {
              breakpoint = point;
            }
          }
          return breakpoint || 'max';
        };
        s.setBreakpoint = function() {
          var breakpoint = s.getActiveBreakpoint();
          if (breakpoint && s.currentBreakpoint !== breakpoint) {
            var breakPointsParams = breakpoint in s.params.breakpoints ? s.params.breakpoints[breakpoint] : s.originalParams;
            for (var param in breakPointsParams) {
              s.params[param] = breakPointsParams[param];
            }
            s.currentBreakpoint = breakpoint;
          }
        };
        if (s.params.breakpoints) {
          s.setBreakpoint();
        }
        s.container = $(container);
        if (s.container.length === 0)
          return;
        if (s.container.length > 1) {
          s.container.each(function() {
            new Swiper(this, params);
          });
          return;
        }
        s.container[0].swiper = s;
        s.container.data('swiper', s);
        s.classNames.push('swiper-container-' + s.params.direction);
        if (s.params.freeMode) {
          s.classNames.push('swiper-container-free-mode');
        }
        if (!s.support.flexbox) {
          s.classNames.push('swiper-container-no-flexbox');
          s.params.slidesPerColumn = 1;
        }
        if (s.params.autoHeight) {
          s.classNames.push('swiper-container-autoheight');
        }
        if (s.params.parallax || s.params.watchSlidesVisibility) {
          s.params.watchSlidesProgress = true;
        }
        if (['cube', 'coverflow'].indexOf(s.params.effect) >= 0) {
          if (s.support.transforms3d) {
            s.params.watchSlidesProgress = true;
            s.classNames.push('swiper-container-3d');
          } else {
            s.params.effect = 'slide';
          }
        }
        if (s.params.effect !== 'slide') {
          s.classNames.push('swiper-container-' + s.params.effect);
        }
        if (s.params.effect === 'cube') {
          s.params.resistanceRatio = 0;
          s.params.slidesPerView = 1;
          s.params.slidesPerColumn = 1;
          s.params.slidesPerGroup = 1;
          s.params.centeredSlides = false;
          s.params.spaceBetween = 0;
          s.params.virtualTranslate = true;
          s.params.setWrapperSize = false;
        }
        if (s.params.effect === 'fade') {
          s.params.slidesPerView = 1;
          s.params.slidesPerColumn = 1;
          s.params.slidesPerGroup = 1;
          s.params.watchSlidesProgress = true;
          s.params.spaceBetween = 0;
          if (typeof initialVirtualTranslate === 'undefined') {
            s.params.virtualTranslate = true;
          }
        }
        if (s.params.grabCursor && s.support.touch) {
          s.params.grabCursor = false;
        }
        s.wrapper = s.container.children('.' + s.params.wrapperClass);
        if (s.params.pagination) {
          s.paginationContainer = $(s.params.pagination);
          if (s.params.paginationClickable) {
            s.paginationContainer.addClass('swiper-pagination-clickable');
          }
        }
        function isH() {
          return s.params.direction === 'horizontal';
        }
        s.rtl = isH() && (s.container[0].dir.toLowerCase() === 'rtl' || s.container.css('direction') === 'rtl');
        if (s.rtl) {
          s.classNames.push('swiper-container-rtl');
        }
        if (s.rtl) {
          s.wrongRTL = s.wrapper.css('display') === '-webkit-box';
        }
        if (s.params.slidesPerColumn > 1) {
          s.classNames.push('swiper-container-multirow');
        }
        if (s.device.android) {
          s.classNames.push('swiper-container-android');
        }
        s.container.addClass(s.classNames.join(' '));
        s.translate = 0;
        s.progress = 0;
        s.velocity = 0;
        s.lockSwipeToNext = function() {
          s.params.allowSwipeToNext = false;
        };
        s.lockSwipeToPrev = function() {
          s.params.allowSwipeToPrev = false;
        };
        s.lockSwipes = function() {
          s.params.allowSwipeToNext = s.params.allowSwipeToPrev = false;
        };
        s.unlockSwipeToNext = function() {
          s.params.allowSwipeToNext = true;
        };
        s.unlockSwipeToPrev = function() {
          s.params.allowSwipeToPrev = true;
        };
        s.unlockSwipes = function() {
          s.params.allowSwipeToNext = s.params.allowSwipeToPrev = true;
        };
        function round(a) {
          return Math.floor(a);
        }
        if (s.params.grabCursor) {
          s.container[0].style.cursor = 'move';
          s.container[0].style.cursor = '-webkit-grab';
          s.container[0].style.cursor = '-moz-grab';
          s.container[0].style.cursor = 'grab';
        }
        s.imagesToLoad = [];
        s.imagesLoaded = 0;
        s.loadImage = function(imgElement, src, srcset, checkForComplete, callback) {
          var image;
          function onReady() {
            if (callback)
              callback();
          }
          if (!imgElement.complete || !checkForComplete) {
            if (src) {
              image = new window.Image();
              image.onload = onReady;
              image.onerror = onReady;
              if (srcset) {
                image.srcset = srcset;
              }
              if (src) {
                image.src = src;
              }
            } else {
              onReady();
            }
          } else {
            onReady();
          }
        };
        s.preloadImages = function() {
          s.imagesToLoad = s.container.find('img');
          function _onReady() {
            if (typeof s === 'undefined' || s === null)
              return;
            if (s.imagesLoaded !== undefined)
              s.imagesLoaded++;
            if (s.imagesLoaded === s.imagesToLoad.length) {
              if (s.params.updateOnImagesReady)
                s.update();
              s.emit('onImagesReady', s);
            }
          }
          for (var i = 0; i < s.imagesToLoad.length; i++) {
            s.loadImage(s.imagesToLoad[i], (s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute('src')), (s.imagesToLoad[i].srcset || s.imagesToLoad[i].getAttribute('srcset')), true, _onReady);
          }
        };
        s.autoplayTimeoutId = undefined;
        s.autoplaying = false;
        s.autoplayPaused = false;
        function autoplay() {
          s.autoplayTimeoutId = setTimeout(function() {
            if (s.params.loop) {
              s.fixLoop();
              s._slideNext();
            } else {
              if (!s.isEnd) {
                s._slideNext();
              } else {
                if (!params.autoplayStopOnLast) {
                  s._slideTo(0);
                } else {
                  s.stopAutoplay();
                }
              }
            }
          }, s.params.autoplay);
        }
        s.startAutoplay = function() {
          if (typeof s.autoplayTimeoutId !== 'undefined')
            return false;
          if (!s.params.autoplay)
            return false;
          if (s.autoplaying)
            return false;
          s.autoplaying = true;
          s.emit('onAutoplayStart', s);
          autoplay();
        };
        s.stopAutoplay = function(internal) {
          if (!s.autoplayTimeoutId)
            return;
          if (s.autoplayTimeoutId)
            clearTimeout(s.autoplayTimeoutId);
          s.autoplaying = false;
          s.autoplayTimeoutId = undefined;
          s.emit('onAutoplayStop', s);
        };
        s.pauseAutoplay = function(speed) {
          if (s.autoplayPaused)
            return;
          if (s.autoplayTimeoutId)
            clearTimeout(s.autoplayTimeoutId);
          s.autoplayPaused = true;
          if (speed === 0) {
            s.autoplayPaused = false;
            autoplay();
          } else {
            s.wrapper.transitionEnd(function() {
              if (!s)
                return;
              s.autoplayPaused = false;
              if (!s.autoplaying) {
                s.stopAutoplay();
              } else {
                autoplay();
              }
            });
          }
        };
        s.minTranslate = function() {
          return (-s.snapGrid[0]);
        };
        s.maxTranslate = function() {
          return (-s.snapGrid[s.snapGrid.length - 1]);
        };
        s.updateAutoHeight = function() {
          var newHeight = s.slides.eq(s.activeIndex)[0].offsetHeight;
          if (newHeight)
            s.wrapper.css('height', s.slides.eq(s.activeIndex)[0].offsetHeight + 'px');
        };
        s.updateContainerSize = function() {
          var width,
              height;
          if (typeof s.params.width !== 'undefined') {
            width = s.params.width;
          } else {
            width = s.container[0].clientWidth;
          }
          if (typeof s.params.height !== 'undefined') {
            height = s.params.height;
          } else {
            height = s.container[0].clientHeight;
          }
          if (width === 0 && isH() || height === 0 && !isH()) {
            return;
          }
          width = width - parseInt(s.container.css('padding-left'), 10) - parseInt(s.container.css('padding-right'), 10);
          height = height - parseInt(s.container.css('padding-top'), 10) - parseInt(s.container.css('padding-bottom'), 10);
          s.width = width;
          s.height = height;
          s.size = isH() ? s.width : s.height;
        };
        s.updateSlidesSize = function() {
          s.slides = s.wrapper.children('.' + s.params.slideClass);
          s.snapGrid = [];
          s.slidesGrid = [];
          s.slidesSizesGrid = [];
          var spaceBetween = s.params.spaceBetween,
              slidePosition = -s.params.slidesOffsetBefore,
              i,
              prevSlideSize = 0,
              index = 0;
          if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * s.size;
          }
          s.virtualSize = -spaceBetween;
          if (s.rtl)
            s.slides.css({
              marginLeft: '',
              marginTop: ''
            });
          else
            s.slides.css({
              marginRight: '',
              marginBottom: ''
            });
          var slidesNumberEvenToRows;
          if (s.params.slidesPerColumn > 1) {
            if (Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn) {
              slidesNumberEvenToRows = s.slides.length;
            } else {
              slidesNumberEvenToRows = Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn;
            }
            if (s.params.slidesPerView !== 'auto' && s.params.slidesPerColumnFill === 'row') {
              slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, s.params.slidesPerView * s.params.slidesPerColumn);
            }
          }
          var slideSize;
          var slidesPerColumn = s.params.slidesPerColumn;
          var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
          var numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
          for (i = 0; i < s.slides.length; i++) {
            slideSize = 0;
            var slide = s.slides.eq(i);
            if (s.params.slidesPerColumn > 1) {
              var newSlideOrderIndex;
              var column,
                  row;
              if (s.params.slidesPerColumnFill === 'column') {
                column = Math.floor(i / slidesPerColumn);
                row = i - column * slidesPerColumn;
                if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
                  if (++row >= slidesPerColumn) {
                    row = 0;
                    column++;
                  }
                }
                newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
                slide.css({
                  '-webkit-box-ordinal-group': newSlideOrderIndex,
                  '-moz-box-ordinal-group': newSlideOrderIndex,
                  '-ms-flex-order': newSlideOrderIndex,
                  '-webkit-order': newSlideOrderIndex,
                  'order': newSlideOrderIndex
                });
              } else {
                row = Math.floor(i / slidesPerRow);
                column = i - row * slidesPerRow;
              }
              slide.css({'margin-top': (row !== 0 && s.params.spaceBetween) && (s.params.spaceBetween + 'px')}).attr('data-swiper-column', column).attr('data-swiper-row', row);
            }
            if (slide.css('display') === 'none')
              continue;
            if (s.params.slidesPerView === 'auto') {
              slideSize = isH() ? slide.outerWidth(true) : slide.outerHeight(true);
              if (s.params.roundLengths)
                slideSize = round(slideSize);
            } else {
              slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView;
              if (s.params.roundLengths)
                slideSize = round(slideSize);
              if (isH()) {
                s.slides[i].style.width = slideSize + 'px';
              } else {
                s.slides[i].style.height = slideSize + 'px';
              }
            }
            s.slides[i].swiperSlideSize = slideSize;
            s.slidesSizesGrid.push(slideSize);
            if (s.params.centeredSlides) {
              slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
              if (i === 0)
                slidePosition = slidePosition - s.size / 2 - spaceBetween;
              if (Math.abs(slidePosition) < 1 / 1000)
                slidePosition = 0;
              if ((index) % s.params.slidesPerGroup === 0)
                s.snapGrid.push(slidePosition);
              s.slidesGrid.push(slidePosition);
            } else {
              if ((index) % s.params.slidesPerGroup === 0)
                s.snapGrid.push(slidePosition);
              s.slidesGrid.push(slidePosition);
              slidePosition = slidePosition + slideSize + spaceBetween;
            }
            s.virtualSize += slideSize + spaceBetween;
            prevSlideSize = slideSize;
            index++;
          }
          s.virtualSize = Math.max(s.virtualSize, s.size) + s.params.slidesOffsetAfter;
          var newSlidesGrid;
          if (s.rtl && s.wrongRTL && (s.params.effect === 'slide' || s.params.effect === 'coverflow')) {
            s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
          }
          if (!s.support.flexbox || s.params.setWrapperSize) {
            if (isH())
              s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
            else
              s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + 'px'});
          }
          if (s.params.slidesPerColumn > 1) {
            s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows;
            s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween;
            s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + 'px'});
            if (s.params.centeredSlides) {
              newSlidesGrid = [];
              for (i = 0; i < s.snapGrid.length; i++) {
                if (s.snapGrid[i] < s.virtualSize + s.snapGrid[0])
                  newSlidesGrid.push(s.snapGrid[i]);
              }
              s.snapGrid = newSlidesGrid;
            }
          }
          if (!s.params.centeredSlides) {
            newSlidesGrid = [];
            for (i = 0; i < s.snapGrid.length; i++) {
              if (s.snapGrid[i] <= s.virtualSize - s.size) {
                newSlidesGrid.push(s.snapGrid[i]);
              }
            }
            s.snapGrid = newSlidesGrid;
            if (Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1])) {
              s.snapGrid.push(s.virtualSize - s.size);
            }
          }
          if (s.snapGrid.length === 0)
            s.snapGrid = [0];
          if (s.params.spaceBetween !== 0) {
            if (isH()) {
              if (s.rtl)
                s.slides.css({marginLeft: spaceBetween + 'px'});
              else
                s.slides.css({marginRight: spaceBetween + 'px'});
            } else
              s.slides.css({marginBottom: spaceBetween + 'px'});
          }
          if (s.params.watchSlidesProgress) {
            s.updateSlidesOffset();
          }
        };
        s.updateSlidesOffset = function() {
          for (var i = 0; i < s.slides.length; i++) {
            s.slides[i].swiperSlideOffset = isH() ? s.slides[i].offsetLeft : s.slides[i].offsetTop;
          }
        };
        s.updateSlidesProgress = function(translate) {
          if (typeof translate === 'undefined') {
            translate = s.translate || 0;
          }
          if (s.slides.length === 0)
            return;
          if (typeof s.slides[0].swiperSlideOffset === 'undefined')
            s.updateSlidesOffset();
          var offsetCenter = -translate;
          if (s.rtl)
            offsetCenter = translate;
          s.slides.removeClass(s.params.slideVisibleClass);
          for (var i = 0; i < s.slides.length; i++) {
            var slide = s.slides[i];
            var slideProgress = (offsetCenter - slide.swiperSlideOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
            if (s.params.watchSlidesVisibility) {
              var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
              var slideAfter = slideBefore + s.slidesSizesGrid[i];
              var isVisible = (slideBefore >= 0 && slideBefore < s.size) || (slideAfter > 0 && slideAfter <= s.size) || (slideBefore <= 0 && slideAfter >= s.size);
              if (isVisible) {
                s.slides.eq(i).addClass(s.params.slideVisibleClass);
              }
            }
            slide.progress = s.rtl ? -slideProgress : slideProgress;
          }
        };
        s.updateProgress = function(translate) {
          if (typeof translate === 'undefined') {
            translate = s.translate || 0;
          }
          var translatesDiff = s.maxTranslate() - s.minTranslate();
          var wasBeginning = s.isBeginning;
          var wasEnd = s.isEnd;
          if (translatesDiff === 0) {
            s.progress = 0;
            s.isBeginning = s.isEnd = true;
          } else {
            s.progress = (translate - s.minTranslate()) / (translatesDiff);
            s.isBeginning = s.progress <= 0;
            s.isEnd = s.progress >= 1;
          }
          if (s.isBeginning && !wasBeginning)
            s.emit('onReachBeginning', s);
          if (s.isEnd && !wasEnd)
            s.emit('onReachEnd', s);
          if (s.params.watchSlidesProgress)
            s.updateSlidesProgress(translate);
          s.emit('onProgress', s, s.progress);
        };
        s.updateActiveIndex = function() {
          var translate = s.rtl ? s.translate : -s.translate;
          var newActiveIndex,
              i,
              snapIndex;
          for (i = 0; i < s.slidesGrid.length; i++) {
            if (typeof s.slidesGrid[i + 1] !== 'undefined') {
              if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2) {
                newActiveIndex = i;
              } else if (translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1]) {
                newActiveIndex = i + 1;
              }
            } else {
              if (translate >= s.slidesGrid[i]) {
                newActiveIndex = i;
              }
            }
          }
          if (newActiveIndex < 0 || typeof newActiveIndex === 'undefined')
            newActiveIndex = 0;
          snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup);
          if (snapIndex >= s.snapGrid.length)
            snapIndex = s.snapGrid.length - 1;
          if (newActiveIndex === s.activeIndex) {
            return;
          }
          s.snapIndex = snapIndex;
          s.previousIndex = s.activeIndex;
          s.activeIndex = newActiveIndex;
          s.updateClasses();
        };
        s.updateClasses = function() {
          s.slides.removeClass(s.params.slideActiveClass + ' ' + s.params.slideNextClass + ' ' + s.params.slidePrevClass);
          var activeSlide = s.slides.eq(s.activeIndex);
          activeSlide.addClass(s.params.slideActiveClass);
          activeSlide.next('.' + s.params.slideClass).addClass(s.params.slideNextClass);
          activeSlide.prev('.' + s.params.slideClass).addClass(s.params.slidePrevClass);
          if (s.bullets && s.bullets.length > 0) {
            s.bullets.removeClass(s.params.bulletActiveClass);
            var bulletIndex;
            if (s.params.loop) {
              bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup;
              if (bulletIndex > s.slides.length - 1 - s.loopedSlides * 2) {
                bulletIndex = bulletIndex - (s.slides.length - s.loopedSlides * 2);
              }
              if (bulletIndex > s.bullets.length - 1)
                bulletIndex = bulletIndex - s.bullets.length;
            } else {
              if (typeof s.snapIndex !== 'undefined') {
                bulletIndex = s.snapIndex;
              } else {
                bulletIndex = s.activeIndex || 0;
              }
            }
            if (s.paginationContainer.length > 1) {
              s.bullets.each(function() {
                if ($(this).index() === bulletIndex)
                  $(this).addClass(s.params.bulletActiveClass);
              });
            } else {
              s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass);
            }
          }
          if (!s.params.loop) {
            if (s.params.prevButton) {
              if (s.isBeginning) {
                $(s.params.prevButton).addClass(s.params.buttonDisabledClass);
                if (s.params.a11y && s.a11y)
                  s.a11y.disable($(s.params.prevButton));
              } else {
                $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
                if (s.params.a11y && s.a11y)
                  s.a11y.enable($(s.params.prevButton));
              }
            }
            if (s.params.nextButton) {
              if (s.isEnd) {
                $(s.params.nextButton).addClass(s.params.buttonDisabledClass);
                if (s.params.a11y && s.a11y)
                  s.a11y.disable($(s.params.nextButton));
              } else {
                $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
                if (s.params.a11y && s.a11y)
                  s.a11y.enable($(s.params.nextButton));
              }
            }
          }
        };
        s.updatePagination = function() {
          if (!s.params.pagination)
            return;
          if (s.paginationContainer && s.paginationContainer.length > 0) {
            var bulletsHTML = '';
            var numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - s.loopedSlides * 2) / s.params.slidesPerGroup) : s.snapGrid.length;
            for (var i = 0; i < numberOfBullets; i++) {
              if (s.params.paginationBulletRender) {
                bulletsHTML += s.params.paginationBulletRender(i, s.params.bulletClass);
              } else {
                bulletsHTML += '<' + s.params.paginationElement + ' class="' + s.params.bulletClass + '"></' + s.params.paginationElement + '>';
              }
            }
            s.paginationContainer.html(bulletsHTML);
            s.bullets = s.paginationContainer.find('.' + s.params.bulletClass);
            if (s.params.paginationClickable && s.params.a11y && s.a11y) {
              s.a11y.initPagination();
            }
          }
        };
        s.update = function(updateTranslate) {
          s.updateContainerSize();
          s.updateSlidesSize();
          s.updateProgress();
          s.updatePagination();
          s.updateClasses();
          if (s.params.scrollbar && s.scrollbar) {
            s.scrollbar.set();
          }
          function forceSetTranslate() {
            newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
            s.setWrapperTranslate(newTranslate);
            s.updateActiveIndex();
            s.updateClasses();
          }
          if (updateTranslate) {
            var translated,
                newTranslate;
            if (s.controller && s.controller.spline) {
              s.controller.spline = undefined;
            }
            if (s.params.freeMode) {
              forceSetTranslate();
              if (s.params.autoHeight) {
                s.updateAutoHeight();
              }
            } else {
              if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
                translated = s.slideTo(s.slides.length - 1, 0, false, true);
              } else {
                translated = s.slideTo(s.activeIndex, 0, false, true);
              }
              if (!translated) {
                forceSetTranslate();
              }
            }
          } else if (s.params.autoHeight) {
            s.updateAutoHeight();
          }
        };
        s.onResize = function(forceUpdatePagination) {
          if (s.params.breakpoints) {
            s.setBreakpoint();
          }
          var allowSwipeToPrev = s.params.allowSwipeToPrev;
          var allowSwipeToNext = s.params.allowSwipeToNext;
          s.params.allowSwipeToPrev = s.params.allowSwipeToNext = true;
          s.updateContainerSize();
          s.updateSlidesSize();
          if (s.params.slidesPerView === 'auto' || s.params.freeMode || forceUpdatePagination)
            s.updatePagination();
          if (s.params.scrollbar && s.scrollbar) {
            s.scrollbar.set();
          }
          if (s.controller && s.controller.spline) {
            s.controller.spline = undefined;
          }
          if (s.params.freeMode) {
            var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
            s.setWrapperTranslate(newTranslate);
            s.updateActiveIndex();
            s.updateClasses();
            if (s.params.autoHeight) {
              s.updateAutoHeight();
            }
          } else {
            s.updateClasses();
            if ((s.params.slidesPerView === 'auto' || s.params.slidesPerView > 1) && s.isEnd && !s.params.centeredSlides) {
              s.slideTo(s.slides.length - 1, 0, false, true);
            } else {
              s.slideTo(s.activeIndex, 0, false, true);
            }
          }
          s.params.allowSwipeToPrev = allowSwipeToPrev;
          s.params.allowSwipeToNext = allowSwipeToNext;
        };
        var desktopEvents = ['mousedown', 'mousemove', 'mouseup'];
        if (window.navigator.pointerEnabled)
          desktopEvents = ['pointerdown', 'pointermove', 'pointerup'];
        else if (window.navigator.msPointerEnabled)
          desktopEvents = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];
        s.touchEvents = {
          start: s.support.touch || !s.params.simulateTouch ? 'touchstart' : desktopEvents[0],
          move: s.support.touch || !s.params.simulateTouch ? 'touchmove' : desktopEvents[1],
          end: s.support.touch || !s.params.simulateTouch ? 'touchend' : desktopEvents[2]
        };
        if (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) {
          (s.params.touchEventsTarget === 'container' ? s.container : s.wrapper).addClass('swiper-wp8-' + s.params.direction);
        }
        s.initEvents = function(detach) {
          var actionDom = detach ? 'off' : 'on';
          var action = detach ? 'removeEventListener' : 'addEventListener';
          var touchEventsTarget = s.params.touchEventsTarget === 'container' ? s.container[0] : s.wrapper[0];
          var target = s.support.touch ? touchEventsTarget : document;
          var moveCapture = s.params.nested ? true : false;
          if (s.browser.ie) {
            touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
            target[action](s.touchEvents.move, s.onTouchMove, moveCapture);
            target[action](s.touchEvents.end, s.onTouchEnd, false);
          } else {
            if (s.support.touch) {
              touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, false);
              touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture);
              touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, false);
            }
            if (params.simulateTouch && !s.device.ios && !s.device.android) {
              touchEventsTarget[action]('mousedown', s.onTouchStart, false);
              document[action]('mousemove', s.onTouchMove, moveCapture);
              document[action]('mouseup', s.onTouchEnd, false);
            }
          }
          window[action]('resize', s.onResize);
          if (s.params.nextButton) {
            $(s.params.nextButton)[actionDom]('click', s.onClickNext);
            if (s.params.a11y && s.a11y)
              $(s.params.nextButton)[actionDom]('keydown', s.a11y.onEnterKey);
          }
          if (s.params.prevButton) {
            $(s.params.prevButton)[actionDom]('click', s.onClickPrev);
            if (s.params.a11y && s.a11y)
              $(s.params.prevButton)[actionDom]('keydown', s.a11y.onEnterKey);
          }
          if (s.params.pagination && s.params.paginationClickable) {
            $(s.paginationContainer)[actionDom]('click', '.' + s.params.bulletClass, s.onClickIndex);
            if (s.params.a11y && s.a11y)
              $(s.paginationContainer)[actionDom]('keydown', '.' + s.params.bulletClass, s.a11y.onEnterKey);
          }
          if (s.params.preventClicks || s.params.preventClicksPropagation)
            touchEventsTarget[action]('click', s.preventClicks, true);
        };
        s.attachEvents = function(detach) {
          s.initEvents();
        };
        s.detachEvents = function() {
          s.initEvents(true);
        };
        s.allowClick = true;
        s.preventClicks = function(e) {
          if (!s.allowClick) {
            if (s.params.preventClicks)
              e.preventDefault();
            if (s.params.preventClicksPropagation && s.animating) {
              e.stopPropagation();
              e.stopImmediatePropagation();
            }
          }
        };
        s.onClickNext = function(e) {
          e.preventDefault();
          if (s.isEnd && !s.params.loop)
            return;
          s.slideNext();
        };
        s.onClickPrev = function(e) {
          e.preventDefault();
          if (s.isBeginning && !s.params.loop)
            return;
          s.slidePrev();
        };
        s.onClickIndex = function(e) {
          e.preventDefault();
          var index = $(this).index() * s.params.slidesPerGroup;
          if (s.params.loop)
            index = index + s.loopedSlides;
          s.slideTo(index);
        };
        function findElementInEvent(e, selector) {
          var el = $(e.target);
          if (!el.is(selector)) {
            if (typeof selector === 'string') {
              el = el.parents(selector);
            } else if (selector.nodeType) {
              var found;
              el.parents().each(function(index, _el) {
                if (_el === selector)
                  found = selector;
              });
              if (!found)
                return undefined;
              else
                return selector;
            }
          }
          if (el.length === 0) {
            return undefined;
          }
          return el[0];
        }
        s.updateClickedSlide = function(e) {
          var slide = findElementInEvent(e, '.' + s.params.slideClass);
          var slideFound = false;
          if (slide) {
            for (var i = 0; i < s.slides.length; i++) {
              if (s.slides[i] === slide)
                slideFound = true;
            }
          }
          if (slide && slideFound) {
            s.clickedSlide = slide;
            s.clickedIndex = $(slide).index();
          } else {
            s.clickedSlide = undefined;
            s.clickedIndex = undefined;
            return;
          }
          if (s.params.slideToClickedSlide && s.clickedIndex !== undefined && s.clickedIndex !== s.activeIndex) {
            var slideToIndex = s.clickedIndex,
                realIndex,
                duplicatedSlides;
            if (s.params.loop) {
              if (s.animating)
                return;
              realIndex = $(s.clickedSlide).attr('data-swiper-slide-index');
              if (s.params.centeredSlides) {
                if ((slideToIndex < s.loopedSlides - s.params.slidesPerView / 2) || (slideToIndex > s.slides.length - s.loopedSlides + s.params.slidesPerView / 2)) {
                  s.fixLoop();
                  slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
                  setTimeout(function() {
                    s.slideTo(slideToIndex);
                  }, 0);
                } else {
                  s.slideTo(slideToIndex);
                }
              } else {
                if (slideToIndex > s.slides.length - s.params.slidesPerView) {
                  s.fixLoop();
                  slideToIndex = s.wrapper.children('.' + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.swiper-slide-duplicate)').eq(0).index();
                  setTimeout(function() {
                    s.slideTo(slideToIndex);
                  }, 0);
                } else {
                  s.slideTo(slideToIndex);
                }
              }
            } else {
              s.slideTo(slideToIndex);
            }
          }
        };
        var isTouched,
            isMoved,
            allowTouchCallbacks,
            touchStartTime,
            isScrolling,
            currentTranslate,
            startTranslate,
            allowThresholdMove,
            formElements = 'input, select, textarea, button',
            lastClickTime = Date.now(),
            clickTimeout,
            velocities = [],
            allowMomentumBounce;
        s.animating = false;
        s.touches = {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        };
        var isTouchEvent,
            startMoving;
        s.onTouchStart = function(e) {
          if (e.originalEvent)
            e = e.originalEvent;
          isTouchEvent = e.type === 'touchstart';
          if (!isTouchEvent && 'which' in e && e.which === 3)
            return;
          if (s.params.noSwiping && findElementInEvent(e, '.' + s.params.noSwipingClass)) {
            s.allowClick = true;
            return;
          }
          if (s.params.swipeHandler) {
            if (!findElementInEvent(e, s.params.swipeHandler))
              return;
          }
          var startX = s.touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          var startY = s.touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          if (s.device.ios && s.params.iOSEdgeSwipeDetection && startX <= s.params.iOSEdgeSwipeThreshold) {
            return;
          }
          isTouched = true;
          isMoved = false;
          allowTouchCallbacks = true;
          isScrolling = undefined;
          startMoving = undefined;
          s.touches.startX = startX;
          s.touches.startY = startY;
          touchStartTime = Date.now();
          s.allowClick = true;
          s.updateContainerSize();
          s.swipeDirection = undefined;
          if (s.params.threshold > 0)
            allowThresholdMove = false;
          if (e.type !== 'touchstart') {
            var preventDefault = true;
            if ($(e.target).is(formElements))
              preventDefault = false;
            if (document.activeElement && $(document.activeElement).is(formElements)) {
              document.activeElement.blur();
            }
            if (preventDefault) {
              e.preventDefault();
            }
          }
          s.emit('onTouchStart', s, e);
        };
        s.onTouchMove = function(e) {
          if (e.originalEvent)
            e = e.originalEvent;
          if (isTouchEvent && e.type === 'mousemove')
            return;
          if (e.preventedByNestedSwiper)
            return;
          if (s.params.onlyExternal) {
            s.allowClick = false;
            if (isTouched) {
              s.touches.startX = s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
              s.touches.startY = s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
              touchStartTime = Date.now();
            }
            return;
          }
          if (isTouchEvent && document.activeElement) {
            if (e.target === document.activeElement && $(e.target).is(formElements)) {
              isMoved = true;
              s.allowClick = false;
              return;
            }
          }
          if (allowTouchCallbacks) {
            s.emit('onTouchMove', s, e);
          }
          if (e.targetTouches && e.targetTouches.length > 1)
            return;
          s.touches.currentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          s.touches.currentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          if (typeof isScrolling === 'undefined') {
            var touchAngle = Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) * 180 / Math.PI;
            isScrolling = isH() ? touchAngle > s.params.touchAngle : (90 - touchAngle > s.params.touchAngle);
          }
          if (isScrolling) {
            s.emit('onTouchMoveOpposite', s, e);
          }
          if (typeof startMoving === 'undefined' && s.browser.ieTouch) {
            if (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) {
              startMoving = true;
            }
          }
          if (!isTouched)
            return;
          if (isScrolling) {
            isTouched = false;
            return;
          }
          if (!startMoving && s.browser.ieTouch) {
            return;
          }
          s.allowClick = false;
          s.emit('onSliderMove', s, e);
          e.preventDefault();
          if (s.params.touchMoveStopPropagation && !s.params.nested) {
            e.stopPropagation();
          }
          if (!isMoved) {
            if (params.loop) {
              s.fixLoop();
            }
            startTranslate = s.getWrapperTranslate();
            s.setWrapperTransition(0);
            if (s.animating) {
              s.wrapper.trigger('webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd');
            }
            if (s.params.autoplay && s.autoplaying) {
              if (s.params.autoplayDisableOnInteraction) {
                s.stopAutoplay();
              } else {
                s.pauseAutoplay();
              }
            }
            allowMomentumBounce = false;
            if (s.params.grabCursor) {
              s.container[0].style.cursor = 'move';
              s.container[0].style.cursor = '-webkit-grabbing';
              s.container[0].style.cursor = '-moz-grabbin';
              s.container[0].style.cursor = 'grabbing';
            }
          }
          isMoved = true;
          var diff = s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
          diff = diff * s.params.touchRatio;
          if (s.rtl)
            diff = -diff;
          s.swipeDirection = diff > 0 ? 'prev' : 'next';
          currentTranslate = diff + startTranslate;
          var disableParentSwiper = true;
          if ((diff > 0 && currentTranslate > s.minTranslate())) {
            disableParentSwiper = false;
            if (s.params.resistance)
              currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio);
          } else if (diff < 0 && currentTranslate < s.maxTranslate()) {
            disableParentSwiper = false;
            if (s.params.resistance)
              currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio);
          }
          if (disableParentSwiper) {
            e.preventedByNestedSwiper = true;
          }
          if (!s.params.allowSwipeToNext && s.swipeDirection === 'next' && currentTranslate < startTranslate) {
            currentTranslate = startTranslate;
          }
          if (!s.params.allowSwipeToPrev && s.swipeDirection === 'prev' && currentTranslate > startTranslate) {
            currentTranslate = startTranslate;
          }
          if (!s.params.followFinger)
            return;
          if (s.params.threshold > 0) {
            if (Math.abs(diff) > s.params.threshold || allowThresholdMove) {
              if (!allowThresholdMove) {
                allowThresholdMove = true;
                s.touches.startX = s.touches.currentX;
                s.touches.startY = s.touches.currentY;
                currentTranslate = startTranslate;
                s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                return;
              }
            } else {
              currentTranslate = startTranslate;
              return;
            }
          }
          if (s.params.freeMode || s.params.watchSlidesProgress) {
            s.updateActiveIndex();
          }
          if (s.params.freeMode) {
            if (velocities.length === 0) {
              velocities.push({
                position: s.touches[isH() ? 'startX' : 'startY'],
                time: touchStartTime
              });
            }
            velocities.push({
              position: s.touches[isH() ? 'currentX' : 'currentY'],
              time: (new window.Date()).getTime()
            });
          }
          s.updateProgress(currentTranslate);
          s.setWrapperTranslate(currentTranslate);
        };
        s.onTouchEnd = function(e) {
          if (e.originalEvent)
            e = e.originalEvent;
          if (allowTouchCallbacks) {
            s.emit('onTouchEnd', s, e);
          }
          allowTouchCallbacks = false;
          if (!isTouched)
            return;
          if (s.params.grabCursor && isMoved && isTouched) {
            s.container[0].style.cursor = 'move';
            s.container[0].style.cursor = '-webkit-grab';
            s.container[0].style.cursor = '-moz-grab';
            s.container[0].style.cursor = 'grab';
          }
          var touchEndTime = Date.now();
          var timeDiff = touchEndTime - touchStartTime;
          if (s.allowClick) {
            s.updateClickedSlide(e);
            s.emit('onTap', s, e);
            if (timeDiff < 300 && (touchEndTime - lastClickTime) > 300) {
              if (clickTimeout)
                clearTimeout(clickTimeout);
              clickTimeout = setTimeout(function() {
                if (!s)
                  return;
                if (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass)) {
                  s.paginationContainer.toggleClass(s.params.paginationHiddenClass);
                }
                s.emit('onClick', s, e);
              }, 300);
            }
            if (timeDiff < 300 && (touchEndTime - lastClickTime) < 300) {
              if (clickTimeout)
                clearTimeout(clickTimeout);
              s.emit('onDoubleTap', s, e);
            }
          }
          lastClickTime = Date.now();
          setTimeout(function() {
            if (s)
              s.allowClick = true;
          }, 0);
          if (!isTouched || !isMoved || !s.swipeDirection || s.touches.diff === 0 || currentTranslate === startTranslate) {
            isTouched = isMoved = false;
            return;
          }
          isTouched = isMoved = false;
          var currentPos;
          if (s.params.followFinger) {
            currentPos = s.rtl ? s.translate : -s.translate;
          } else {
            currentPos = -currentTranslate;
          }
          if (s.params.freeMode) {
            if (currentPos < -s.minTranslate()) {
              s.slideTo(s.activeIndex);
              return;
            } else if (currentPos > -s.maxTranslate()) {
              if (s.slides.length < s.snapGrid.length) {
                s.slideTo(s.snapGrid.length - 1);
              } else {
                s.slideTo(s.slides.length - 1);
              }
              return;
            }
            if (s.params.freeModeMomentum) {
              if (velocities.length > 1) {
                var lastMoveEvent = velocities.pop(),
                    velocityEvent = velocities.pop();
                var distance = lastMoveEvent.position - velocityEvent.position;
                var time = lastMoveEvent.time - velocityEvent.time;
                s.velocity = distance / time;
                s.velocity = s.velocity / 2;
                if (Math.abs(s.velocity) < s.params.freeModeMinimumVelocity) {
                  s.velocity = 0;
                }
                if (time > 150 || (new window.Date().getTime() - lastMoveEvent.time) > 300) {
                  s.velocity = 0;
                }
              } else {
                s.velocity = 0;
              }
              velocities.length = 0;
              var momentumDuration = 1000 * s.params.freeModeMomentumRatio;
              var momentumDistance = s.velocity * momentumDuration;
              var newPosition = s.translate + momentumDistance;
              if (s.rtl)
                newPosition = -newPosition;
              var doBounce = false;
              var afterBouncePosition;
              var bounceAmount = Math.abs(s.velocity) * 20 * s.params.freeModeMomentumBounceRatio;
              if (newPosition < s.maxTranslate()) {
                if (s.params.freeModeMomentumBounce) {
                  if (newPosition + s.maxTranslate() < -bounceAmount) {
                    newPosition = s.maxTranslate() - bounceAmount;
                  }
                  afterBouncePosition = s.maxTranslate();
                  doBounce = true;
                  allowMomentumBounce = true;
                } else {
                  newPosition = s.maxTranslate();
                }
              } else if (newPosition > s.minTranslate()) {
                if (s.params.freeModeMomentumBounce) {
                  if (newPosition - s.minTranslate() > bounceAmount) {
                    newPosition = s.minTranslate() + bounceAmount;
                  }
                  afterBouncePosition = s.minTranslate();
                  doBounce = true;
                  allowMomentumBounce = true;
                } else {
                  newPosition = s.minTranslate();
                }
              } else if (s.params.freeModeSticky) {
                var j = 0,
                    nextSlide;
                for (j = 0; j < s.snapGrid.length; j += 1) {
                  if (s.snapGrid[j] > -newPosition) {
                    nextSlide = j;
                    break;
                  }
                }
                if (Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || s.swipeDirection === 'next') {
                  newPosition = s.snapGrid[nextSlide];
                } else {
                  newPosition = s.snapGrid[nextSlide - 1];
                }
                if (!s.rtl)
                  newPosition = -newPosition;
              }
              if (s.velocity !== 0) {
                if (s.rtl) {
                  momentumDuration = Math.abs((-newPosition - s.translate) / s.velocity);
                } else {
                  momentumDuration = Math.abs((newPosition - s.translate) / s.velocity);
                }
              } else if (s.params.freeModeSticky) {
                s.slideReset();
                return;
              }
              if (s.params.freeModeMomentumBounce && doBounce) {
                s.updateProgress(afterBouncePosition);
                s.setWrapperTransition(momentumDuration);
                s.setWrapperTranslate(newPosition);
                s.onTransitionStart();
                s.animating = true;
                s.wrapper.transitionEnd(function() {
                  if (!s || !allowMomentumBounce)
                    return;
                  s.emit('onMomentumBounce', s);
                  s.setWrapperTransition(s.params.speed);
                  s.setWrapperTranslate(afterBouncePosition);
                  s.wrapper.transitionEnd(function() {
                    if (!s)
                      return;
                    s.onTransitionEnd();
                  });
                });
              } else if (s.velocity) {
                s.updateProgress(newPosition);
                s.setWrapperTransition(momentumDuration);
                s.setWrapperTranslate(newPosition);
                s.onTransitionStart();
                if (!s.animating) {
                  s.animating = true;
                  s.wrapper.transitionEnd(function() {
                    if (!s)
                      return;
                    s.onTransitionEnd();
                  });
                }
              } else {
                s.updateProgress(newPosition);
              }
              s.updateActiveIndex();
            }
            if (!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) {
              s.updateProgress();
              s.updateActiveIndex();
            }
            return;
          }
          var i,
              stopIndex = 0,
              groupSize = s.slidesSizesGrid[0];
          for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup) {
            if (typeof s.slidesGrid[i + s.params.slidesPerGroup] !== 'undefined') {
              if (currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup]) {
                stopIndex = i;
                groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i];
              }
            } else {
              if (currentPos >= s.slidesGrid[i]) {
                stopIndex = i;
                groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2];
              }
            }
          }
          var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
          if (timeDiff > s.params.longSwipesMs) {
            if (!s.params.longSwipes) {
              s.slideTo(s.activeIndex);
              return;
            }
            if (s.swipeDirection === 'next') {
              if (ratio >= s.params.longSwipesRatio)
                s.slideTo(stopIndex + s.params.slidesPerGroup);
              else
                s.slideTo(stopIndex);
            }
            if (s.swipeDirection === 'prev') {
              if (ratio > (1 - s.params.longSwipesRatio))
                s.slideTo(stopIndex + s.params.slidesPerGroup);
              else
                s.slideTo(stopIndex);
            }
          } else {
            if (!s.params.shortSwipes) {
              s.slideTo(s.activeIndex);
              return;
            }
            if (s.swipeDirection === 'next') {
              s.slideTo(stopIndex + s.params.slidesPerGroup);
            }
            if (s.swipeDirection === 'prev') {
              s.slideTo(stopIndex);
            }
          }
        };
        s._slideTo = function(slideIndex, speed) {
          return s.slideTo(slideIndex, speed, true, true);
        };
        s.slideTo = function(slideIndex, speed, runCallbacks, internal) {
          if (typeof runCallbacks === 'undefined')
            runCallbacks = true;
          if (typeof slideIndex === 'undefined')
            slideIndex = 0;
          if (slideIndex < 0)
            slideIndex = 0;
          s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup);
          if (s.snapIndex >= s.snapGrid.length)
            s.snapIndex = s.snapGrid.length - 1;
          var translate = -s.snapGrid[s.snapIndex];
          if (s.params.autoplay && s.autoplaying) {
            if (internal || !s.params.autoplayDisableOnInteraction) {
              s.pauseAutoplay(speed);
            } else {
              s.stopAutoplay();
            }
          }
          s.updateProgress(translate);
          for (var i = 0; i < s.slidesGrid.length; i++) {
            if (-Math.floor(translate * 100) >= Math.floor(s.slidesGrid[i] * 100)) {
              slideIndex = i;
            }
          }
          if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate()) {
            return false;
          }
          if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate()) {
            if ((s.activeIndex || 0) !== slideIndex)
              return false;
          }
          if (typeof speed === 'undefined')
            speed = s.params.speed;
          s.previousIndex = s.activeIndex || 0;
          s.activeIndex = slideIndex;
          if ((s.rtl && -translate === s.translate) || (!s.rtl && translate === s.translate)) {
            if (s.params.autoHeight) {
              s.updateAutoHeight();
            }
            s.updateClasses();
            if (s.params.effect !== 'slide') {
              s.setWrapperTranslate(translate);
            }
            return false;
          }
          s.updateClasses();
          s.onTransitionStart(runCallbacks);
          if (speed === 0) {
            s.setWrapperTranslate(translate);
            s.setWrapperTransition(0);
            s.onTransitionEnd(runCallbacks);
          } else {
            s.setWrapperTranslate(translate);
            s.setWrapperTransition(speed);
            if (!s.animating) {
              s.animating = true;
              s.wrapper.transitionEnd(function() {
                if (!s)
                  return;
                s.onTransitionEnd(runCallbacks);
              });
            }
          }
          return true;
        };
        s.onTransitionStart = function(runCallbacks) {
          if (typeof runCallbacks === 'undefined')
            runCallbacks = true;
          if (s.params.autoHeight) {
            s.updateAutoHeight();
          }
          if (s.lazy)
            s.lazy.onTransitionStart();
          if (runCallbacks) {
            s.emit('onTransitionStart', s);
            if (s.activeIndex !== s.previousIndex) {
              s.emit('onSlideChangeStart', s);
              if (s.activeIndex > s.previousIndex) {
                s.emit('onSlideNextStart', s);
              } else {
                s.emit('onSlidePrevStart', s);
              }
            }
          }
        };
        s.onTransitionEnd = function(runCallbacks) {
          s.animating = false;
          s.setWrapperTransition(0);
          if (typeof runCallbacks === 'undefined')
            runCallbacks = true;
          if (s.lazy)
            s.lazy.onTransitionEnd();
          if (runCallbacks) {
            s.emit('onTransitionEnd', s);
            if (s.activeIndex !== s.previousIndex) {
              s.emit('onSlideChangeEnd', s);
              if (s.activeIndex > s.previousIndex) {
                s.emit('onSlideNextEnd', s);
              } else {
                s.emit('onSlidePrevEnd', s);
              }
            }
          }
          if (s.params.hashnav && s.hashnav) {
            s.hashnav.setHash();
          }
        };
        s.slideNext = function(runCallbacks, speed, internal) {
          if (s.params.loop) {
            if (s.animating)
              return false;
            s.fixLoop();
            var clientLeft = s.container[0].clientLeft;
            return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
          } else
            return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal);
        };
        s._slideNext = function(speed) {
          return s.slideNext(true, speed, true);
        };
        s.slidePrev = function(runCallbacks, speed, internal) {
          if (s.params.loop) {
            if (s.animating)
              return false;
            s.fixLoop();
            var clientLeft = s.container[0].clientLeft;
            return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
          } else
            return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal);
        };
        s._slidePrev = function(speed) {
          return s.slidePrev(true, speed, true);
        };
        s.slideReset = function(runCallbacks, speed, internal) {
          return s.slideTo(s.activeIndex, speed, runCallbacks);
        };
        s.setWrapperTransition = function(duration, byController) {
          s.wrapper.transition(duration);
          if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
            s.effects[s.params.effect].setTransition(duration);
          }
          if (s.params.parallax && s.parallax) {
            s.parallax.setTransition(duration);
          }
          if (s.params.scrollbar && s.scrollbar) {
            s.scrollbar.setTransition(duration);
          }
          if (s.params.control && s.controller) {
            s.controller.setTransition(duration, byController);
          }
          s.emit('onSetTransition', s, duration);
        };
        s.setWrapperTranslate = function(translate, updateActiveIndex, byController) {
          var x = 0,
              y = 0,
              z = 0;
          if (isH()) {
            x = s.rtl ? -translate : translate;
          } else {
            y = translate;
          }
          if (s.params.roundLengths) {
            x = round(x);
            y = round(y);
          }
          if (!s.params.virtualTranslate) {
            if (s.support.transforms3d)
              s.wrapper.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
            else
              s.wrapper.transform('translate(' + x + 'px, ' + y + 'px)');
          }
          s.translate = isH() ? x : y;
          var progress;
          var translatesDiff = s.maxTranslate() - s.minTranslate();
          if (translatesDiff === 0) {
            progress = 0;
          } else {
            progress = (translate - s.minTranslate()) / (translatesDiff);
          }
          if (progress !== s.progress) {
            s.updateProgress(translate);
          }
          if (updateActiveIndex)
            s.updateActiveIndex();
          if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
            s.effects[s.params.effect].setTranslate(s.translate);
          }
          if (s.params.parallax && s.parallax) {
            s.parallax.setTranslate(s.translate);
          }
          if (s.params.scrollbar && s.scrollbar) {
            s.scrollbar.setTranslate(s.translate);
          }
          if (s.params.control && s.controller) {
            s.controller.setTranslate(s.translate, byController);
          }
          s.emit('onSetTranslate', s, s.translate);
        };
        s.getTranslate = function(el, axis) {
          var matrix,
              curTransform,
              curStyle,
              transformMatrix;
          if (typeof axis === 'undefined') {
            axis = 'x';
          }
          if (s.params.virtualTranslate) {
            return s.rtl ? -s.translate : s.translate;
          }
          curStyle = window.getComputedStyle(el, null);
          if (window.WebKitCSSMatrix) {
            curTransform = curStyle.transform || curStyle.webkitTransform;
            if (curTransform.split(',').length > 6) {
              curTransform = curTransform.split(', ').map(function(a) {
                return a.replace(',', '.');
              }).join(', ');
            }
            transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
          } else {
            transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
            matrix = transformMatrix.toString().split(',');
          }
          if (axis === 'x') {
            if (window.WebKitCSSMatrix)
              curTransform = transformMatrix.m41;
            else if (matrix.length === 16)
              curTransform = parseFloat(matrix[12]);
            else
              curTransform = parseFloat(matrix[4]);
          }
          if (axis === 'y') {
            if (window.WebKitCSSMatrix)
              curTransform = transformMatrix.m42;
            else if (matrix.length === 16)
              curTransform = parseFloat(matrix[13]);
            else
              curTransform = parseFloat(matrix[5]);
          }
          if (s.rtl && curTransform)
            curTransform = -curTransform;
          return curTransform || 0;
        };
        s.getWrapperTranslate = function(axis) {
          if (typeof axis === 'undefined') {
            axis = isH() ? 'x' : 'y';
          }
          return s.getTranslate(s.wrapper[0], axis);
        };
        s.observers = [];
        function initObserver(target, options) {
          options = options || {};
          var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
          var observer = new ObserverFunc(function(mutations) {
            mutations.forEach(function(mutation) {
              s.onResize(true);
              s.emit('onObserverUpdate', s, mutation);
            });
          });
          observer.observe(target, {
            attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
            childList: typeof options.childList === 'undefined' ? true : options.childList,
            characterData: typeof options.characterData === 'undefined' ? true : options.characterData
          });
          s.observers.push(observer);
        }
        s.initObservers = function() {
          if (s.params.observeParents) {
            var containerParents = s.container.parents();
            for (var i = 0; i < containerParents.length; i++) {
              initObserver(containerParents[i]);
            }
          }
          initObserver(s.container[0], {childList: false});
          initObserver(s.wrapper[0], {attributes: false});
        };
        s.disconnectObservers = function() {
          for (var i = 0; i < s.observers.length; i++) {
            s.observers[i].disconnect();
          }
          s.observers = [];
        };
        s.createLoop = function() {
          var toRemove = s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass);
          angular.element(toRemove).remove();
          var slides = s.wrapper.children('.' + s.params.slideClass);
          if (s.params.slidesPerView === 'auto' && !s.params.loopedSlides)
            s.params.loopedSlides = slides.length;
          s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10);
          s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides;
          if (s.loopedSlides > slides.length) {
            s.loopedSlides = slides.length;
          }
          var prependSlides = [],
              appendSlides = [],
              i,
              scope,
              newNode;
          slides.each(function(index, el) {
            var slide = $(this);
            if (index < s.loopedSlides)
              appendSlides.push(el);
            if (index < slides.length && index >= slides.length - s.loopedSlides)
              prependSlides.push(el);
            slide.attr('data-swiper-slide-index', index);
          });
          for (i = 0; i < appendSlides.length; i++) {
            newNode = angular.element(appendSlides[i]).clone().addClass(s.params.slideDuplicateClass);
            newNode.removeAttr('ng-transclude');
            newNode.removeAttr('ng-repeat');
            scope = angular.element(appendSlides[i]).scope();
            newNode = $compile(newNode)(scope);
            angular.element(s.wrapper).append(newNode);
          }
          for (i = prependSlides.length - 1; i >= 0; i--) {
            newNode = angular.element(prependSlides[i]).clone().addClass(s.params.slideDuplicateClass);
            newNode.removeAttr('ng-transclude');
            newNode.removeAttr('ng-repeat');
            scope = angular.element(prependSlides[i]).scope();
            newNode = $compile(newNode)(scope);
            angular.element(s.wrapper).prepend(newNode);
          }
        };
        s.destroyLoop = function() {
          s.wrapper.children('.' + s.params.slideClass + '.' + s.params.slideDuplicateClass).remove();
          s.slides.removeAttr('data-swiper-slide-index');
        };
        s.fixLoop = function() {
          var newIndex;
          if (s.activeIndex < s.loopedSlides) {
            newIndex = s.slides.length - s.loopedSlides * 3 + s.activeIndex;
            newIndex = newIndex + s.loopedSlides;
            s.slideTo(newIndex, 0, false, true);
          } else if ((s.params.slidesPerView === 'auto' && s.activeIndex >= s.loopedSlides * 2) || (s.activeIndex > s.slides.length - s.params.slidesPerView * 2)) {
            newIndex = -s.slides.length + s.activeIndex + s.loopedSlides;
            newIndex = newIndex + s.loopedSlides;
            s.slideTo(newIndex, 0, false, true);
          }
        };
        s.appendSlide = function(slides) {
          if (s.params.loop) {
            s.destroyLoop();
          }
          if (typeof slides === 'object' && slides.length) {
            for (var i = 0; i < slides.length; i++) {
              if (slides[i])
                s.wrapper.append(slides[i]);
            }
          } else {
            s.wrapper.append(slides);
          }
          if (s.params.loop) {
            s.createLoop();
          }
          if (!(s.params.observer && s.support.observer)) {
            s.update(true);
          }
        };
        s.prependSlide = function(slides) {
          if (s.params.loop) {
            s.destroyLoop();
          }
          var newActiveIndex = s.activeIndex + 1;
          if (typeof slides === 'object' && slides.length) {
            for (var i = 0; i < slides.length; i++) {
              if (slides[i])
                s.wrapper.prepend(slides[i]);
            }
            newActiveIndex = s.activeIndex + slides.length;
          } else {
            s.wrapper.prepend(slides);
          }
          if (s.params.loop) {
            s.createLoop();
          }
          if (!(s.params.observer && s.support.observer)) {
            s.update(true);
          }
          s.slideTo(newActiveIndex, 0, false);
        };
        s.removeSlide = function(slidesIndexes) {
          if (s.params.loop) {
            s.destroyLoop();
            s.slides = s.wrapper.children('.' + s.params.slideClass);
          }
          var newActiveIndex = s.activeIndex,
              indexToRemove;
          if (typeof slidesIndexes === 'object' && slidesIndexes.length) {
            for (var i = 0; i < slidesIndexes.length; i++) {
              indexToRemove = slidesIndexes[i];
              if (s.slides[indexToRemove])
                s.slides.eq(indexToRemove).remove();
              if (indexToRemove < newActiveIndex)
                newActiveIndex--;
            }
            newActiveIndex = Math.max(newActiveIndex, 0);
          } else {
            indexToRemove = slidesIndexes;
            if (s.slides[indexToRemove])
              s.slides.eq(indexToRemove).remove();
            if (indexToRemove < newActiveIndex)
              newActiveIndex--;
            newActiveIndex = Math.max(newActiveIndex, 0);
          }
          if (s.params.loop) {
            s.createLoop();
          }
          if (!(s.params.observer && s.support.observer)) {
            s.update(true);
          }
          if (s.params.loop) {
            s.slideTo(newActiveIndex + s.loopedSlides, 0, false);
          } else {
            s.slideTo(newActiveIndex, 0, false);
          }
        };
        s.removeAllSlides = function() {
          var slidesIndexes = [];
          for (var i = 0; i < s.slides.length; i++) {
            slidesIndexes.push(i);
          }
          s.removeSlide(slidesIndexes);
        };
        s.effects = {
          fade: {
            setTranslate: function() {
              for (var i = 0; i < s.slides.length; i++) {
                var slide = s.slides.eq(i);
                var offset = slide[0].swiperSlideOffset;
                var tx = -offset;
                if (!s.params.virtualTranslate)
                  tx = tx - s.translate;
                var ty = 0;
                if (!isH()) {
                  ty = tx;
                  tx = 0;
                }
                var slideOpacity = s.params.fade.crossFade ? Math.max(1 - Math.abs(slide[0].progress), 0) : 1 + Math.min(Math.max(slide[0].progress, -1), 0);
                slide.css({opacity: slideOpacity}).transform('translate3d(' + tx + 'px, ' + ty + 'px, 0px)');
              }
            },
            setTransition: function(duration) {
              s.slides.transition(duration);
              if (s.params.virtualTranslate && duration !== 0) {
                var eventTriggered = false;
                s.slides.transitionEnd(function() {
                  if (eventTriggered)
                    return;
                  if (!s)
                    return;
                  eventTriggered = true;
                  s.animating = false;
                  var triggerEvents = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'];
                  for (var i = 0; i < triggerEvents.length; i++) {
                    s.wrapper.trigger(triggerEvents[i]);
                  }
                });
              }
            }
          },
          cube: {
            setTranslate: function() {
              var wrapperRotate = 0,
                  cubeShadow;
              if (s.params.cube.shadow) {
                if (isH()) {
                  cubeShadow = s.wrapper.find('.swiper-cube-shadow');
                  if (cubeShadow.length === 0) {
                    cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                    s.wrapper.append(cubeShadow);
                  }
                  cubeShadow.css({height: s.width + 'px'});
                } else {
                  cubeShadow = s.container.find('.swiper-cube-shadow');
                  if (cubeShadow.length === 0) {
                    cubeShadow = $('<div class="swiper-cube-shadow"></div>');
                    s.container.append(cubeShadow);
                  }
                }
              }
              for (var i = 0; i < s.slides.length; i++) {
                var slide = s.slides.eq(i);
                var slideAngle = i * 90;
                var round = Math.floor(slideAngle / 360);
                if (s.rtl) {
                  slideAngle = -slideAngle;
                  round = Math.floor(-slideAngle / 360);
                }
                var progress = Math.max(Math.min(slide[0].progress, 1), -1);
                var tx = 0,
                    ty = 0,
                    tz = 0;
                if (i % 4 === 0) {
                  tx = -round * 4 * s.size;
                  tz = 0;
                } else if ((i - 1) % 4 === 0) {
                  tx = 0;
                  tz = -round * 4 * s.size;
                } else if ((i - 2) % 4 === 0) {
                  tx = s.size + round * 4 * s.size;
                  tz = s.size;
                } else if ((i - 3) % 4 === 0) {
                  tx = -s.size;
                  tz = 3 * s.size + s.size * 4 * round;
                }
                if (s.rtl) {
                  tx = -tx;
                }
                if (!isH()) {
                  ty = tx;
                  tx = 0;
                }
                var transform = 'rotateX(' + (isH() ? 0 : -slideAngle) + 'deg) rotateY(' + (isH() ? slideAngle : 0) + 'deg) translate3d(' + tx + 'px, ' + ty + 'px, ' + tz + 'px)';
                if (progress <= 1 && progress > -1) {
                  wrapperRotate = i * 90 + progress * 90;
                  if (s.rtl)
                    wrapperRotate = -i * 90 - progress * 90;
                }
                slide.transform(transform);
                if (s.params.cube.slideShadows) {
                  var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                  var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                  if (shadowBefore.length === 0) {
                    shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
                    slide.append(shadowBefore);
                  }
                  if (shadowAfter.length === 0) {
                    shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
                    slide.append(shadowAfter);
                  }
                  var shadowOpacity = slide[0].progress;
                  if (shadowBefore.length)
                    shadowBefore[0].style.opacity = -slide[0].progress;
                  if (shadowAfter.length)
                    shadowAfter[0].style.opacity = slide[0].progress;
                }
              }
              s.wrapper.css({
                '-webkit-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                '-moz-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                '-ms-transform-origin': '50% 50% -' + (s.size / 2) + 'px',
                'transform-origin': '50% 50% -' + (s.size / 2) + 'px'
              });
              if (s.params.cube.shadow) {
                if (isH()) {
                  cubeShadow.transform('translate3d(0px, ' + (s.width / 2 + s.params.cube.shadowOffset) + 'px, ' + (-s.width / 2) + 'px) rotateX(90deg) rotateZ(0deg) scale(' + (s.params.cube.shadowScale) + ')');
                } else {
                  var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                  var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                  var scale1 = s.params.cube.shadowScale,
                      scale2 = s.params.cube.shadowScale / multiplier,
                      offset = s.params.cube.shadowOffset;
                  cubeShadow.transform('scale3d(' + scale1 + ', 1, ' + scale2 + ') translate3d(0px, ' + (s.height / 2 + offset) + 'px, ' + (-s.height / 2 / scale2) + 'px) rotateX(-90deg)');
                }
              }
              var zFactor = (s.isSafari || s.isUiWebView) ? (-s.size / 2) : 0;
              s.wrapper.transform('translate3d(0px,0,' + zFactor + 'px) rotateX(' + (isH() ? 0 : wrapperRotate) + 'deg) rotateY(' + (isH() ? -wrapperRotate : 0) + 'deg)');
            },
            setTransition: function(duration) {
              s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
              if (s.params.cube.shadow && !isH()) {
                s.container.find('.swiper-cube-shadow').transition(duration);
              }
            }
          },
          coverflow: {
            setTranslate: function() {
              var transform = s.translate;
              var center = isH() ? -transform + s.width / 2 : -transform + s.height / 2;
              var rotate = isH() ? s.params.coverflow.rotate : -s.params.coverflow.rotate;
              var translate = s.params.coverflow.depth;
              for (var i = 0,
                  length = s.slides.length; i < length; i++) {
                var slide = s.slides.eq(i);
                var slideSize = s.slidesSizesGrid[i];
                var slideOffset = slide[0].swiperSlideOffset;
                var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier;
                var rotateY = isH() ? rotate * offsetMultiplier : 0;
                var rotateX = isH() ? 0 : rotate * offsetMultiplier;
                var translateZ = -translate * Math.abs(offsetMultiplier);
                var translateY = isH() ? 0 : s.params.coverflow.stretch * (offsetMultiplier);
                var translateX = isH() ? s.params.coverflow.stretch * (offsetMultiplier) : 0;
                if (Math.abs(translateX) < 0.001)
                  translateX = 0;
                if (Math.abs(translateY) < 0.001)
                  translateY = 0;
                if (Math.abs(translateZ) < 0.001)
                  translateZ = 0;
                if (Math.abs(rotateY) < 0.001)
                  rotateY = 0;
                if (Math.abs(rotateX) < 0.001)
                  rotateX = 0;
                var slideTransform = 'translate3d(' + translateX + 'px,' + translateY + 'px,' + translateZ + 'px)  rotateX(' + rotateX + 'deg) rotateY(' + rotateY + 'deg)';
                slide.transform(slideTransform);
                slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
                if (s.params.coverflow.slideShadows) {
                  var shadowBefore = isH() ? slide.find('.swiper-slide-shadow-left') : slide.find('.swiper-slide-shadow-top');
                  var shadowAfter = isH() ? slide.find('.swiper-slide-shadow-right') : slide.find('.swiper-slide-shadow-bottom');
                  if (shadowBefore.length === 0) {
                    shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? 'left' : 'top') + '"></div>');
                    slide.append(shadowBefore);
                  }
                  if (shadowAfter.length === 0) {
                    shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? 'right' : 'bottom') + '"></div>');
                    slide.append(shadowAfter);
                  }
                  if (shadowBefore.length)
                    shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                  if (shadowAfter.length)
                    shadowAfter[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
                }
              }
              if (s.browser.ie) {
                var ws = s.wrapper[0].style;
                ws.perspectiveOrigin = center + 'px 50%';
              }
            },
            setTransition: function(duration) {
              s.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
            }
          }
        };
        s.lazy = {
          initialImageLoaded: false,
          loadImageInSlide: function(index, loadInDuplicate) {
            if (typeof index === 'undefined')
              return;
            if (typeof loadInDuplicate === 'undefined')
              loadInDuplicate = true;
            if (s.slides.length === 0)
              return;
            var slide = s.slides.eq(index);
            var img = slide.find('.swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)');
            if (slide.hasClass('swiper-lazy') && !slide.hasClass('swiper-lazy-loaded') && !slide.hasClass('swiper-lazy-loading')) {
              img = img.add(slide[0]);
            }
            if (img.length === 0)
              return;
            img.each(function() {
              var _img = $(this);
              _img.addClass('swiper-lazy-loading');
              var background = _img.attr('data-background');
              var src = _img.attr('data-src'),
                  srcset = _img.attr('data-srcset');
              s.loadImage(_img[0], (src || background), srcset, false, function() {
                if (background) {
                  _img.css('background-image', 'url(' + background + ')');
                  _img.removeAttr('data-background');
                } else {
                  if (srcset) {
                    _img.attr('srcset', srcset);
                    _img.removeAttr('data-srcset');
                  }
                  if (src) {
                    _img.attr('src', src);
                    _img.removeAttr('data-src');
                  }
                }
                _img.addClass('swiper-lazy-loaded').removeClass('swiper-lazy-loading');
                slide.find('.swiper-lazy-preloader, .preloader').remove();
                if (s.params.loop && loadInDuplicate) {
                  var slideOriginalIndex = slide.attr('data-swiper-slide-index');
                  if (slide.hasClass(s.params.slideDuplicateClass)) {
                    var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ')');
                    s.lazy.loadImageInSlide(originalSlide.index(), false);
                  } else {
                    var duplicatedSlide = s.wrapper.children('.' + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                    s.lazy.loadImageInSlide(duplicatedSlide.index(), false);
                  }
                }
                s.emit('onLazyImageReady', s, slide[0], _img[0]);
              });
              s.emit('onLazyImageLoad', s, slide[0], _img[0]);
            });
          },
          load: function() {
            var i;
            if (s.params.watchSlidesVisibility) {
              s.wrapper.children('.' + s.params.slideVisibleClass).each(function() {
                s.lazy.loadImageInSlide($(this).index());
              });
            } else {
              if (s.params.slidesPerView > 1) {
                for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView; i++) {
                  if (s.slides[i])
                    s.lazy.loadImageInSlide(i);
                }
              } else {
                s.lazy.loadImageInSlide(s.activeIndex);
              }
            }
            if (s.params.lazyLoadingInPrevNext) {
              if (s.params.slidesPerView > 1) {
                for (i = s.activeIndex + s.params.slidesPerView; i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView; i++) {
                  if (s.slides[i])
                    s.lazy.loadImageInSlide(i);
                }
                for (i = s.activeIndex - s.params.slidesPerView; i < s.activeIndex; i++) {
                  if (s.slides[i])
                    s.lazy.loadImageInSlide(i);
                }
              } else {
                var nextSlide = s.wrapper.children('.' + s.params.slideNextClass);
                if (nextSlide.length > 0)
                  s.lazy.loadImageInSlide(nextSlide.index());
                var prevSlide = s.wrapper.children('.' + s.params.slidePrevClass);
                if (prevSlide.length > 0)
                  s.lazy.loadImageInSlide(prevSlide.index());
              }
            }
          },
          onTransitionStart: function() {
            if (s.params.lazyLoading) {
              if (s.params.lazyLoadingOnTransitionStart || (!s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded)) {
                s.lazy.load();
              }
            }
          },
          onTransitionEnd: function() {
            if (s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart) {
              s.lazy.load();
            }
          }
        };
        s.scrollbar = {
          isTouched: false,
          setDragPosition: function(e) {
            var sb = s.scrollbar;
            var x = 0,
                y = 0;
            var translate;
            var pointerPosition = isH() ? ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX) : ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);
            var position = (pointerPosition) - sb.track.offset()[isH() ? 'left' : 'top'] - sb.dragSize / 2;
            var positionMin = -s.minTranslate() * sb.moveDivider;
            var positionMax = -s.maxTranslate() * sb.moveDivider;
            if (position < positionMin) {
              position = positionMin;
            } else if (position > positionMax) {
              position = positionMax;
            }
            position = -position / sb.moveDivider;
            s.updateProgress(position);
            s.setWrapperTranslate(position, true);
          },
          dragStart: function(e) {
            var sb = s.scrollbar;
            sb.isTouched = true;
            e.preventDefault();
            e.stopPropagation();
            sb.setDragPosition(e);
            clearTimeout(sb.dragTimeout);
            sb.track.transition(0);
            if (s.params.scrollbarHide) {
              sb.track.css('opacity', 1);
            }
            s.wrapper.transition(100);
            sb.drag.transition(100);
            s.emit('onScrollbarDragStart', s);
          },
          dragMove: function(e) {
            var sb = s.scrollbar;
            if (!sb.isTouched)
              return;
            if (e.preventDefault)
              e.preventDefault();
            else
              e.returnValue = false;
            sb.setDragPosition(e);
            s.wrapper.transition(0);
            sb.track.transition(0);
            sb.drag.transition(0);
            s.emit('onScrollbarDragMove', s);
          },
          dragEnd: function(e) {
            var sb = s.scrollbar;
            if (!sb.isTouched)
              return;
            sb.isTouched = false;
            if (s.params.scrollbarHide) {
              clearTimeout(sb.dragTimeout);
              sb.dragTimeout = setTimeout(function() {
                sb.track.css('opacity', 0);
                sb.track.transition(400);
              }, 1000);
            }
            s.emit('onScrollbarDragEnd', s);
            if (s.params.scrollbarSnapOnRelease) {
              s.slideReset();
            }
          },
          enableDraggable: function() {
            var sb = s.scrollbar;
            var target = s.support.touch ? sb.track : document;
            $(sb.track).on(s.touchEvents.start, sb.dragStart);
            $(target).on(s.touchEvents.move, sb.dragMove);
            $(target).on(s.touchEvents.end, sb.dragEnd);
          },
          disableDraggable: function() {
            var sb = s.scrollbar;
            var target = s.support.touch ? sb.track : document;
            $(sb.track).off(s.touchEvents.start, sb.dragStart);
            $(target).off(s.touchEvents.move, sb.dragMove);
            $(target).off(s.touchEvents.end, sb.dragEnd);
          },
          set: function() {
            if (!s.params.scrollbar)
              return;
            var sb = s.scrollbar;
            sb.track = $(s.params.scrollbar);
            sb.drag = sb.track.find('.swiper-scrollbar-drag');
            if (sb.drag.length === 0) {
              sb.drag = $('<div class="swiper-scrollbar-drag"></div>');
              sb.track.append(sb.drag);
            }
            sb.drag[0].style.width = '';
            sb.drag[0].style.height = '';
            sb.trackSize = isH() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight;
            sb.divider = s.size / s.virtualSize;
            sb.moveDivider = sb.divider * (sb.trackSize / s.size);
            sb.dragSize = sb.trackSize * sb.divider;
            if (isH()) {
              sb.drag[0].style.width = sb.dragSize + 'px';
            } else {
              sb.drag[0].style.height = sb.dragSize + 'px';
            }
            if (sb.divider >= 1) {
              sb.track[0].style.display = 'none';
            } else {
              sb.track[0].style.display = '';
            }
            if (s.params.scrollbarHide) {
              sb.track[0].style.opacity = 0;
            }
          },
          setTranslate: function() {
            if (!s.params.scrollbar)
              return;
            var diff;
            var sb = s.scrollbar;
            var translate = s.translate || 0;
            var newPos;
            var newSize = sb.dragSize;
            newPos = (sb.trackSize - sb.dragSize) * s.progress;
            if (s.rtl && isH()) {
              newPos = -newPos;
              if (newPos > 0) {
                newSize = sb.dragSize - newPos;
                newPos = 0;
              } else if (-newPos + sb.dragSize > sb.trackSize) {
                newSize = sb.trackSize + newPos;
              }
            } else {
              if (newPos < 0) {
                newSize = sb.dragSize + newPos;
                newPos = 0;
              } else if (newPos + sb.dragSize > sb.trackSize) {
                newSize = sb.trackSize - newPos;
              }
            }
            if (isH()) {
              if (s.support.transforms3d) {
                sb.drag.transform('translate3d(' + (newPos) + 'px, 0, 0)');
              } else {
                sb.drag.transform('translateX(' + (newPos) + 'px)');
              }
              sb.drag[0].style.width = newSize + 'px';
            } else {
              if (s.support.transforms3d) {
                sb.drag.transform('translate3d(0px, ' + (newPos) + 'px, 0)');
              } else {
                sb.drag.transform('translateY(' + (newPos) + 'px)');
              }
              sb.drag[0].style.height = newSize + 'px';
            }
            if (s.params.scrollbarHide) {
              clearTimeout(sb.timeout);
              sb.track[0].style.opacity = 1;
              sb.timeout = setTimeout(function() {
                sb.track[0].style.opacity = 0;
                sb.track.transition(400);
              }, 1000);
            }
          },
          setTransition: function(duration) {
            if (!s.params.scrollbar)
              return;
            s.scrollbar.drag.transition(duration);
          }
        };
        s.controller = {
          LinearSpline: function(x, y) {
            this.x = x;
            this.y = y;
            this.lastIndex = x.length - 1;
            var i1,
                i3;
            var l = this.x.length;
            this.interpolate = function(x2) {
              if (!x2)
                return 0;
              i3 = binarySearch(this.x, x2);
              i1 = i3 - 1;
              return ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1]) + this.y[i1];
            };
            var binarySearch = (function() {
              var maxIndex,
                  minIndex,
                  guess;
              return function(array, val) {
                minIndex = -1;
                maxIndex = array.length;
                while (maxIndex - minIndex > 1)
                  if (array[guess = maxIndex + minIndex >> 1] <= val) {
                    minIndex = guess;
                  } else {
                    maxIndex = guess;
                  }
                return maxIndex;
              };
            })();
          },
          getInterpolateFunction: function(c) {
            if (!s.controller.spline)
              s.controller.spline = s.params.loop ? new s.controller.LinearSpline(s.slidesGrid, c.slidesGrid) : new s.controller.LinearSpline(s.snapGrid, c.snapGrid);
          },
          setTranslate: function(translate, byController) {
            var controlled = s.params.control;
            var multiplier,
                controlledTranslate;
            function setControlledTranslate(c) {
              translate = c.rtl && c.params.direction === 'horizontal' ? -s.translate : s.translate;
              if (s.params.controlBy === 'slide') {
                s.controller.getInterpolateFunction(c);
                controlledTranslate = -s.controller.spline.interpolate(-translate);
              }
              if (!controlledTranslate || s.params.controlBy === 'container') {
                multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate());
                controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate();
              }
              if (s.params.controlInverse) {
                controlledTranslate = c.maxTranslate() - controlledTranslate;
              }
              c.updateProgress(controlledTranslate);
              c.setWrapperTranslate(controlledTranslate, false, s);
              c.updateActiveIndex();
            }
            if (s.isArray(controlled)) {
              for (var i = 0; i < controlled.length; i++) {
                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                  setControlledTranslate(controlled[i]);
                }
              }
            } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTranslate(controlled);
            }
          },
          setTransition: function(duration, byController) {
            var controlled = s.params.control;
            var i;
            function setControlledTransition(c) {
              c.setWrapperTransition(duration, s);
              if (duration !== 0) {
                c.onTransitionStart();
                c.wrapper.transitionEnd(function() {
                  if (!controlled)
                    return;
                  if (c.params.loop && s.params.controlBy === 'slide') {
                    c.fixLoop();
                  }
                  c.onTransitionEnd();
                });
              }
            }
            if (s.isArray(controlled)) {
              for (i = 0; i < controlled.length; i++) {
                if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
                  setControlledTransition(controlled[i]);
                }
              }
            } else if (controlled instanceof Swiper && byController !== controlled) {
              setControlledTransition(controlled);
            }
          }
        };
        s.hashnav = {
          init: function() {
            if (!s.params.hashnav)
              return;
            s.hashnav.initialized = true;
            var hash = document.location.hash.replace('#', '');
            if (!hash)
              return;
            var speed = 0;
            for (var i = 0,
                length = s.slides.length; i < length; i++) {
              var slide = s.slides.eq(i);
              var slideHash = slide.attr('data-hash');
              if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                var index = slide.index();
                s.slideTo(index, speed, s.params.runCallbacksOnInit, true);
              }
            }
          },
          setHash: function() {
            if (!s.hashnav.initialized || !s.params.hashnav)
              return;
            document.location.hash = s.slides.eq(s.activeIndex).attr('data-hash') || '';
          }
        };
        function handleKeyboard(e) {
          if (e.originalEvent)
            e = e.originalEvent;
          var kc = e.keyCode || e.charCode;
          if (!s.params.allowSwipeToNext && (isH() && kc === 39 || !isH() && kc === 40)) {
            return false;
          }
          if (!s.params.allowSwipeToPrev && (isH() && kc === 37 || !isH() && kc === 38)) {
            return false;
          }
          if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return;
          }
          if (document.activeElement && document.activeElement.nodeName && (document.activeElement.nodeName.toLowerCase() === 'input' || document.activeElement.nodeName.toLowerCase() === 'textarea')) {
            return;
          }
          if (kc === 37 || kc === 39 || kc === 38 || kc === 40) {
            var inView = false;
            if (s.container.parents('.swiper-slide').length > 0 && s.container.parents('.swiper-slide-active').length === 0) {
              return;
            }
            var windowScroll = {
              left: window.pageXOffset,
              top: window.pageYOffset
            };
            var windowWidth = window.innerWidth;
            var windowHeight = window.innerHeight;
            var swiperOffset = s.container.offset();
            if (s.rtl)
              swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft;
            var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + s.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + s.height], [swiperOffset.left + s.width, swiperOffset.top + s.height]];
            for (var i = 0; i < swiperCoord.length; i++) {
              var point = swiperCoord[i];
              if (point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight) {
                inView = true;
              }
            }
            if (!inView)
              return;
          }
          if (isH()) {
            if (kc === 37 || kc === 39) {
              if (e.preventDefault)
                e.preventDefault();
              else
                e.returnValue = false;
            }
            if ((kc === 39 && !s.rtl) || (kc === 37 && s.rtl))
              s.slideNext();
            if ((kc === 37 && !s.rtl) || (kc === 39 && s.rtl))
              s.slidePrev();
          } else {
            if (kc === 38 || kc === 40) {
              if (e.preventDefault)
                e.preventDefault();
              else
                e.returnValue = false;
            }
            if (kc === 40)
              s.slideNext();
            if (kc === 38)
              s.slidePrev();
          }
        }
        s.disableKeyboardControl = function() {
          s.params.keyboardControl = false;
          $(document).off('keydown', handleKeyboard);
        };
        s.enableKeyboardControl = function() {
          s.params.keyboardControl = true;
          $(document).on('keydown', handleKeyboard);
        };
        s.mousewheel = {
          event: false,
          lastScrollTime: (new window.Date()).getTime()
        };
        if (s.params.mousewheelControl) {
          try {
            new window.WheelEvent('wheel');
            s.mousewheel.event = 'wheel';
          } catch (e) {}
          if (!s.mousewheel.event && document.onmousewheel !== undefined) {
            s.mousewheel.event = 'mousewheel';
          }
          if (!s.mousewheel.event) {
            s.mousewheel.event = 'DOMMouseScroll';
          }
        }
        function handleMousewheel(e) {
          if (e.originalEvent)
            e = e.originalEvent;
          var we = s.mousewheel.event;
          var delta = 0;
          var rtlFactor = s.rtl ? -1 : 1;
          if (e.detail)
            delta = -e.detail;
          else if (we === 'mousewheel') {
            if (s.params.mousewheelForceToAxis) {
              if (isH()) {
                if (Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY))
                  delta = e.wheelDeltaX * rtlFactor;
                else
                  return;
              } else {
                if (Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX))
                  delta = e.wheelDeltaY;
                else
                  return;
              }
            } else {
              delta = Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY) ? -e.wheelDeltaX * rtlFactor : -e.wheelDeltaY;
            }
          } else if (we === 'DOMMouseScroll')
            delta = -e.detail;
          else if (we === 'wheel') {
            if (s.params.mousewheelForceToAxis) {
              if (isH()) {
                if (Math.abs(e.deltaX) > Math.abs(e.deltaY))
                  delta = -e.deltaX * rtlFactor;
                else
                  return;
              } else {
                if (Math.abs(e.deltaY) > Math.abs(e.deltaX))
                  delta = -e.deltaY;
                else
                  return;
              }
            } else {
              delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? -e.deltaX * rtlFactor : -e.deltaY;
            }
          }
          if (delta === 0)
            return;
          if (s.params.mousewheelInvert)
            delta = -delta;
          if (!s.params.freeMode) {
            if ((new window.Date()).getTime() - s.mousewheel.lastScrollTime > 60) {
              if (delta < 0) {
                if ((!s.isEnd || s.params.loop) && !s.animating)
                  s.slideNext();
                else if (s.params.mousewheelReleaseOnEdges)
                  return true;
              } else {
                if ((!s.isBeginning || s.params.loop) && !s.animating)
                  s.slidePrev();
                else if (s.params.mousewheelReleaseOnEdges)
                  return true;
              }
            }
            s.mousewheel.lastScrollTime = (new window.Date()).getTime();
          } else {
            var position = s.getWrapperTranslate() + delta * s.params.mousewheelSensitivity;
            var wasBeginning = s.isBeginning,
                wasEnd = s.isEnd;
            if (position >= s.minTranslate())
              position = s.minTranslate();
            if (position <= s.maxTranslate())
              position = s.maxTranslate();
            s.setWrapperTransition(0);
            s.setWrapperTranslate(position);
            s.updateProgress();
            s.updateActiveIndex();
            if (!wasBeginning && s.isBeginning || !wasEnd && s.isEnd) {
              s.updateClasses();
            }
            if (s.params.freeModeSticky) {
              clearTimeout(s.mousewheel.timeout);
              s.mousewheel.timeout = setTimeout(function() {
                s.slideReset();
              }, 300);
            }
            if (position === 0 || position === s.maxTranslate())
              return;
          }
          if (s.params.autoplay)
            s.stopAutoplay();
          if (e.preventDefault)
            e.preventDefault();
          else
            e.returnValue = false;
          return false;
        }
        s.disableMousewheelControl = function() {
          if (!s.mousewheel.event)
            return false;
          s.container.off(s.mousewheel.event, handleMousewheel);
          return true;
        };
        s.enableMousewheelControl = function() {
          if (!s.mousewheel.event)
            return false;
          s.container.on(s.mousewheel.event, handleMousewheel);
          return true;
        };
        function setParallaxTransform(el, progress) {
          el = $(el);
          var p,
              pX,
              pY;
          var rtlFactor = s.rtl ? -1 : 1;
          p = el.attr('data-swiper-parallax') || '0';
          pX = el.attr('data-swiper-parallax-x');
          pY = el.attr('data-swiper-parallax-y');
          if (pX || pY) {
            pX = pX || '0';
            pY = pY || '0';
          } else {
            if (isH()) {
              pX = p;
              pY = '0';
            } else {
              pY = p;
              pX = '0';
            }
          }
          if ((pX).indexOf('%') >= 0) {
            pX = parseInt(pX, 10) * progress * rtlFactor + '%';
          } else {
            pX = pX * progress * rtlFactor + 'px';
          }
          if ((pY).indexOf('%') >= 0) {
            pY = parseInt(pY, 10) * progress + '%';
          } else {
            pY = pY * progress + 'px';
          }
          el.transform('translate3d(' + pX + ', ' + pY + ',0px)');
        }
        s.parallax = {
          setTranslate: function() {
            s.container.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function() {
              setParallaxTransform(this, s.progress);
            });
            s.slides.each(function() {
              var slide = $(this);
              slide.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function() {
                var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                setParallaxTransform(this, progress);
              });
            });
          },
          setTransition: function(duration) {
            if (typeof duration === 'undefined')
              duration = s.params.speed;
            s.container.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]').each(function() {
              var el = $(this);
              var parallaxDuration = parseInt(el.attr('data-swiper-parallax-duration'), 10) || duration;
              if (duration === 0)
                parallaxDuration = 0;
              el.transition(parallaxDuration);
            });
          }
        };
        s._plugins = [];
        for (var plugin in s.plugins) {
          var p = s.plugins[plugin](s, s.params[plugin]);
          if (p)
            s._plugins.push(p);
        }
        s.callPlugins = function(eventName) {
          for (var i = 0; i < s._plugins.length; i++) {
            if (eventName in s._plugins[i]) {
              s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
          }
        };
        function normalizeEventName(eventName) {
          if (eventName.indexOf('on') !== 0) {
            if (eventName[0] !== eventName[0].toUpperCase()) {
              eventName = 'on' + eventName[0].toUpperCase() + eventName.substring(1);
            } else {
              eventName = 'on' + eventName;
            }
          }
          return eventName;
        }
        s.emitterEventListeners = {};
        s.emit = function(eventName) {
          if (s.params[eventName]) {
            s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
          }
          var i;
          if (s.emitterEventListeners[eventName]) {
            for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
              s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            }
          }
          if (s.callPlugins)
            s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
        };
        s.on = function(eventName, handler) {
          eventName = normalizeEventName(eventName);
          if (!s.emitterEventListeners[eventName])
            s.emitterEventListeners[eventName] = [];
          s.emitterEventListeners[eventName].push(handler);
          return s;
        };
        s.off = function(eventName, handler) {
          var i;
          eventName = normalizeEventName(eventName);
          if (typeof handler === 'undefined') {
            s.emitterEventListeners[eventName] = [];
            return s;
          }
          if (!s.emitterEventListeners[eventName] || s.emitterEventListeners[eventName].length === 0)
            return;
          for (i = 0; i < s.emitterEventListeners[eventName].length; i++) {
            if (s.emitterEventListeners[eventName][i] === handler)
              s.emitterEventListeners[eventName].splice(i, 1);
          }
          return s;
        };
        s.once = function(eventName, handler) {
          eventName = normalizeEventName(eventName);
          var _handler = function() {
            handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
            s.off(eventName, _handler);
          };
          s.on(eventName, _handler);
          return s;
        };
        s.a11y = {
          makeFocusable: function($el) {
            $el.attr('tabIndex', '0');
            return $el;
          },
          addRole: function($el, role) {
            $el.attr('role', role);
            return $el;
          },
          addLabel: function($el, label) {
            $el.attr('aria-label', label);
            return $el;
          },
          disable: function($el) {
            $el.attr('aria-disabled', true);
            return $el;
          },
          enable: function($el) {
            $el.attr('aria-disabled', false);
            return $el;
          },
          onEnterKey: function(event) {
            if (event.keyCode !== 13)
              return;
            if ($(event.target).is(s.params.nextButton)) {
              s.onClickNext(event);
              if (s.isEnd) {
                s.a11y.notify(s.params.lastSlideMessage);
              } else {
                s.a11y.notify(s.params.nextSlideMessage);
              }
            } else if ($(event.target).is(s.params.prevButton)) {
              s.onClickPrev(event);
              if (s.isBeginning) {
                s.a11y.notify(s.params.firstSlideMessage);
              } else {
                s.a11y.notify(s.params.prevSlideMessage);
              }
            }
            if ($(event.target).is('.' + s.params.bulletClass)) {
              $(event.target)[0].click();
            }
          },
          liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),
          notify: function(message) {
            var notification = s.a11y.liveRegion;
            if (notification.length === 0)
              return;
            notification.html('');
            notification.html(message);
          },
          init: function() {
            if (s.params.nextButton) {
              var nextButton = $(s.params.nextButton);
              s.a11y.makeFocusable(nextButton);
              s.a11y.addRole(nextButton, 'button');
              s.a11y.addLabel(nextButton, s.params.nextSlideMessage);
            }
            if (s.params.prevButton) {
              var prevButton = $(s.params.prevButton);
              s.a11y.makeFocusable(prevButton);
              s.a11y.addRole(prevButton, 'button');
              s.a11y.addLabel(prevButton, s.params.prevSlideMessage);
            }
            $(s.container).append(s.a11y.liveRegion);
          },
          initPagination: function() {
            if (s.params.pagination && s.params.paginationClickable && s.bullets && s.bullets.length) {
              s.bullets.each(function() {
                var bullet = $(this);
                s.a11y.makeFocusable(bullet);
                s.a11y.addRole(bullet, 'button');
                s.a11y.addLabel(bullet, s.params.paginationBulletMessage.replace(/{{index}}/, bullet.index() + 1));
              });
            }
          },
          destroy: function() {
            if (s.a11y.liveRegion && s.a11y.liveRegion.length > 0)
              s.a11y.liveRegion.remove();
          }
        };
        s.init = function() {
          if (s.params.loop)
            s.createLoop();
          s.updateContainerSize();
          s.updateSlidesSize();
          s.updatePagination();
          if (s.params.scrollbar && s.scrollbar) {
            s.scrollbar.set();
            if (s.params.scrollbarDraggable) {
              s.scrollbar.enableDraggable();
            }
          }
          if (s.params.effect !== 'slide' && s.effects[s.params.effect]) {
            if (!s.params.loop)
              s.updateProgress();
            s.effects[s.params.effect].setTranslate();
          }
          if (s.params.loop) {
            s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit);
          } else {
            s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit);
            if (s.params.initialSlide === 0) {
              if (s.parallax && s.params.parallax)
                s.parallax.setTranslate();
              if (s.lazy && s.params.lazyLoading) {
                s.lazy.load();
                s.lazy.initialImageLoaded = true;
              }
            }
          }
          s.attachEvents();
          if (s.params.observer && s.support.observer) {
            s.initObservers();
          }
          if (s.params.preloadImages && !s.params.lazyLoading) {
            s.preloadImages();
          }
          if (s.params.autoplay) {
            s.startAutoplay();
          }
          if (s.params.keyboardControl) {
            if (s.enableKeyboardControl)
              s.enableKeyboardControl();
          }
          if (s.params.mousewheelControl) {
            if (s.enableMousewheelControl)
              s.enableMousewheelControl();
          }
          if (s.params.hashnav) {
            if (s.hashnav)
              s.hashnav.init();
          }
          if (s.params.a11y && s.a11y)
            s.a11y.init();
          s.emit('onInit', s);
        };
        s.cleanupStyles = function() {
          s.container.removeClass(s.classNames.join(' ')).removeAttr('style');
          s.wrapper.removeAttr('style');
          if (s.slides && s.slides.length) {
            s.slides.removeClass([s.params.slideVisibleClass, s.params.slideActiveClass, s.params.slideNextClass, s.params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-column').removeAttr('data-swiper-row');
          }
          if (s.paginationContainer && s.paginationContainer.length) {
            s.paginationContainer.removeClass(s.params.paginationHiddenClass);
          }
          if (s.bullets && s.bullets.length) {
            s.bullets.removeClass(s.params.bulletActiveClass);
          }
          if (s.params.prevButton)
            $(s.params.prevButton).removeClass(s.params.buttonDisabledClass);
          if (s.params.nextButton)
            $(s.params.nextButton).removeClass(s.params.buttonDisabledClass);
          if (s.params.scrollbar && s.scrollbar) {
            if (s.scrollbar.track && s.scrollbar.track.length)
              s.scrollbar.track.removeAttr('style');
            if (s.scrollbar.drag && s.scrollbar.drag.length)
              s.scrollbar.drag.removeAttr('style');
          }
        };
        s.destroy = function(deleteInstance, cleanupStyles) {
          s.detachEvents();
          s.stopAutoplay();
          if (s.params.scrollbar && s.scrollbar) {
            if (s.params.scrollbarDraggable) {
              s.scrollbar.disableDraggable();
            }
          }
          if (s.params.loop) {
            s.destroyLoop();
          }
          if (cleanupStyles) {
            s.cleanupStyles();
          }
          s.disconnectObservers();
          if (s.params.keyboardControl) {
            if (s.disableKeyboardControl)
              s.disableKeyboardControl();
          }
          if (s.params.mousewheelControl) {
            if (s.disableMousewheelControl)
              s.disableMousewheelControl();
          }
          if (s.params.a11y && s.a11y)
            s.a11y.destroy();
          s.emit('onDestroy');
          if (deleteInstance !== false)
            s = null;
        };
        s.init();
        return s;
      };
      Swiper.prototype = {
        isSafari: (function() {
          var ua = navigator.userAgent.toLowerCase();
          return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
        })(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
        isArray: function(arr) {
          return Object.prototype.toString.apply(arr) === '[object Array]';
        },
        browser: {
          ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
          ieTouch: (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1) || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1)
        },
        device: (function() {
          var ua = navigator.userAgent;
          var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
          var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
          var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
          var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
          return {
            ios: ipad || iphone || ipod,
            android: android
          };
        })(),
        support: {
          touch: (window.Modernizr && Modernizr.touch === true) || (function() {
            return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
          })(),
          transforms3d: (window.Modernizr && Modernizr.csstransforms3d === true) || (function() {
            var div = document.createElement('div').style;
            return ('webkitPerspective' in div || 'MozPerspective' in div || 'OPerspective' in div || 'MsPerspective' in div || 'perspective' in div);
          })(),
          flexbox: (function() {
            var div = document.createElement('div').style;
            var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');
            for (var i = 0; i < styles.length; i++) {
              if (styles[i] in div)
                return true;
            }
          })(),
          observer: (function() {
            return ('MutationObserver' in window || 'WebkitMutationObserver' in window);
          })()
        },
        plugins: {}
      };
      var Dom7 = (function() {
        var Dom7 = function(arr) {
          var _this = this,
              i = 0;
          for (i = 0; i < arr.length; i++) {
            _this[i] = arr[i];
          }
          _this.length = arr.length;
          return this;
        };
        var $ = function(selector, context) {
          var arr = [],
              i = 0;
          if (selector && !context) {
            if (selector instanceof Dom7) {
              return selector;
            }
          }
          if (selector) {
            if (typeof selector === 'string') {
              var els,
                  tempParent,
                  html = selector.trim();
              if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
                var toCreate = 'div';
                if (html.indexOf('<li') === 0)
                  toCreate = 'ul';
                if (html.indexOf('<tr') === 0)
                  toCreate = 'tbody';
                if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0)
                  toCreate = 'tr';
                if (html.indexOf('<tbody') === 0)
                  toCreate = 'table';
                if (html.indexOf('<option') === 0)
                  toCreate = 'select';
                tempParent = document.createElement(toCreate);
                tempParent.innerHTML = selector;
                for (i = 0; i < tempParent.childNodes.length; i++) {
                  arr.push(tempParent.childNodes[i]);
                }
              } else {
                if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
                  els = [document.getElementById(selector.split('#')[1])];
                } else {
                  els = (context || document).querySelectorAll(selector);
                }
                for (i = 0; i < els.length; i++) {
                  if (els[i])
                    arr.push(els[i]);
                }
              }
            } else if (selector.nodeType || selector === window || selector === document) {
              arr.push(selector);
            } else if (selector.length > 0 && selector[0].nodeType) {
              for (i = 0; i < selector.length; i++) {
                arr.push(selector[i]);
              }
            }
          }
          return new Dom7(arr);
        };
        Dom7.prototype = {
          addClass: function(className) {
            if (typeof className === 'undefined') {
              return this;
            }
            var classes = className.split(' ');
            for (var i = 0; i < classes.length; i++) {
              for (var j = 0; j < this.length; j++) {
                this[j].classList.add(classes[i]);
              }
            }
            return this;
          },
          removeClass: function(className) {
            var classes = className.split(' ');
            for (var i = 0; i < classes.length; i++) {
              for (var j = 0; j < this.length; j++) {
                this[j].classList.remove(classes[i]);
              }
            }
            return this;
          },
          hasClass: function(className) {
            if (!this[0])
              return false;
            else
              return this[0].classList.contains(className);
          },
          toggleClass: function(className) {
            var classes = className.split(' ');
            for (var i = 0; i < classes.length; i++) {
              for (var j = 0; j < this.length; j++) {
                this[j].classList.toggle(classes[i]);
              }
            }
            return this;
          },
          attr: function(attrs, value) {
            if (arguments.length === 1 && typeof attrs === 'string') {
              if (this[0])
                return this[0].getAttribute(attrs);
              else
                return undefined;
            } else {
              for (var i = 0; i < this.length; i++) {
                if (arguments.length === 2) {
                  this[i].setAttribute(attrs, value);
                } else {
                  for (var attrName in attrs) {
                    this[i][attrName] = attrs[attrName];
                    this[i].setAttribute(attrName, attrs[attrName]);
                  }
                }
              }
              return this;
            }
          },
          removeAttr: function(attr) {
            for (var i = 0; i < this.length; i++) {
              this[i].removeAttribute(attr);
            }
            return this;
          },
          data: function(key, value) {
            if (typeof value === 'undefined') {
              if (this[0]) {
                var dataKey = this[0].getAttribute('data-' + key);
                if (dataKey)
                  return dataKey;
                else if (this[0].dom7ElementDataStorage && (key in this[0].dom7ElementDataStorage))
                  return this[0].dom7ElementDataStorage[key];
                else
                  return undefined;
              } else
                return undefined;
            } else {
              for (var i = 0; i < this.length; i++) {
                var el = this[i];
                if (!el.dom7ElementDataStorage)
                  el.dom7ElementDataStorage = {};
                el.dom7ElementDataStorage[key] = value;
              }
              return this;
            }
          },
          transform: function(transform) {
            for (var i = 0; i < this.length; i++) {
              var elStyle = this[i].style;
              elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
            }
            return this;
          },
          transition: function(duration) {
            if (typeof duration !== 'string') {
              duration = duration + 'ms';
            }
            for (var i = 0; i < this.length; i++) {
              var elStyle = this[i].style;
              elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
            }
            return this;
          },
          on: function(eventName, targetSelector, listener, capture) {
            function handleLiveEvent(e) {
              var target = e.target;
              if ($(target).is(targetSelector))
                listener.call(target, e);
              else {
                var parents = $(target).parents();
                for (var k = 0; k < parents.length; k++) {
                  if ($(parents[k]).is(targetSelector))
                    listener.call(parents[k], e);
                }
              }
            }
            var events = eventName.split(' ');
            var i,
                j;
            for (i = 0; i < this.length; i++) {
              if (typeof targetSelector === 'function' || targetSelector === false) {
                if (typeof targetSelector === 'function') {
                  listener = arguments[1];
                  capture = arguments[2] || false;
                }
                for (j = 0; j < events.length; j++) {
                  this[i].addEventListener(events[j], listener, capture);
                }
              } else {
                for (j = 0; j < events.length; j++) {
                  if (!this[i].dom7LiveListeners)
                    this[i].dom7LiveListeners = [];
                  this[i].dom7LiveListeners.push({
                    listener: listener,
                    liveListener: handleLiveEvent
                  });
                  this[i].addEventListener(events[j], handleLiveEvent, capture);
                }
              }
            }
            return this;
          },
          off: function(eventName, targetSelector, listener, capture) {
            var events = eventName.split(' ');
            for (var i = 0; i < events.length; i++) {
              for (var j = 0; j < this.length; j++) {
                if (typeof targetSelector === 'function' || targetSelector === false) {
                  if (typeof targetSelector === 'function') {
                    listener = arguments[1];
                    capture = arguments[2] || false;
                  }
                  this[j].removeEventListener(events[i], listener, capture);
                } else {
                  if (this[j].dom7LiveListeners) {
                    for (var k = 0; k < this[j].dom7LiveListeners.length; k++) {
                      if (this[j].dom7LiveListeners[k].listener === listener) {
                        this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                      }
                    }
                  }
                }
              }
            }
            return this;
          },
          once: function(eventName, targetSelector, listener, capture) {
            var dom = this;
            if (typeof targetSelector === 'function') {
              targetSelector = false;
              listener = arguments[1];
              capture = arguments[2];
            }
            function proxy(e) {
              listener(e);
              dom.off(eventName, targetSelector, proxy, capture);
            }
            dom.on(eventName, targetSelector, proxy, capture);
          },
          trigger: function(eventName, eventData) {
            for (var i = 0; i < this.length; i++) {
              var evt;
              try {
                evt = new window.CustomEvent(eventName, {
                  detail: eventData,
                  bubbles: true,
                  cancelable: true
                });
              } catch (e) {
                evt = document.createEvent('Event');
                evt.initEvent(eventName, true, true);
                evt.detail = eventData;
              }
              this[i].dispatchEvent(evt);
            }
            return this;
          },
          transitionEnd: function(callback) {
            var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                i,
                j,
                dom = this;
            function fireCallBack(e) {
              if (e.target !== this)
                return;
              callback.call(this, e);
              for (i = 0; i < events.length; i++) {
                dom.off(events[i], fireCallBack);
              }
            }
            if (callback) {
              for (i = 0; i < events.length; i++) {
                dom.on(events[i], fireCallBack);
              }
            }
            return this;
          },
          width: function() {
            if (this[0] === window) {
              return window.innerWidth;
            } else {
              if (this.length > 0) {
                return parseFloat(this.css('width'));
              } else {
                return null;
              }
            }
          },
          outerWidth: function(includeMargins) {
            if (this.length > 0) {
              if (includeMargins)
                return this[0].offsetWidth + parseFloat(this.css('margin-right')) + parseFloat(this.css('margin-left'));
              else
                return this[0].offsetWidth;
            } else
              return null;
          },
          height: function() {
            if (this[0] === window) {
              return window.innerHeight;
            } else {
              if (this.length > 0) {
                return parseFloat(this.css('height'));
              } else {
                return null;
              }
            }
          },
          outerHeight: function(includeMargins) {
            if (this.length > 0) {
              if (includeMargins)
                return this[0].offsetHeight + parseFloat(this.css('margin-top')) + parseFloat(this.css('margin-bottom'));
              else
                return this[0].offsetHeight;
            } else
              return null;
          },
          offset: function() {
            if (this.length > 0) {
              var el = this[0];
              var box = el.getBoundingClientRect();
              var body = document.body;
              var clientTop = el.clientTop || body.clientTop || 0;
              var clientLeft = el.clientLeft || body.clientLeft || 0;
              var scrollTop = window.pageYOffset || el.scrollTop;
              var scrollLeft = window.pageXOffset || el.scrollLeft;
              return {
                top: box.top + scrollTop - clientTop,
                left: box.left + scrollLeft - clientLeft
              };
            } else {
              return null;
            }
          },
          css: function(props, value) {
            var i;
            if (arguments.length === 1) {
              if (typeof props === 'string') {
                if (this[0])
                  return window.getComputedStyle(this[0], null).getPropertyValue(props);
              } else {
                for (i = 0; i < this.length; i++) {
                  for (var prop in props) {
                    this[i].style[prop] = props[prop];
                  }
                }
                return this;
              }
            }
            if (arguments.length === 2 && typeof props === 'string') {
              for (i = 0; i < this.length; i++) {
                this[i].style[props] = value;
              }
              return this;
            }
            return this;
          },
          each: function(callback) {
            for (var i = 0; i < this.length; i++) {
              callback.call(this[i], i, this[i]);
            }
            return this;
          },
          html: function(html) {
            if (typeof html === 'undefined') {
              return this[0] ? this[0].innerHTML : undefined;
            } else {
              for (var i = 0; i < this.length; i++) {
                this[i].innerHTML = html;
              }
              return this;
            }
          },
          is: function(selector) {
            if (!this[0])
              return false;
            var compareWith,
                i;
            if (typeof selector === 'string') {
              var el = this[0];
              if (el === document)
                return selector === document;
              if (el === window)
                return selector === window;
              if (el.matches)
                return el.matches(selector);
              else if (el.webkitMatchesSelector)
                return el.webkitMatchesSelector(selector);
              else if (el.mozMatchesSelector)
                return el.mozMatchesSelector(selector);
              else if (el.msMatchesSelector)
                return el.msMatchesSelector(selector);
              else {
                compareWith = $(selector);
                for (i = 0; i < compareWith.length; i++) {
                  if (compareWith[i] === this[0])
                    return true;
                }
                return false;
              }
            } else if (selector === document)
              return this[0] === document;
            else if (selector === window)
              return this[0] === window;
            else {
              if (selector.nodeType || selector instanceof Dom7) {
                compareWith = selector.nodeType ? [selector] : selector;
                for (i = 0; i < compareWith.length; i++) {
                  if (compareWith[i] === this[0])
                    return true;
                }
                return false;
              }
              return false;
            }
          },
          index: function() {
            if (this[0]) {
              var child = this[0];
              var i = 0;
              while ((child = child.previousSibling) !== null) {
                if (child.nodeType === 1)
                  i++;
              }
              return i;
            } else
              return undefined;
          },
          eq: function(index) {
            if (typeof index === 'undefined')
              return this;
            var length = this.length;
            var returnIndex;
            if (index > length - 1) {
              return new Dom7([]);
            }
            if (index < 0) {
              returnIndex = length + index;
              if (returnIndex < 0)
                return new Dom7([]);
              else
                return new Dom7([this[returnIndex]]);
            }
            return new Dom7([this[index]]);
          },
          append: function(newChild) {
            var i,
                j;
            for (i = 0; i < this.length; i++) {
              if (typeof newChild === 'string') {
                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = newChild;
                while (tempDiv.firstChild) {
                  this[i].appendChild(tempDiv.firstChild);
                }
              } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j++) {
                  this[i].appendChild(newChild[j]);
                }
              } else {
                this[i].appendChild(newChild);
              }
            }
            return this;
          },
          prepend: function(newChild) {
            var i,
                j;
            for (i = 0; i < this.length; i++) {
              if (typeof newChild === 'string') {
                var tempDiv = document.createElement('div');
                tempDiv.innerHTML = newChild;
                for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {
                  this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
                }
              } else if (newChild instanceof Dom7) {
                for (j = 0; j < newChild.length; j++) {
                  this[i].insertBefore(newChild[j], this[i].childNodes[0]);
                }
              } else {
                this[i].insertBefore(newChild, this[i].childNodes[0]);
              }
            }
            return this;
          },
          insertBefore: function(selector) {
            var before = $(selector);
            for (var i = 0; i < this.length; i++) {
              if (before.length === 1) {
                before[0].parentNode.insertBefore(this[i], before[0]);
              } else if (before.length > 1) {
                for (var j = 0; j < before.length; j++) {
                  before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
                }
              }
            }
          },
          insertAfter: function(selector) {
            var after = $(selector);
            for (var i = 0; i < this.length; i++) {
              if (after.length === 1) {
                after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
              } else if (after.length > 1) {
                for (var j = 0; j < after.length; j++) {
                  after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
                }
              }
            }
          },
          next: function(selector) {
            if (this.length > 0) {
              if (selector) {
                if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector))
                  return new Dom7([this[0].nextElementSibling]);
                else
                  return new Dom7([]);
              } else {
                if (this[0].nextElementSibling)
                  return new Dom7([this[0].nextElementSibling]);
                else
                  return new Dom7([]);
              }
            } else
              return new Dom7([]);
          },
          nextAll: function(selector) {
            var nextEls = [];
            var el = this[0];
            if (!el)
              return new Dom7([]);
            while (el.nextElementSibling) {
              var next = el.nextElementSibling;
              if (selector) {
                if ($(next).is(selector))
                  nextEls.push(next);
              } else
                nextEls.push(next);
              el = next;
            }
            return new Dom7(nextEls);
          },
          prev: function(selector) {
            if (this.length > 0) {
              if (selector) {
                if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector))
                  return new Dom7([this[0].previousElementSibling]);
                else
                  return new Dom7([]);
              } else {
                if (this[0].previousElementSibling)
                  return new Dom7([this[0].previousElementSibling]);
                else
                  return new Dom7([]);
              }
            } else
              return new Dom7([]);
          },
          prevAll: function(selector) {
            var prevEls = [];
            var el = this[0];
            if (!el)
              return new Dom7([]);
            while (el.previousElementSibling) {
              var prev = el.previousElementSibling;
              if (selector) {
                if ($(prev).is(selector))
                  prevEls.push(prev);
              } else
                prevEls.push(prev);
              el = prev;
            }
            return new Dom7(prevEls);
          },
          parent: function(selector) {
            var parents = [];
            for (var i = 0; i < this.length; i++) {
              if (selector) {
                if ($(this[i].parentNode).is(selector))
                  parents.push(this[i].parentNode);
              } else {
                parents.push(this[i].parentNode);
              }
            }
            return $($.unique(parents));
          },
          parents: function(selector) {
            var parents = [];
            for (var i = 0; i < this.length; i++) {
              var parent = this[i].parentNode;
              while (parent) {
                if (selector) {
                  if ($(parent).is(selector))
                    parents.push(parent);
                } else {
                  parents.push(parent);
                }
                parent = parent.parentNode;
              }
            }
            return $($.unique(parents));
          },
          find: function(selector) {
            var foundElements = [];
            for (var i = 0; i < this.length; i++) {
              var found = this[i].querySelectorAll(selector);
              for (var j = 0; j < found.length; j++) {
                foundElements.push(found[j]);
              }
            }
            return new Dom7(foundElements);
          },
          children: function(selector) {
            var children = [];
            for (var i = 0; i < this.length; i++) {
              var childNodes = this[i].childNodes;
              for (var j = 0; j < childNodes.length; j++) {
                if (!selector) {
                  if (childNodes[j].nodeType === 1)
                    children.push(childNodes[j]);
                } else {
                  if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector))
                    children.push(childNodes[j]);
                }
              }
            }
            return new Dom7($.unique(children));
          },
          remove: function() {
            for (var i = 0; i < this.length; i++) {
              if (this[i].parentNode)
                this[i].parentNode.removeChild(this[i]);
            }
            return this;
          },
          add: function() {
            var dom = this;
            var i,
                j;
            for (i = 0; i < arguments.length; i++) {
              var toAdd = $(arguments[i]);
              for (j = 0; j < toAdd.length; j++) {
                dom[dom.length] = toAdd[j];
                dom.length++;
              }
            }
            return dom;
          }
        };
        $.fn = Dom7.prototype;
        $.unique = function(arr) {
          var unique = [];
          for (var i = 0; i < arr.length; i++) {
            if (unique.indexOf(arr[i]) === -1)
              unique.push(arr[i]);
          }
          return unique;
        };
        return $;
      })();
      var swiperDomPlugins = ['jQuery', 'Zepto', 'Dom7'];
      for (var i = 0; i < swiperDomPlugins.length; i++) {
        if (window[swiperDomPlugins[i]]) {
          addLibraryPlugin(window[swiperDomPlugins[i]]);
        }
      }
      var domLib;
      if (typeof Dom7 === 'undefined') {
        domLib = window.Dom7 || window.Zepto || window.jQuery;
      } else {
        domLib = Dom7;
      }
      function addLibraryPlugin(lib) {
        lib.fn.swiper = function(params) {
          var firstInstance;
          lib(this).each(function() {
            var s = new Swiper(this, params);
            if (!firstInstance)
              firstInstance = s;
          });
          return firstInstance;
        };
      }
      if (domLib) {
        if (!('transitionEnd' in domLib.fn)) {
          domLib.fn.transitionEnd = function(callback) {
            var events = ['webkitTransitionEnd', 'transitionend', 'oTransitionEnd', 'MSTransitionEnd', 'msTransitionEnd'],
                i,
                j,
                dom = this;
            function fireCallBack(e) {
              if (e.target !== this)
                return;
              callback.call(this, e);
              for (i = 0; i < events.length; i++) {
                dom.off(events[i], fireCallBack);
              }
            }
            if (callback) {
              for (i = 0; i < events.length; i++) {
                dom.on(events[i], fireCallBack);
              }
            }
            return this;
          };
        }
        if (!('transform' in domLib.fn)) {
          domLib.fn.transform = function(transform) {
            for (var i = 0; i < this.length; i++) {
              var elStyle = this[i].style;
              elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform;
            }
            return this;
          };
        }
        if (!('transition' in domLib.fn)) {
          domLib.fn.transition = function(duration) {
            if (typeof duration !== 'string') {
              duration = duration + 'ms';
            }
            for (var i = 0; i < this.length; i++) {
              var elStyle = this[i].style;
              elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration;
            }
            return this;
          };
        }
      }
      ionic.views.Swiper = Swiper;
    })();
    (function(ionic) {
      'use strict';
      ionic.views.Toggle = ionic.views.View.inherit({
        initialize: function(opts) {
          var self = this;
          this.el = opts.el;
          this.checkbox = opts.checkbox;
          this.track = opts.track;
          this.handle = opts.handle;
          this.openPercent = -1;
          this.onChange = opts.onChange || function() {};
          this.triggerThreshold = opts.triggerThreshold || 20;
          this.dragStartHandler = function(e) {
            self.dragStart(e);
          };
          this.dragHandler = function(e) {
            self.drag(e);
          };
          this.holdHandler = function(e) {
            self.hold(e);
          };
          this.releaseHandler = function(e) {
            self.release(e);
          };
          this.dragStartGesture = ionic.onGesture('dragstart', this.dragStartHandler, this.el);
          this.dragGesture = ionic.onGesture('drag', this.dragHandler, this.el);
          this.dragHoldGesture = ionic.onGesture('hold', this.holdHandler, this.el);
          this.dragReleaseGesture = ionic.onGesture('release', this.releaseHandler, this.el);
        },
        destroy: function() {
          ionic.offGesture(this.dragStartGesture, 'dragstart', this.dragStartGesture);
          ionic.offGesture(this.dragGesture, 'drag', this.dragGesture);
          ionic.offGesture(this.dragHoldGesture, 'hold', this.holdHandler);
          ionic.offGesture(this.dragReleaseGesture, 'release', this.releaseHandler);
        },
        tap: function() {
          if (this.el.getAttribute('disabled') !== 'disabled') {
            this.val(!this.checkbox.checked);
          }
        },
        dragStart: function(e) {
          if (this.checkbox.disabled)
            return;
          this._dragInfo = {
            width: this.el.offsetWidth,
            left: this.el.offsetLeft,
            right: this.el.offsetLeft + this.el.offsetWidth,
            triggerX: this.el.offsetWidth / 2,
            initialState: this.checkbox.checked
          };
          e.gesture.srcEvent.preventDefault();
          this.hold(e);
        },
        drag: function(e) {
          var self = this;
          if (!this._dragInfo) {
            return;
          }
          e.gesture.srcEvent.preventDefault();
          ionic.requestAnimationFrame(function() {
            if (!self._dragInfo) {
              return;
            }
            var px = e.gesture.touches[0].pageX - self._dragInfo.left;
            var mx = self._dragInfo.width - self.triggerThreshold;
            if (self._dragInfo.initialState) {
              if (px < self.triggerThreshold) {
                self.setOpenPercent(0);
              } else if (px > self._dragInfo.triggerX) {
                self.setOpenPercent(100);
              }
            } else {
              if (px < self._dragInfo.triggerX) {
                self.setOpenPercent(0);
              } else if (px > mx) {
                self.setOpenPercent(100);
              }
            }
          });
        },
        endDrag: function() {
          this._dragInfo = null;
        },
        hold: function() {
          this.el.classList.add('dragging');
        },
        release: function(e) {
          this.el.classList.remove('dragging');
          this.endDrag(e);
        },
        setOpenPercent: function(openPercent) {
          if (this.openPercent < 0 || (openPercent < (this.openPercent - 3) || openPercent > (this.openPercent + 3))) {
            this.openPercent = openPercent;
            if (openPercent === 0) {
              this.val(false);
            } else if (openPercent === 100) {
              this.val(true);
            } else {
              var openPixel = Math.round((openPercent / 100) * this.track.offsetWidth - (this.handle.offsetWidth));
              openPixel = (openPixel < 1 ? 0 : openPixel);
              this.handle.style[ionic.CSS.TRANSFORM] = 'translate3d(' + openPixel + 'px,0,0)';
            }
          }
        },
        val: function(value) {
          if (value === true || value === false) {
            if (this.handle.style[ionic.CSS.TRANSFORM] !== "") {
              this.handle.style[ionic.CSS.TRANSFORM] = "";
            }
            this.checkbox.checked = value;
            this.openPercent = (value ? 100 : 0);
            this.onChange && this.onChange();
          }
          return this.checkbox.checked;
        }
      });
    })(ionic);
  })();
  (function(window, document, undefined) {
    'use strict';
    function minErr(module, ErrorConstructor) {
      ErrorConstructor = ErrorConstructor || Error;
      return function() {
        var SKIP_INDEXES = 2;
        var templateArgs = arguments,
            code = templateArgs[0],
            message = '[' + (module ? module + ':' : '') + code + '] ',
            template = templateArgs[1],
            paramPrefix,
            i;
        message += template.replace(/\{\d+\}/g, function(match) {
          var index = +match.slice(1, -1),
              shiftedIndex = index + SKIP_INDEXES;
          if (shiftedIndex < templateArgs.length) {
            return toDebugString(templateArgs[shiftedIndex]);
          }
          return match;
        });
        message += '\nhttp://errors.angularjs.org/1.4.3/' + (module ? module + '/' : '') + code;
        for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
          message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
        }
        return new ErrorConstructor(message);
      };
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
    var VALIDITY_STATE_PROPERTY = 'validity';
    var lowercase = function(string) {
      return isString(string) ? string.toLowerCase() : string;
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var uppercase = function(string) {
      return isString(string) ? string.toUpperCase() : string;
    };
    var manualLowercase = function(s) {
      return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) | 32);
      }) : s;
    };
    var manualUppercase = function(s) {
      return isString(s) ? s.replace(/[a-z]/g, function(ch) {
        return String.fromCharCode(ch.charCodeAt(0) & ~32);
      }) : s;
    };
    if ('i' !== 'I'.toLowerCase()) {
      lowercase = manualLowercase;
      uppercase = manualUppercase;
    }
    var msie,
        jqLite,
        jQuery,
        slice = [].slice,
        splice = [].splice,
        push = [].push,
        toString = Object.prototype.toString,
        getPrototypeOf = Object.getPrototypeOf,
        ngMinErr = minErr('ng'),
        angular = window.angular || (window.angular = {}),
        angularModule,
        uid = 0;
    msie = document.documentMode;
    function isArrayLike(obj) {
      if (obj == null || isWindow(obj)) {
        return false;
      }
      var length = "length" in Object(obj) && obj.length;
      if (obj.nodeType === NODE_TYPE_ELEMENT && length) {
        return true;
      }
      return isString(obj) || isArray(obj) || length === 0 || typeof length === 'number' && length > 0 && (length - 1) in obj;
    }
    function forEach(obj, iterator, context) {
      var key,
          length;
      if (obj) {
        if (isFunction(obj)) {
          for (key in obj) {
            if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        } else if (isArray(obj) || isArrayLike(obj)) {
          var isPrimitive = typeof obj !== 'object';
          for (key = 0, length = obj.length; key < length; key++) {
            if (isPrimitive || key in obj) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        } else if (obj.forEach && obj.forEach !== forEach) {
          obj.forEach(iterator, context, obj);
        } else if (isBlankObject(obj)) {
          for (key in obj) {
            iterator.call(context, obj[key], key, obj);
          }
        } else if (typeof obj.hasOwnProperty === 'function') {
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        } else {
          for (key in obj) {
            if (hasOwnProperty.call(obj, key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        }
      }
      return obj;
    }
    function forEachSorted(obj, iterator, context) {
      var keys = Object.keys(obj).sort();
      for (var i = 0; i < keys.length; i++) {
        iterator.call(context, obj[keys[i]], keys[i]);
      }
      return keys;
    }
    function reverseParams(iteratorFn) {
      return function(value, key) {
        iteratorFn(key, value);
      };
    }
    function nextUid() {
      return ++uid;
    }
    function setHashKey(obj, h) {
      if (h) {
        obj.$$hashKey = h;
      } else {
        delete obj.$$hashKey;
      }
    }
    function baseExtend(dst, objs, deep) {
      var h = dst.$$hashKey;
      for (var i = 0,
          ii = objs.length; i < ii; ++i) {
        var obj = objs[i];
        if (!isObject(obj) && !isFunction(obj))
          continue;
        var keys = Object.keys(obj);
        for (var j = 0,
            jj = keys.length; j < jj; j++) {
          var key = keys[j];
          var src = obj[key];
          if (deep && isObject(src)) {
            if (isDate(src)) {
              dst[key] = new Date(src.valueOf());
            } else {
              if (!isObject(dst[key]))
                dst[key] = isArray(src) ? [] : {};
              baseExtend(dst[key], [src], true);
            }
          } else {
            dst[key] = src;
          }
        }
      }
      setHashKey(dst, h);
      return dst;
    }
    function extend(dst) {
      return baseExtend(dst, slice.call(arguments, 1), false);
    }
    function merge(dst) {
      return baseExtend(dst, slice.call(arguments, 1), true);
    }
    function toInt(str) {
      return parseInt(str, 10);
    }
    function inherit(parent, extra) {
      return extend(Object.create(parent), extra);
    }
    function noop() {}
    noop.$inject = [];
    function identity($) {
      return $;
    }
    identity.$inject = [];
    function valueFn(value) {
      return function() {
        return value;
      };
    }
    function hasCustomToString(obj) {
      return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
    }
    function isUndefined(value) {
      return typeof value === 'undefined';
    }
    function isDefined(value) {
      return typeof value !== 'undefined';
    }
    function isObject(value) {
      return value !== null && typeof value === 'object';
    }
    function isBlankObject(value) {
      return value !== null && typeof value === 'object' && !getPrototypeOf(value);
    }
    function isString(value) {
      return typeof value === 'string';
    }
    function isNumber(value) {
      return typeof value === 'number';
    }
    function isDate(value) {
      return toString.call(value) === '[object Date]';
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      return typeof value === 'function';
    }
    function isRegExp(value) {
      return toString.call(value) === '[object RegExp]';
    }
    function isWindow(obj) {
      return obj && obj.window === obj;
    }
    function isScope(obj) {
      return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
      return toString.call(obj) === '[object File]';
    }
    function isFormData(obj) {
      return toString.call(obj) === '[object FormData]';
    }
    function isBlob(obj) {
      return toString.call(obj) === '[object Blob]';
    }
    function isBoolean(value) {
      return typeof value === 'boolean';
    }
    function isPromiseLike(obj) {
      return obj && isFunction(obj.then);
    }
    var TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/;
    function isTypedArray(value) {
      return TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    var trim = function(value) {
      return isString(value) ? value.trim() : value;
    };
    var escapeForRegexp = function(s) {
      return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
    };
    function isElement(node) {
      return !!(node && (node.nodeName || (node.prop && node.attr && node.find)));
    }
    function makeMap(str) {
      var obj = {},
          items = str.split(","),
          i;
      for (i = 0; i < items.length; i++) {
        obj[items[i]] = true;
      }
      return obj;
    }
    function nodeName_(element) {
      return lowercase(element.nodeName || (element[0] && element[0].nodeName));
    }
    function includes(array, obj) {
      return Array.prototype.indexOf.call(array, obj) != -1;
    }
    function arrayRemove(array, value) {
      var index = array.indexOf(value);
      if (index >= 0) {
        array.splice(index, 1);
      }
      return index;
    }
    function copy(source, destination, stackSource, stackDest) {
      if (isWindow(source) || isScope(source)) {
        throw ngMinErr('cpws', "Can't copy! Making copies of Window or Scope instances is not supported.");
      }
      if (isTypedArray(destination)) {
        throw ngMinErr('cpta', "Can't copy! TypedArray destination cannot be mutated.");
      }
      if (!destination) {
        destination = source;
        if (isObject(source)) {
          var index;
          if (stackSource && (index = stackSource.indexOf(source)) !== -1) {
            return stackDest[index];
          }
          if (isArray(source)) {
            return copy(source, [], stackSource, stackDest);
          } else if (isTypedArray(source)) {
            destination = new source.constructor(source);
          } else if (isDate(source)) {
            destination = new Date(source.getTime());
          } else if (isRegExp(source)) {
            destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
            destination.lastIndex = source.lastIndex;
          } else {
            var emptyObject = Object.create(getPrototypeOf(source));
            return copy(source, emptyObject, stackSource, stackDest);
          }
          if (stackDest) {
            stackSource.push(source);
            stackDest.push(destination);
          }
        }
      } else {
        if (source === destination)
          throw ngMinErr('cpi', "Can't copy! Source and destination are identical.");
        stackSource = stackSource || [];
        stackDest = stackDest || [];
        if (isObject(source)) {
          stackSource.push(source);
          stackDest.push(destination);
        }
        var result,
            key;
        if (isArray(source)) {
          destination.length = 0;
          for (var i = 0; i < source.length; i++) {
            destination.push(copy(source[i], null, stackSource, stackDest));
          }
        } else {
          var h = destination.$$hashKey;
          if (isArray(destination)) {
            destination.length = 0;
          } else {
            forEach(destination, function(value, key) {
              delete destination[key];
            });
          }
          if (isBlankObject(source)) {
            for (key in source) {
              destination[key] = copy(source[key], null, stackSource, stackDest);
            }
          } else if (source && typeof source.hasOwnProperty === 'function') {
            for (key in source) {
              if (source.hasOwnProperty(key)) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            }
          } else {
            for (key in source) {
              if (hasOwnProperty.call(source, key)) {
                destination[key] = copy(source[key], null, stackSource, stackDest);
              }
            }
          }
          setHashKey(destination, h);
        }
      }
      return destination;
    }
    function shallowCopy(src, dst) {
      if (isArray(src)) {
        dst = dst || [];
        for (var i = 0,
            ii = src.length; i < ii; i++) {
          dst[i] = src[i];
        }
      } else if (isObject(src)) {
        dst = dst || {};
        for (var key in src) {
          if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
            dst[key] = src[key];
          }
        }
      }
      return dst || src;
    }
    function equals(o1, o2) {
      if (o1 === o2)
        return true;
      if (o1 === null || o2 === null)
        return false;
      if (o1 !== o1 && o2 !== o2)
        return true;
      var t1 = typeof o1,
          t2 = typeof o2,
          length,
          key,
          keySet;
      if (t1 == t2) {
        if (t1 == 'object') {
          if (isArray(o1)) {
            if (!isArray(o2))
              return false;
            if ((length = o1.length) == o2.length) {
              for (key = 0; key < length; key++) {
                if (!equals(o1[key], o2[key]))
                  return false;
              }
              return true;
            }
          } else if (isDate(o1)) {
            if (!isDate(o2))
              return false;
            return equals(o1.getTime(), o2.getTime());
          } else if (isRegExp(o1)) {
            return isRegExp(o2) ? o1.toString() == o2.toString() : false;
          } else {
            if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
              return false;
            keySet = createMap();
            for (key in o1) {
              if (key.charAt(0) === '$' || isFunction(o1[key]))
                continue;
              if (!equals(o1[key], o2[key]))
                return false;
              keySet[key] = true;
            }
            for (key in o2) {
              if (!(key in keySet) && key.charAt(0) !== '$' && o2[key] !== undefined && !isFunction(o2[key]))
                return false;
            }
            return true;
          }
        }
      }
      return false;
    }
    var csp = function() {
      if (isDefined(csp.isActive_))
        return csp.isActive_;
      var active = !!(document.querySelector('[ng-csp]') || document.querySelector('[data-ng-csp]'));
      if (!active) {
        try {
          new Function('');
        } catch (e) {
          active = true;
        }
      }
      return (csp.isActive_ = active);
    };
    var jq = function() {
      if (isDefined(jq.name_))
        return jq.name_;
      var el;
      var i,
          ii = ngAttrPrefixes.length,
          prefix,
          name;
      for (i = 0; i < ii; ++i) {
        prefix = ngAttrPrefixes[i];
        if (el = document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
          name = el.getAttribute(prefix + 'jq');
          break;
        }
      }
      return (jq.name_ = name);
    };
    function concat(array1, array2, index) {
      return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
      return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
      var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
      if (isFunction(fn) && !(fn instanceof RegExp)) {
        return curryArgs.length ? function() {
          return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
          return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
      } else {
        return fn;
      }
    }
    function toJsonReplacer(key, value) {
      var val = value;
      if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
        val = undefined;
      } else if (isWindow(value)) {
        val = '$WINDOW';
      } else if (value && document === value) {
        val = '$DOCUMENT';
      } else if (isScope(value)) {
        val = '$SCOPE';
      }
      return val;
    }
    function toJson(obj, pretty) {
      if (typeof obj === 'undefined')
        return undefined;
      if (!isNumber(pretty)) {
        pretty = pretty ? 2 : null;
      }
      return JSON.stringify(obj, toJsonReplacer, pretty);
    }
    function fromJson(json) {
      return isString(json) ? JSON.parse(json) : json;
    }
    function timezoneToOffset(timezone, fallback) {
      var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
      return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
      date = new Date(date.getTime());
      date.setMinutes(date.getMinutes() + minutes);
      return date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
      reverse = reverse ? -1 : 1;
      var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
      return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
    function startingTag(element) {
      element = jqLite(element).clone();
      try {
        element.empty();
      } catch (e) {}
      var elemHtml = jqLite('<div>').append(element).html();
      try {
        return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
          return '<' + lowercase(nodeName);
        });
      } catch (e) {
        return lowercase(elemHtml);
      }
    }
    function tryDecodeURIComponent(value) {
      try {
        return decodeURIComponent(value);
      } catch (e) {}
    }
    function parseKeyValue(keyValue) {
      var obj = {},
          key_value,
          key;
      forEach((keyValue || "").split('&'), function(keyValue) {
        if (keyValue) {
          key_value = keyValue.replace(/\+/g, '%20').split('=');
          key = tryDecodeURIComponent(key_value[0]);
          if (isDefined(key)) {
            var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;
            if (!hasOwnProperty.call(obj, key)) {
              obj[key] = val;
            } else if (isArray(obj[key])) {
              obj[key].push(val);
            } else {
              obj[key] = [obj[key], val];
            }
          }
        }
      });
      return obj;
    }
    function toKeyValue(obj) {
      var parts = [];
      forEach(obj, function(value, key) {
        if (isArray(value)) {
          forEach(value, function(arrayValue) {
            parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
          });
        } else {
          parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
        }
      });
      return parts.length ? parts.join('&') : '';
    }
    function encodeUriSegment(val) {
      return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
      return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
    }
    var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
    function getNgAttribute(element, ngAttr) {
      var attr,
          i,
          ii = ngAttrPrefixes.length;
      for (i = 0; i < ii; ++i) {
        attr = ngAttrPrefixes[i] + ngAttr;
        if (isString(attr = element.getAttribute(attr))) {
          return attr;
        }
      }
      return null;
    }
    function angularInit(element, bootstrap) {
      var appElement,
          module,
          config = {};
      forEach(ngAttrPrefixes, function(prefix) {
        var name = prefix + 'app';
        if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
          appElement = element;
          module = element.getAttribute(name);
        }
      });
      forEach(ngAttrPrefixes, function(prefix) {
        var name = prefix + 'app';
        var candidate;
        if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
          appElement = candidate;
          module = candidate.getAttribute(name);
        }
      });
      if (appElement) {
        config.strictDi = getNgAttribute(appElement, "strict-di") !== null;
        bootstrap(appElement, module ? [module] : [], config);
      }
    }
    function bootstrap(element, modules, config) {
      if (!isObject(config))
        config = {};
      var defaultConfig = {strictDi: false};
      config = extend(defaultConfig, config);
      var doBootstrap = function() {
        element = jqLite(element);
        if (element.injector()) {
          var tag = (element[0] === document) ? 'document' : startingTag(element);
          throw ngMinErr('btstrpd', "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
        }
        modules = modules || [];
        modules.unshift(['$provide', function($provide) {
          $provide.value('$rootElement', element);
        }]);
        if (config.debugInfoEnabled) {
          modules.push(['$compileProvider', function($compileProvider) {
            $compileProvider.debugInfoEnabled(true);
          }]);
        }
        modules.unshift('ng');
        var injector = createInjector(modules, config.strictDi);
        injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', function bootstrapApply(scope, element, compile, injector) {
          scope.$apply(function() {
            element.data('$injector', injector);
            compile(element)(scope);
          });
        }]);
        return injector;
      };
      var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
      var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
      if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
        config.debugInfoEnabled = true;
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
      }
      if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
        return doBootstrap();
      }
      window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
      angular.resumeBootstrap = function(extraModules) {
        forEach(extraModules, function(module) {
          modules.push(module);
        });
        return doBootstrap();
      };
      if (isFunction(angular.resumeDeferredBootstrap)) {
        angular.resumeDeferredBootstrap();
      }
    }
    function reloadWithDebugInfo() {
      window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
      window.location.reload();
    }
    function getTestability(rootElement) {
      var injector = angular.element(rootElement).injector();
      if (!injector) {
        throw ngMinErr('test', 'no injector found for element argument to getTestability');
      }
      return injector.get('$$testability');
    }
    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator) {
      separator = separator || '_';
      return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
        return (pos ? separator : '') + letter.toLowerCase();
      });
    }
    var bindJQueryFired = false;
    var skipDestroyOnNextJQueryCleanData;
    function bindJQuery() {
      var originalCleanData;
      if (bindJQueryFired) {
        return;
      }
      var jqName = jq();
      jQuery = window.jQuery;
      if (isDefined(jqName)) {
        jQuery = jqName === null ? undefined : window[jqName];
      }
      if (jQuery && jQuery.fn.on) {
        jqLite = jQuery;
        extend(jQuery.fn, {
          scope: JQLitePrototype.scope,
          isolateScope: JQLitePrototype.isolateScope,
          controller: JQLitePrototype.controller,
          injector: JQLitePrototype.injector,
          inheritedData: JQLitePrototype.inheritedData
        });
        originalCleanData = jQuery.cleanData;
        jQuery.cleanData = function(elems) {
          var events;
          if (!skipDestroyOnNextJQueryCleanData) {
            for (var i = 0,
                elem; (elem = elems[i]) != null; i++) {
              events = jQuery._data(elem, "events");
              if (events && events.$destroy) {
                jQuery(elem).triggerHandler('$destroy');
              }
            }
          } else {
            skipDestroyOnNextJQueryCleanData = false;
          }
          originalCleanData(elems);
        };
      } else {
        jqLite = JQLite;
      }
      angular.element = jqLite;
      bindJQueryFired = true;
    }
    function assertArg(arg, name, reason) {
      if (!arg) {
        throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
      }
      return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
      if (acceptArrayAnnotation && isArray(arg)) {
        arg = arg[arg.length - 1];
      }
      assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
      return arg;
    }
    function assertNotHasOwnProperty(name, context) {
      if (name === 'hasOwnProperty') {
        throw ngMinErr('badname', "hasOwnProperty is not a valid {0} name", context);
      }
    }
    function getter(obj, path, bindFnToScope) {
      if (!path)
        return obj;
      var keys = path.split('.');
      var key;
      var lastInstance = obj;
      var len = keys.length;
      for (var i = 0; i < len; i++) {
        key = keys[i];
        if (obj) {
          obj = (lastInstance = obj)[key];
        }
      }
      if (!bindFnToScope && isFunction(obj)) {
        return bind(lastInstance, obj);
      }
      return obj;
    }
    function getBlockNodes(nodes) {
      var node = nodes[0];
      var endNode = nodes[nodes.length - 1];
      var blockNodes = [node];
      do {
        node = node.nextSibling;
        if (!node)
          break;
        blockNodes.push(node);
      } while (node !== endNode);
      return jqLite(blockNodes);
    }
    function createMap() {
      return Object.create(null);
    }
    var NODE_TYPE_ELEMENT = 1;
    var NODE_TYPE_ATTRIBUTE = 2;
    var NODE_TYPE_TEXT = 3;
    var NODE_TYPE_COMMENT = 8;
    var NODE_TYPE_DOCUMENT = 9;
    var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
    function setupModuleLoader(window) {
      var $injectorMinErr = minErr('$injector');
      var ngMinErr = minErr('ng');
      function ensure(obj, name, factory) {
        return obj[name] || (obj[name] = factory());
      }
      var angular = ensure(window, 'angular', Object);
      angular.$$minErr = angular.$$minErr || minErr;
      return ensure(angular, 'module', function() {
        var modules = {};
        return function module(name, requires, configFn) {
          var assertNotHasOwnProperty = function(name, context) {
            if (name === 'hasOwnProperty') {
              throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
            }
          };
          assertNotHasOwnProperty(name, 'module');
          if (requires && modules.hasOwnProperty(name)) {
            modules[name] = null;
          }
          return ensure(modules, name, function() {
            if (!requires) {
              throw $injectorMinErr('nomod', "Module '{0}' is not available! You either misspelled " + "the module name or forgot to load it. If registering a module ensure that you " + "specify the dependencies as the second argument.", name);
            }
            var invokeQueue = [];
            var configBlocks = [];
            var runBlocks = [];
            var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
            var moduleInstance = {
              _invokeQueue: invokeQueue,
              _configBlocks: configBlocks,
              _runBlocks: runBlocks,
              requires: requires,
              name: name,
              provider: invokeLaterAndSetModuleName('$provide', 'provider'),
              factory: invokeLaterAndSetModuleName('$provide', 'factory'),
              service: invokeLaterAndSetModuleName('$provide', 'service'),
              value: invokeLater('$provide', 'value'),
              constant: invokeLater('$provide', 'constant', 'unshift'),
              decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
              animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
              filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
              controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
              directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
              config: config,
              run: function(block) {
                runBlocks.push(block);
                return this;
              }
            };
            if (configFn) {
              config(configFn);
            }
            return moduleInstance;
            function invokeLater(provider, method, insertMethod, queue) {
              if (!queue)
                queue = invokeQueue;
              return function() {
                queue[insertMethod || 'push']([provider, method, arguments]);
                return moduleInstance;
              };
            }
            function invokeLaterAndSetModuleName(provider, method) {
              return function(recipeName, factoryFunction) {
                if (factoryFunction && isFunction(factoryFunction))
                  factoryFunction.$$moduleName = name;
                invokeQueue.push([provider, method, arguments]);
                return moduleInstance;
              };
            }
          });
        };
      });
    }
    function serializeObject(obj) {
      var seen = [];
      return JSON.stringify(obj, function(key, val) {
        val = toJsonReplacer(key, val);
        if (isObject(val)) {
          if (seen.indexOf(val) >= 0)
            return '<<already seen>>';
          seen.push(val);
        }
        return val;
      });
    }
    function toDebugString(obj) {
      if (typeof obj === 'function') {
        return obj.toString().replace(/ \{[\s\S]*$/, '');
      } else if (typeof obj === 'undefined') {
        return 'undefined';
      } else if (typeof obj !== 'string') {
        return serializeObject(obj);
      }
      return obj;
    }
    var version = {
      full: '1.4.3',
      major: 1,
      minor: 4,
      dot: 3,
      codeName: 'foam-acceleration'
    };
    function publishExternalAPI(angular) {
      extend(angular, {
        'bootstrap': bootstrap,
        'copy': copy,
        'extend': extend,
        'merge': merge,
        'equals': equals,
        'element': jqLite,
        'forEach': forEach,
        'injector': createInjector,
        'noop': noop,
        'bind': bind,
        'toJson': toJson,
        'fromJson': fromJson,
        'identity': identity,
        'isUndefined': isUndefined,
        'isDefined': isDefined,
        'isString': isString,
        'isFunction': isFunction,
        'isObject': isObject,
        'isNumber': isNumber,
        'isElement': isElement,
        'isArray': isArray,
        'version': version,
        'isDate': isDate,
        'lowercase': lowercase,
        'uppercase': uppercase,
        'callbacks': {counter: 0},
        'getTestability': getTestability,
        '$$minErr': minErr,
        '$$csp': csp,
        'reloadWithDebugInfo': reloadWithDebugInfo
      });
      angularModule = setupModuleLoader(window);
      try {
        angularModule('ngLocale');
      } catch (e) {
        angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
      }
      angularModule('ng', ['ngLocale'], ['$provide', function ngModule($provide) {
        $provide.provider({$$sanitizeUri: $$SanitizeUriProvider});
        $provide.provider('$compile', $CompileProvider).directive({
          a: htmlAnchorDirective,
          input: inputDirective,
          textarea: inputDirective,
          form: formDirective,
          script: scriptDirective,
          select: selectDirective,
          style: styleDirective,
          option: optionDirective,
          ngBind: ngBindDirective,
          ngBindHtml: ngBindHtmlDirective,
          ngBindTemplate: ngBindTemplateDirective,
          ngClass: ngClassDirective,
          ngClassEven: ngClassEvenDirective,
          ngClassOdd: ngClassOddDirective,
          ngCloak: ngCloakDirective,
          ngController: ngControllerDirective,
          ngForm: ngFormDirective,
          ngHide: ngHideDirective,
          ngIf: ngIfDirective,
          ngInclude: ngIncludeDirective,
          ngInit: ngInitDirective,
          ngNonBindable: ngNonBindableDirective,
          ngPluralize: ngPluralizeDirective,
          ngRepeat: ngRepeatDirective,
          ngShow: ngShowDirective,
          ngStyle: ngStyleDirective,
          ngSwitch: ngSwitchDirective,
          ngSwitchWhen: ngSwitchWhenDirective,
          ngSwitchDefault: ngSwitchDefaultDirective,
          ngOptions: ngOptionsDirective,
          ngTransclude: ngTranscludeDirective,
          ngModel: ngModelDirective,
          ngList: ngListDirective,
          ngChange: ngChangeDirective,
          pattern: patternDirective,
          ngPattern: patternDirective,
          required: requiredDirective,
          ngRequired: requiredDirective,
          minlength: minlengthDirective,
          ngMinlength: minlengthDirective,
          maxlength: maxlengthDirective,
          ngMaxlength: maxlengthDirective,
          ngValue: ngValueDirective,
          ngModelOptions: ngModelOptionsDirective
        }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
        $provide.provider({
          $anchorScroll: $AnchorScrollProvider,
          $animate: $AnimateProvider,
          $$animateQueue: $$CoreAnimateQueueProvider,
          $$AnimateRunner: $$CoreAnimateRunnerProvider,
          $browser: $BrowserProvider,
          $cacheFactory: $CacheFactoryProvider,
          $controller: $ControllerProvider,
          $document: $DocumentProvider,
          $exceptionHandler: $ExceptionHandlerProvider,
          $filter: $FilterProvider,
          $interpolate: $InterpolateProvider,
          $interval: $IntervalProvider,
          $http: $HttpProvider,
          $httpParamSerializer: $HttpParamSerializerProvider,
          $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
          $httpBackend: $HttpBackendProvider,
          $location: $LocationProvider,
          $log: $LogProvider,
          $parse: $ParseProvider,
          $rootScope: $RootScopeProvider,
          $q: $QProvider,
          $$q: $$QProvider,
          $sce: $SceProvider,
          $sceDelegate: $SceDelegateProvider,
          $sniffer: $SnifferProvider,
          $templateCache: $TemplateCacheProvider,
          $templateRequest: $TemplateRequestProvider,
          $$testability: $$TestabilityProvider,
          $timeout: $TimeoutProvider,
          $window: $WindowProvider,
          $$rAF: $$RAFProvider,
          $$jqLite: $$jqLiteProvider,
          $$HashMap: $$HashMapProvider,
          $$cookieReader: $$CookieReaderProvider
        });
      }]);
    }
    JQLite.expando = 'ng339';
    var jqCache = JQLite.cache = {},
        jqId = 1,
        addEventListenerFn = function(element, type, fn) {
          element.addEventListener(type, fn, false);
        },
        removeEventListenerFn = function(element, type, fn) {
          element.removeEventListener(type, fn, false);
        };
    JQLite._data = function(node) {
      return this.cache[node[this.expando]] || {};
    };
    function jqNextId() {
      return ++jqId;
    }
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;
    var MOUSE_EVENT_MAP = {
      mouseleave: "mouseout",
      mouseenter: "mouseover"
    };
    var jqLiteMinErr = minErr('jqLite');
    function camelCase(name) {
      return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
        return offset ? letter.toUpperCase() : letter;
      }).replace(MOZ_HACK_REGEXP, 'Moz$1');
    }
    var SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
    var HTML_REGEXP = /<|&#?\w+;/;
    var TAG_NAME_REGEXP = /<([\w:]+)/;
    var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
    var wrapMap = {
      'option': [1, '<select multiple="multiple">', '</select>'],
      'thead': [1, '<table>', '</table>'],
      'col': [2, '<table><colgroup>', '</colgroup></table>'],
      'tr': [2, '<table><tbody>', '</tbody></table>'],
      'td': [3, '<table><tbody><tr>', '</tr></tbody></table>'],
      '_default': [0, "", ""]
    };
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    function jqLiteIsTextNode(html) {
      return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
      var nodeType = node.nodeType;
      return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
      for (var key in jqCache[node.ng339]) {
        return true;
      }
      return false;
    }
    function jqLiteBuildFragment(html, context) {
      var tmp,
          tag,
          wrap,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i;
      if (jqLiteIsTextNode(html)) {
        nodes.push(context.createTextNode(html));
      } else {
        tmp = tmp || fragment.appendChild(context.createElement("div"));
        tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase();
        wrap = wrapMap[tag] || wrapMap._default;
        tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2];
        i = wrap[0];
        while (i--) {
          tmp = tmp.lastChild;
        }
        nodes = concat(nodes, tmp.childNodes);
        tmp = fragment.firstChild;
        tmp.textContent = "";
      }
      fragment.textContent = "";
      fragment.innerHTML = "";
      forEach(nodes, function(node) {
        fragment.appendChild(node);
      });
      return fragment;
    }
    function jqLiteParseHTML(html, context) {
      context = context || document;
      var parsed;
      if ((parsed = SINGLE_TAG_REGEXP.exec(html))) {
        return [context.createElement(parsed[1])];
      }
      if ((parsed = jqLiteBuildFragment(html, context))) {
        return parsed.childNodes;
      }
      return [];
    }
    function JQLite(element) {
      if (element instanceof JQLite) {
        return element;
      }
      var argIsString;
      if (isString(element)) {
        element = trim(element);
        argIsString = true;
      }
      if (!(this instanceof JQLite)) {
        if (argIsString && element.charAt(0) != '<') {
          throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
        }
        return new JQLite(element);
      }
      if (argIsString) {
        jqLiteAddNodes(this, jqLiteParseHTML(element));
      } else {
        jqLiteAddNodes(this, element);
      }
    }
    function jqLiteClone(element) {
      return element.cloneNode(true);
    }
    function jqLiteDealoc(element, onlyDescendants) {
      if (!onlyDescendants)
        jqLiteRemoveData(element);
      if (element.querySelectorAll) {
        var descendants = element.querySelectorAll('*');
        for (var i = 0,
            l = descendants.length; i < l; i++) {
          jqLiteRemoveData(descendants[i]);
        }
      }
    }
    function jqLiteOff(element, type, fn, unsupported) {
      if (isDefined(unsupported))
        throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
      var expandoStore = jqLiteExpandoStore(element);
      var events = expandoStore && expandoStore.events;
      var handle = expandoStore && expandoStore.handle;
      if (!handle)
        return;
      if (!type) {
        for (type in events) {
          if (type !== '$destroy') {
            removeEventListenerFn(element, type, handle);
          }
          delete events[type];
        }
      } else {
        forEach(type.split(' '), function(type) {
          if (isDefined(fn)) {
            var listenerFns = events[type];
            arrayRemove(listenerFns || [], fn);
            if (listenerFns && listenerFns.length > 0) {
              return;
            }
          }
          removeEventListenerFn(element, type, handle);
          delete events[type];
        });
      }
    }
    function jqLiteRemoveData(element, name) {
      var expandoId = element.ng339;
      var expandoStore = expandoId && jqCache[expandoId];
      if (expandoStore) {
        if (name) {
          delete expandoStore.data[name];
          return;
        }
        if (expandoStore.handle) {
          if (expandoStore.events.$destroy) {
            expandoStore.handle({}, '$destroy');
          }
          jqLiteOff(element);
        }
        delete jqCache[expandoId];
        element.ng339 = undefined;
      }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
      var expandoId = element.ng339,
          expandoStore = expandoId && jqCache[expandoId];
      if (createIfNecessary && !expandoStore) {
        element.ng339 = expandoId = jqNextId();
        expandoStore = jqCache[expandoId] = {
          events: {},
          data: {},
          handle: undefined
        };
      }
      return expandoStore;
    }
    function jqLiteData(element, key, value) {
      if (jqLiteAcceptsData(element)) {
        var isSimpleSetter = isDefined(value);
        var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
        var massGetter = !key;
        var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
        var data = expandoStore && expandoStore.data;
        if (isSimpleSetter) {
          data[key] = value;
        } else {
          if (massGetter) {
            return data;
          } else {
            if (isSimpleGetter) {
              return data && data[key];
            } else {
              extend(data, key);
            }
          }
        }
      }
    }
    function jqLiteHasClass(element, selector) {
      if (!element.getAttribute)
        return false;
      return ((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1);
    }
    function jqLiteRemoveClass(element, cssClasses) {
      if (cssClasses && element.setAttribute) {
        forEach(cssClasses.split(' '), function(cssClass) {
          element.setAttribute('class', trim((" " + (element.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
      }
    }
    function jqLiteAddClass(element, cssClasses) {
      if (cssClasses && element.setAttribute) {
        var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
        forEach(cssClasses.split(' '), function(cssClass) {
          cssClass = trim(cssClass);
          if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
            existingClasses += cssClass + ' ';
          }
        });
        element.setAttribute('class', trim(existingClasses));
      }
    }
    function jqLiteAddNodes(root, elements) {
      if (elements) {
        if (elements.nodeType) {
          root[root.length++] = elements;
        } else {
          var length = elements.length;
          if (typeof length === 'number' && elements.window !== elements) {
            if (length) {
              for (var i = 0; i < length; i++) {
                root[root.length++] = elements[i];
              }
            }
          } else {
            root[root.length++] = elements;
          }
        }
      }
    }
    function jqLiteController(element, name) {
      return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
    }
    function jqLiteInheritedData(element, name, value) {
      if (element.nodeType == NODE_TYPE_DOCUMENT) {
        element = element.documentElement;
      }
      var names = isArray(name) ? name : [name];
      while (element) {
        for (var i = 0,
            ii = names.length; i < ii; i++) {
          if ((value = jqLite.data(element, names[i])) !== undefined)
            return value;
        }
        element = element.parentNode || (element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host);
      }
    }
    function jqLiteEmpty(element) {
      jqLiteDealoc(element, true);
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
    function jqLiteRemove(element, keepData) {
      if (!keepData)
        jqLiteDealoc(element);
      var parent = element.parentNode;
      if (parent)
        parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
      win = win || window;
      if (win.document.readyState === 'complete') {
        win.setTimeout(action);
      } else {
        jqLite(win).on('load', action);
      }
    }
    var JQLitePrototype = JQLite.prototype = {
      ready: function(fn) {
        var fired = false;
        function trigger() {
          if (fired)
            return;
          fired = true;
          fn();
        }
        if (document.readyState === 'complete') {
          setTimeout(trigger);
        } else {
          this.on('DOMContentLoaded', trigger);
          JQLite(window).on('load', trigger);
        }
      },
      toString: function() {
        var value = [];
        forEach(this, function(e) {
          value.push('' + e);
        });
        return '[' + value.join(', ') + ']';
      },
      eq: function(index) {
        return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
      },
      length: 0,
      push: push,
      sort: [].sort,
      splice: [].splice
    };
    var BOOLEAN_ATTR = {};
    forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {
      BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach('input,select,option,textarea,button,form,details'.split(','), function(value) {
      BOOLEAN_ELEMENTS[value] = true;
    });
    var ALIASED_ATTR = {
      'ngMinlength': 'minlength',
      'ngMaxlength': 'maxlength',
      'ngMin': 'min',
      'ngMax': 'max',
      'ngPattern': 'pattern'
    };
    function getBooleanAttrName(element, name) {
      var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
      return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(element, name) {
      var nodeName = element.nodeName;
      return (nodeName === 'INPUT' || nodeName === 'TEXTAREA') && ALIASED_ATTR[name];
    }
    forEach({
      data: jqLiteData,
      removeData: jqLiteRemoveData,
      hasData: jqLiteHasData
    }, function(fn, name) {
      JQLite[name] = fn;
    });
    forEach({
      data: jqLiteData,
      inheritedData: jqLiteInheritedData,
      scope: function(element) {
        return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, ['$isolateScope', '$scope']);
      },
      isolateScope: function(element) {
        return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
      },
      controller: jqLiteController,
      injector: function(element) {
        return jqLiteInheritedData(element, '$injector');
      },
      removeAttr: function(element, name) {
        element.removeAttribute(name);
      },
      hasClass: jqLiteHasClass,
      css: function(element, name, value) {
        name = camelCase(name);
        if (isDefined(value)) {
          element.style[name] = value;
        } else {
          return element.style[name];
        }
      },
      attr: function(element, name, value) {
        var nodeType = element.nodeType;
        if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
          return;
        }
        var lowercasedName = lowercase(name);
        if (BOOLEAN_ATTR[lowercasedName]) {
          if (isDefined(value)) {
            if (!!value) {
              element[name] = true;
              element.setAttribute(name, lowercasedName);
            } else {
              element[name] = false;
              element.removeAttribute(lowercasedName);
            }
          } else {
            return (element[name] || (element.attributes.getNamedItem(name) || noop).specified) ? lowercasedName : undefined;
          }
        } else if (isDefined(value)) {
          element.setAttribute(name, value);
        } else if (element.getAttribute) {
          var ret = element.getAttribute(name, 2);
          return ret === null ? undefined : ret;
        }
      },
      prop: function(element, name, value) {
        if (isDefined(value)) {
          element[name] = value;
        } else {
          return element[name];
        }
      },
      text: (function() {
        getText.$dv = '';
        return getText;
        function getText(element, value) {
          if (isUndefined(value)) {
            var nodeType = element.nodeType;
            return (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT) ? element.textContent : '';
          }
          element.textContent = value;
        }
      })(),
      val: function(element, value) {
        if (isUndefined(value)) {
          if (element.multiple && nodeName_(element) === 'select') {
            var result = [];
            forEach(element.options, function(option) {
              if (option.selected) {
                result.push(option.value || option.text);
              }
            });
            return result.length === 0 ? null : result;
          }
          return element.value;
        }
        element.value = value;
      },
      html: function(element, value) {
        if (isUndefined(value)) {
          return element.innerHTML;
        }
        jqLiteDealoc(element, true);
        element.innerHTML = value;
      },
      empty: jqLiteEmpty
    }, function(fn, name) {
      JQLite.prototype[name] = function(arg1, arg2) {
        var i,
            key;
        var nodeCount = this.length;
        if (fn !== jqLiteEmpty && (((fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController)) ? arg1 : arg2) === undefined)) {
          if (isObject(arg1)) {
            for (i = 0; i < nodeCount; i++) {
              if (fn === jqLiteData) {
                fn(this[i], arg1);
              } else {
                for (key in arg1) {
                  fn(this[i], key, arg1[key]);
                }
              }
            }
            return this;
          } else {
            var value = fn.$dv;
            var jj = (value === undefined) ? Math.min(nodeCount, 1) : nodeCount;
            for (var j = 0; j < jj; j++) {
              var nodeValue = fn(this[j], arg1, arg2);
              value = value ? value + nodeValue : nodeValue;
            }
            return value;
          }
        } else {
          for (i = 0; i < nodeCount; i++) {
            fn(this[i], arg1, arg2);
          }
          return this;
        }
      };
    });
    function createEventHandler(element, events) {
      var eventHandler = function(event, type) {
        event.isDefaultPrevented = function() {
          return event.defaultPrevented;
        };
        var eventFns = events[type || event.type];
        var eventFnsLength = eventFns ? eventFns.length : 0;
        if (!eventFnsLength)
          return;
        if (isUndefined(event.immediatePropagationStopped)) {
          var originalStopImmediatePropagation = event.stopImmediatePropagation;
          event.stopImmediatePropagation = function() {
            event.immediatePropagationStopped = true;
            if (event.stopPropagation) {
              event.stopPropagation();
            }
            if (originalStopImmediatePropagation) {
              originalStopImmediatePropagation.call(event);
            }
          };
        }
        event.isImmediatePropagationStopped = function() {
          return event.immediatePropagationStopped === true;
        };
        if ((eventFnsLength > 1)) {
          eventFns = shallowCopy(eventFns);
        }
        for (var i = 0; i < eventFnsLength; i++) {
          if (!event.isImmediatePropagationStopped()) {
            eventFns[i].call(element, event);
          }
        }
      };
      eventHandler.elem = element;
      return eventHandler;
    }
    forEach({
      removeData: jqLiteRemoveData,
      on: function jqLiteOn(element, type, fn, unsupported) {
        if (isDefined(unsupported))
          throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
        if (!jqLiteAcceptsData(element)) {
          return;
        }
        var expandoStore = jqLiteExpandoStore(element, true);
        var events = expandoStore.events;
        var handle = expandoStore.handle;
        if (!handle) {
          handle = expandoStore.handle = createEventHandler(element, events);
        }
        var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
        var i = types.length;
        while (i--) {
          type = types[i];
          var eventFns = events[type];
          if (!eventFns) {
            events[type] = [];
            if (type === 'mouseenter' || type === 'mouseleave') {
              jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                var target = this,
                    related = event.relatedTarget;
                if (!related || (related !== target && !target.contains(related))) {
                  handle(event, type);
                }
              });
            } else {
              if (type !== '$destroy') {
                addEventListenerFn(element, type, handle);
              }
            }
            eventFns = events[type];
          }
          eventFns.push(fn);
        }
      },
      off: jqLiteOff,
      one: function(element, type, fn) {
        element = jqLite(element);
        element.on(type, function onFn() {
          element.off(type, fn);
          element.off(type, onFn);
        });
        element.on(type, fn);
      },
      replaceWith: function(element, replaceNode) {
        var index,
            parent = element.parentNode;
        jqLiteDealoc(element);
        forEach(new JQLite(replaceNode), function(node) {
          if (index) {
            parent.insertBefore(node, index.nextSibling);
          } else {
            parent.replaceChild(node, element);
          }
          index = node;
        });
      },
      children: function(element) {
        var children = [];
        forEach(element.childNodes, function(element) {
          if (element.nodeType === NODE_TYPE_ELEMENT) {
            children.push(element);
          }
        });
        return children;
      },
      contents: function(element) {
        return element.contentDocument || element.childNodes || [];
      },
      append: function(element, node) {
        var nodeType = element.nodeType;
        if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
          return;
        node = new JQLite(node);
        for (var i = 0,
            ii = node.length; i < ii; i++) {
          var child = node[i];
          element.appendChild(child);
        }
      },
      prepend: function(element, node) {
        if (element.nodeType === NODE_TYPE_ELEMENT) {
          var index = element.firstChild;
          forEach(new JQLite(node), function(child) {
            element.insertBefore(child, index);
          });
        }
      },
      wrap: function(element, wrapNode) {
        wrapNode = jqLite(wrapNode).eq(0).clone()[0];
        var parent = element.parentNode;
        if (parent) {
          parent.replaceChild(wrapNode, element);
        }
        wrapNode.appendChild(element);
      },
      remove: jqLiteRemove,
      detach: function(element) {
        jqLiteRemove(element, true);
      },
      after: function(element, newElement) {
        var index = element,
            parent = element.parentNode;
        newElement = new JQLite(newElement);
        for (var i = 0,
            ii = newElement.length; i < ii; i++) {
          var node = newElement[i];
          parent.insertBefore(node, index.nextSibling);
          index = node;
        }
      },
      addClass: jqLiteAddClass,
      removeClass: jqLiteRemoveClass,
      toggleClass: function(element, selector, condition) {
        if (selector) {
          forEach(selector.split(' '), function(className) {
            var classCondition = condition;
            if (isUndefined(classCondition)) {
              classCondition = !jqLiteHasClass(element, className);
            }
            (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
          });
        }
      },
      parent: function(element) {
        var parent = element.parentNode;
        return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
      },
      next: function(element) {
        return element.nextElementSibling;
      },
      find: function(element, selector) {
        if (element.getElementsByTagName) {
          return element.getElementsByTagName(selector);
        } else {
          return [];
        }
      },
      clone: jqLiteClone,
      triggerHandler: function(element, event, extraParameters) {
        var dummyEvent,
            eventFnsCopy,
            handlerArgs;
        var eventName = event.type || event;
        var expandoStore = jqLiteExpandoStore(element);
        var events = expandoStore && expandoStore.events;
        var eventFns = events && events[eventName];
        if (eventFns) {
          dummyEvent = {
            preventDefault: function() {
              this.defaultPrevented = true;
            },
            isDefaultPrevented: function() {
              return this.defaultPrevented === true;
            },
            stopImmediatePropagation: function() {
              this.immediatePropagationStopped = true;
            },
            isImmediatePropagationStopped: function() {
              return this.immediatePropagationStopped === true;
            },
            stopPropagation: noop,
            type: eventName,
            target: element
          };
          if (event.type) {
            dummyEvent = extend(dummyEvent, event);
          }
          eventFnsCopy = shallowCopy(eventFns);
          handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
          forEach(eventFnsCopy, function(fn) {
            if (!dummyEvent.isImmediatePropagationStopped()) {
              fn.apply(element, handlerArgs);
            }
          });
        }
      }
    }, function(fn, name) {
      JQLite.prototype[name] = function(arg1, arg2, arg3) {
        var value;
        for (var i = 0,
            ii = this.length; i < ii; i++) {
          if (isUndefined(value)) {
            value = fn(this[i], arg1, arg2, arg3);
            if (isDefined(value)) {
              value = jqLite(value);
            }
          } else {
            jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
          }
        }
        return isDefined(value) ? value : this;
      };
      JQLite.prototype.bind = JQLite.prototype.on;
      JQLite.prototype.unbind = JQLite.prototype.off;
    });
    function $$jqLiteProvider() {
      this.$get = function $$jqLite() {
        return extend(JQLite, {
          hasClass: function(node, classes) {
            if (node.attr)
              node = node[0];
            return jqLiteHasClass(node, classes);
          },
          addClass: function(node, classes) {
            if (node.attr)
              node = node[0];
            return jqLiteAddClass(node, classes);
          },
          removeClass: function(node, classes) {
            if (node.attr)
              node = node[0];
            return jqLiteRemoveClass(node, classes);
          }
        });
      };
    }
    function hashKey(obj, nextUidFn) {
      var key = obj && obj.$$hashKey;
      if (key) {
        if (typeof key === 'function') {
          key = obj.$$hashKey();
        }
        return key;
      }
      var objType = typeof obj;
      if (objType == 'function' || (objType == 'object' && obj !== null)) {
        key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
      } else {
        key = objType + ':' + obj;
      }
      return key;
    }
    function HashMap(array, isolatedUid) {
      if (isolatedUid) {
        var uid = 0;
        this.nextUid = function() {
          return ++uid;
        };
      }
      forEach(array, this.put, this);
    }
    HashMap.prototype = {
      put: function(key, value) {
        this[hashKey(key, this.nextUid)] = value;
      },
      get: function(key) {
        return this[hashKey(key, this.nextUid)];
      },
      remove: function(key) {
        var value = this[key = hashKey(key, this.nextUid)];
        delete this[key];
        return value;
      }
    };
    var $$HashMapProvider = [function() {
      this.$get = [function() {
        return HashMap;
      }];
    }];
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    var $injectorMinErr = minErr('$injector');
    function anonFn(fn) {
      var fnText = fn.toString().replace(STRIP_COMMENTS, ''),
          args = fnText.match(FN_ARGS);
      if (args) {
        return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
      }
      return 'fn';
    }
    function annotate(fn, strictDi, name) {
      var $inject,
          fnText,
          argDecl,
          last;
      if (typeof fn === 'function') {
        if (!($inject = fn.$inject)) {
          $inject = [];
          if (fn.length) {
            if (strictDi) {
              if (!isString(name) || !name) {
                name = fn.name || anonFn(fn);
              }
              throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
            }
            fnText = fn.toString().replace(STRIP_COMMENTS, '');
            argDecl = fnText.match(FN_ARGS);
            forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
              arg.replace(FN_ARG, function(all, underscore, name) {
                $inject.push(name);
              });
            });
          }
          fn.$inject = $inject;
        }
      } else if (isArray(fn)) {
        last = fn.length - 1;
        assertArgFn(fn[last], 'fn');
        $inject = fn.slice(0, last);
      } else {
        assertArgFn(fn, 'fn', true);
      }
      return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
      strictDi = (strictDi === true);
      var INSTANTIATING = {},
          providerSuffix = 'Provider',
          path = [],
          loadedModules = new HashMap([], true),
          providerCache = {$provide: {
              provider: supportObject(provider),
              factory: supportObject(factory),
              service: supportObject(service),
              value: supportObject(value),
              constant: supportObject(constant),
              decorator: decorator
            }},
          providerInjector = (providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            if (angular.isString(caller)) {
              path.push(caller);
            }
            throw $injectorMinErr('unpr', "Unknown provider: {0}", path.join(' <- '));
          })),
          instanceCache = {},
          instanceInjector = (instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
          }));
      forEach(loadModules(modulesToLoad), function(fn) {
        if (fn)
          instanceInjector.invoke(fn);
      });
      return instanceInjector;
      function supportObject(delegate) {
        return function(key, value) {
          if (isObject(key)) {
            forEach(key, reverseParams(delegate));
          } else {
            return delegate(key, value);
          }
        };
      }
      function provider(name, provider_) {
        assertNotHasOwnProperty(name, 'service');
        if (isFunction(provider_) || isArray(provider_)) {
          provider_ = providerInjector.instantiate(provider_);
        }
        if (!provider_.$get) {
          throw $injectorMinErr('pget', "Provider '{0}' must define $get factory method.", name);
        }
        return providerCache[name + providerSuffix] = provider_;
      }
      function enforceReturnValue(name, factory) {
        return function enforcedReturnValue() {
          var result = instanceInjector.invoke(factory, this);
          if (isUndefined(result)) {
            throw $injectorMinErr('undef', "Provider '{0}' must return a value from $get factory method.", name);
          }
          return result;
        };
      }
      function factory(name, factoryFn, enforce) {
        return provider(name, {$get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn});
      }
      function service(name, constructor) {
        return factory(name, ['$injector', function($injector) {
          return $injector.instantiate(constructor);
        }]);
      }
      function value(name, val) {
        return factory(name, valueFn(val), false);
      }
      function constant(name, value) {
        assertNotHasOwnProperty(name, 'constant');
        providerCache[name] = value;
        instanceCache[name] = value;
      }
      function decorator(serviceName, decorFn) {
        var origProvider = providerInjector.get(serviceName + providerSuffix),
            orig$get = origProvider.$get;
        origProvider.$get = function() {
          var origInstance = instanceInjector.invoke(orig$get, origProvider);
          return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
        };
      }
      function loadModules(modulesToLoad) {
        var runBlocks = [],
            moduleFn;
        forEach(modulesToLoad, function(module) {
          if (loadedModules.get(module))
            return;
          loadedModules.put(module, true);
          function runInvokeQueue(queue) {
            var i,
                ii;
            for (i = 0, ii = queue.length; i < ii; i++) {
              var invokeArgs = queue[i],
                  provider = providerInjector.get(invokeArgs[0]);
              provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
            }
          }
          try {
            if (isString(module)) {
              moduleFn = angularModule(module);
              runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
              runInvokeQueue(moduleFn._invokeQueue);
              runInvokeQueue(moduleFn._configBlocks);
            } else if (isFunction(module)) {
              runBlocks.push(providerInjector.invoke(module));
            } else if (isArray(module)) {
              runBlocks.push(providerInjector.invoke(module));
            } else {
              assertArgFn(module, 'module');
            }
          } catch (e) {
            if (isArray(module)) {
              module = module[module.length - 1];
            }
            if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
              e = e.message + '\n' + e.stack;
            }
            throw $injectorMinErr('modulerr', "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
          }
        });
        return runBlocks;
      }
      function createInternalInjector(cache, factory) {
        function getService(serviceName, caller) {
          if (cache.hasOwnProperty(serviceName)) {
            if (cache[serviceName] === INSTANTIATING) {
              throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
            }
            return cache[serviceName];
          } else {
            try {
              path.unshift(serviceName);
              cache[serviceName] = INSTANTIATING;
              return cache[serviceName] = factory(serviceName, caller);
            } catch (err) {
              if (cache[serviceName] === INSTANTIATING) {
                delete cache[serviceName];
              }
              throw err;
            } finally {
              path.shift();
            }
          }
        }
        function invoke(fn, self, locals, serviceName) {
          if (typeof locals === 'string') {
            serviceName = locals;
            locals = null;
          }
          var args = [],
              $inject = createInjector.$$annotate(fn, strictDi, serviceName),
              length,
              i,
              key;
          for (i = 0, length = $inject.length; i < length; i++) {
            key = $inject[i];
            if (typeof key !== 'string') {
              throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
            }
            args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
          }
          if (isArray(fn)) {
            fn = fn[length];
          }
          return fn.apply(self, args);
        }
        function instantiate(Type, locals, serviceName) {
          var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null);
          var returnedValue = invoke(Type, instance, locals, serviceName);
          return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
        }
        return {
          invoke: invoke,
          instantiate: instantiate,
          get: getService,
          annotate: createInjector.$$annotate,
          has: function(name) {
            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
          }
        };
      }
    }
    createInjector.$$annotate = annotate;
    function $AnchorScrollProvider() {
      var autoScrollingEnabled = true;
      this.disableAutoScrolling = function() {
        autoScrollingEnabled = false;
      };
      this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
        var document = $window.document;
        function getFirstAnchor(list) {
          var result = null;
          Array.prototype.some.call(list, function(element) {
            if (nodeName_(element) === 'a') {
              result = element;
              return true;
            }
          });
          return result;
        }
        function getYOffset() {
          var offset = scroll.yOffset;
          if (isFunction(offset)) {
            offset = offset();
          } else if (isElement(offset)) {
            var elem = offset[0];
            var style = $window.getComputedStyle(elem);
            if (style.position !== 'fixed') {
              offset = 0;
            } else {
              offset = elem.getBoundingClientRect().bottom;
            }
          } else if (!isNumber(offset)) {
            offset = 0;
          }
          return offset;
        }
        function scrollTo(elem) {
          if (elem) {
            elem.scrollIntoView();
            var offset = getYOffset();
            if (offset) {
              var elemTop = elem.getBoundingClientRect().top;
              $window.scrollBy(0, elemTop - offset);
            }
          } else {
            $window.scrollTo(0, 0);
          }
        }
        function scroll(hash) {
          hash = isString(hash) ? hash : $location.hash();
          var elm;
          if (!hash)
            scrollTo(null);
          else if ((elm = document.getElementById(hash)))
            scrollTo(elm);
          else if ((elm = getFirstAnchor(document.getElementsByName(hash))))
            scrollTo(elm);
          else if (hash === 'top')
            scrollTo(null);
        }
        if (autoScrollingEnabled) {
          $rootScope.$watch(function autoScrollWatch() {
            return $location.hash();
          }, function autoScrollWatchAction(newVal, oldVal) {
            if (newVal === oldVal && newVal === '')
              return;
            jqLiteDocumentLoaded(function() {
              $rootScope.$evalAsync(scroll);
            });
          });
        }
        return scroll;
      }];
    }
    var $animateMinErr = minErr('$animate');
    var ELEMENT_NODE = 1;
    var NG_ANIMATE_CLASSNAME = 'ng-animate';
    function mergeClasses(a, b) {
      if (!a && !b)
        return '';
      if (!a)
        return b;
      if (!b)
        return a;
      if (isArray(a))
        a = a.join(' ');
      if (isArray(b))
        b = b.join(' ');
      return a + ' ' + b;
    }
    function extractElementNode(element) {
      for (var i = 0; i < element.length; i++) {
        var elm = element[i];
        if (elm.nodeType === ELEMENT_NODE) {
          return elm;
        }
      }
    }
    function splitClasses(classes) {
      if (isString(classes)) {
        classes = classes.split(' ');
      }
      var obj = createMap();
      forEach(classes, function(klass) {
        if (klass.length) {
          obj[klass] = true;
        }
      });
      return obj;
    }
    function prepareAnimateOptions(options) {
      return isObject(options) ? options : {};
    }
    var $$CoreAnimateRunnerProvider = function() {
      this.$get = ['$q', '$$rAF', function($q, $$rAF) {
        function AnimateRunner() {}
        AnimateRunner.all = noop;
        AnimateRunner.chain = noop;
        AnimateRunner.prototype = {
          end: noop,
          cancel: noop,
          resume: noop,
          pause: noop,
          complete: noop,
          then: function(pass, fail) {
            return $q(function(resolve) {
              $$rAF(function() {
                resolve();
              });
            }).then(pass, fail);
          }
        };
        return AnimateRunner;
      }];
    };
    var $$CoreAnimateQueueProvider = function() {
      var postDigestQueue = new HashMap();
      var postDigestElements = [];
      this.$get = ['$$AnimateRunner', '$rootScope', function($$AnimateRunner, $rootScope) {
        return {
          enabled: noop,
          on: noop,
          off: noop,
          pin: noop,
          push: function(element, event, options, domOperation) {
            domOperation && domOperation();
            options = options || {};
            options.from && element.css(options.from);
            options.to && element.css(options.to);
            if (options.addClass || options.removeClass) {
              addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
            }
            return new $$AnimateRunner();
          }
        };
        function addRemoveClassesPostDigest(element, add, remove) {
          var data = postDigestQueue.get(element);
          var classVal;
          if (!data) {
            postDigestQueue.put(element, data = {});
            postDigestElements.push(element);
          }
          if (add) {
            forEach(add.split(' '), function(className) {
              if (className) {
                data[className] = true;
              }
            });
          }
          if (remove) {
            forEach(remove.split(' '), function(className) {
              if (className) {
                data[className] = false;
              }
            });
          }
          if (postDigestElements.length > 1)
            return;
          $rootScope.$$postDigest(function() {
            forEach(postDigestElements, function(element) {
              var data = postDigestQueue.get(element);
              if (data) {
                var existing = splitClasses(element.attr('class'));
                var toAdd = '';
                var toRemove = '';
                forEach(data, function(status, className) {
                  var hasClass = !!existing[className];
                  if (status !== hasClass) {
                    if (status) {
                      toAdd += (toAdd.length ? ' ' : '') + className;
                    } else {
                      toRemove += (toRemove.length ? ' ' : '') + className;
                    }
                  }
                });
                forEach(element, function(elm) {
                  toAdd && jqLiteAddClass(elm, toAdd);
                  toRemove && jqLiteRemoveClass(elm, toRemove);
                });
                postDigestQueue.remove(element);
              }
            });
            postDigestElements.length = 0;
          });
        }
      }];
    };
    var $AnimateProvider = ['$provide', function($provide) {
      var provider = this;
      this.$$registeredAnimations = Object.create(null);
      this.register = function(name, factory) {
        if (name && name.charAt(0) !== '.') {
          throw $animateMinErr('notcsel', "Expecting class selector starting with '.' got '{0}'.", name);
        }
        var key = name + '-animation';
        provider.$$registeredAnimations[name.substr(1)] = key;
        $provide.factory(key, factory);
      };
      this.classNameFilter = function(expression) {
        if (arguments.length === 1) {
          this.$$classNameFilter = (expression instanceof RegExp) ? expression : null;
          if (this.$$classNameFilter) {
            var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
            if (reservedRegex.test(this.$$classNameFilter.toString())) {
              throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
            }
          }
        }
        return this.$$classNameFilter;
      };
      this.$get = ['$$animateQueue', function($$animateQueue) {
        function domInsert(element, parentElement, afterElement) {
          if (afterElement) {
            var afterNode = extractElementNode(afterElement);
            if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
              afterElement = null;
            }
          }
          afterElement ? afterElement.after(element) : parentElement.prepend(element);
        }
        return {
          on: $$animateQueue.on,
          off: $$animateQueue.off,
          pin: $$animateQueue.pin,
          enabled: $$animateQueue.enabled,
          cancel: function(runner) {
            runner.end && runner.end();
          },
          enter: function(element, parent, after, options) {
            parent = parent && jqLite(parent);
            after = after && jqLite(after);
            parent = parent || after.parent();
            domInsert(element, parent, after);
            return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
          },
          move: function(element, parent, after, options) {
            parent = parent && jqLite(parent);
            after = after && jqLite(after);
            parent = parent || after.parent();
            domInsert(element, parent, after);
            return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
          },
          leave: function(element, options) {
            return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function() {
              element.remove();
            });
          },
          addClass: function(element, className, options) {
            options = prepareAnimateOptions(options);
            options.addClass = mergeClasses(options.addclass, className);
            return $$animateQueue.push(element, 'addClass', options);
          },
          removeClass: function(element, className, options) {
            options = prepareAnimateOptions(options);
            options.removeClass = mergeClasses(options.removeClass, className);
            return $$animateQueue.push(element, 'removeClass', options);
          },
          setClass: function(element, add, remove, options) {
            options = prepareAnimateOptions(options);
            options.addClass = mergeClasses(options.addClass, add);
            options.removeClass = mergeClasses(options.removeClass, remove);
            return $$animateQueue.push(element, 'setClass', options);
          },
          animate: function(element, from, to, className, options) {
            options = prepareAnimateOptions(options);
            options.from = options.from ? extend(options.from, from) : from;
            options.to = options.to ? extend(options.to, to) : to;
            className = className || 'ng-inline-animate';
            options.tempClasses = mergeClasses(options.tempClasses, className);
            return $$animateQueue.push(element, 'animate', options);
          }
        };
      }];
    }];
    function $$AsyncCallbackProvider() {
      this.$get = ['$$rAF', '$timeout', function($$rAF, $timeout) {
        return $$rAF.supported ? function(fn) {
          return $$rAF(fn);
        } : function(fn) {
          return $timeout(fn, 0, false);
        };
      }];
    }
    function Browser(window, document, $log, $sniffer) {
      var self = this,
          rawDocument = document[0],
          location = window.location,
          history = window.history,
          setTimeout = window.setTimeout,
          clearTimeout = window.clearTimeout,
          pendingDeferIds = {};
      self.isMock = false;
      var outstandingRequestCount = 0;
      var outstandingRequestCallbacks = [];
      self.$$completeOutstandingRequest = completeOutstandingRequest;
      self.$$incOutstandingRequestCount = function() {
        outstandingRequestCount++;
      };
      function completeOutstandingRequest(fn) {
        try {
          fn.apply(null, sliceArgs(arguments, 1));
        } finally {
          outstandingRequestCount--;
          if (outstandingRequestCount === 0) {
            while (outstandingRequestCallbacks.length) {
              try {
                outstandingRequestCallbacks.pop()();
              } catch (e) {
                $log.error(e);
              }
            }
          }
        }
      }
      function getHash(url) {
        var index = url.indexOf('#');
        return index === -1 ? '' : url.substr(index);
      }
      self.notifyWhenNoOutstandingRequests = function(callback) {
        if (outstandingRequestCount === 0) {
          callback();
        } else {
          outstandingRequestCallbacks.push(callback);
        }
      };
      var cachedState,
          lastHistoryState,
          lastBrowserUrl = location.href,
          baseElement = document.find('base'),
          reloadLocation = null;
      cacheState();
      lastHistoryState = cachedState;
      self.url = function(url, replace, state) {
        if (isUndefined(state)) {
          state = null;
        }
        if (location !== window.location)
          location = window.location;
        if (history !== window.history)
          history = window.history;
        if (url) {
          var sameState = lastHistoryState === state;
          if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
            return self;
          }
          var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
          lastBrowserUrl = url;
          lastHistoryState = state;
          if ($sniffer.history && (!sameBase || !sameState)) {
            history[replace ? 'replaceState' : 'pushState'](state, '', url);
            cacheState();
            lastHistoryState = cachedState;
          } else {
            if (!sameBase || reloadLocation) {
              reloadLocation = url;
            }
            if (replace) {
              location.replace(url);
            } else if (!sameBase) {
              location.href = url;
            } else {
              location.hash = getHash(url);
            }
          }
          return self;
        } else {
          return reloadLocation || location.href.replace(/%27/g, "'");
        }
      };
      self.state = function() {
        return cachedState;
      };
      var urlChangeListeners = [],
          urlChangeInit = false;
      function cacheStateAndFireUrlChange() {
        cacheState();
        fireUrlChange();
      }
      function getCurrentState() {
        try {
          return history.state;
        } catch (e) {}
      }
      var lastCachedState = null;
      function cacheState() {
        cachedState = getCurrentState();
        cachedState = isUndefined(cachedState) ? null : cachedState;
        if (equals(cachedState, lastCachedState)) {
          cachedState = lastCachedState;
        }
        lastCachedState = cachedState;
      }
      function fireUrlChange() {
        if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
          return;
        }
        lastBrowserUrl = self.url();
        lastHistoryState = cachedState;
        forEach(urlChangeListeners, function(listener) {
          listener(self.url(), cachedState);
        });
      }
      self.onUrlChange = function(callback) {
        if (!urlChangeInit) {
          if ($sniffer.history)
            jqLite(window).on('popstate', cacheStateAndFireUrlChange);
          jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
          urlChangeInit = true;
        }
        urlChangeListeners.push(callback);
        return callback;
      };
      self.$$applicationDestroyed = function() {
        jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
      };
      self.$$checkUrlChange = fireUrlChange;
      self.baseHref = function() {
        var href = baseElement.attr('href');
        return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
      };
      self.defer = function(fn, delay) {
        var timeoutId;
        outstandingRequestCount++;
        timeoutId = setTimeout(function() {
          delete pendingDeferIds[timeoutId];
          completeOutstandingRequest(fn);
        }, delay || 0);
        pendingDeferIds[timeoutId] = true;
        return timeoutId;
      };
      self.defer.cancel = function(deferId) {
        if (pendingDeferIds[deferId]) {
          delete pendingDeferIds[deferId];
          clearTimeout(deferId);
          completeOutstandingRequest(noop);
          return true;
        }
        return false;
      };
    }
    function $BrowserProvider() {
      this.$get = ['$window', '$log', '$sniffer', '$document', function($window, $log, $sniffer, $document) {
        return new Browser($window, $document, $log, $sniffer);
      }];
    }
    function $CacheFactoryProvider() {
      this.$get = function() {
        var caches = {};
        function cacheFactory(cacheId, options) {
          if (cacheId in caches) {
            throw minErr('$cacheFactory')('iid', "CacheId '{0}' is already taken!", cacheId);
          }
          var size = 0,
              stats = extend({}, options, {id: cacheId}),
              data = {},
              capacity = (options && options.capacity) || Number.MAX_VALUE,
              lruHash = {},
              freshEnd = null,
              staleEnd = null;
          return caches[cacheId] = {
            put: function(key, value) {
              if (isUndefined(value))
                return;
              if (capacity < Number.MAX_VALUE) {
                var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                refresh(lruEntry);
              }
              if (!(key in data))
                size++;
              data[key] = value;
              if (size > capacity) {
                this.remove(staleEnd.key);
              }
              return value;
            },
            get: function(key) {
              if (capacity < Number.MAX_VALUE) {
                var lruEntry = lruHash[key];
                if (!lruEntry)
                  return;
                refresh(lruEntry);
              }
              return data[key];
            },
            remove: function(key) {
              if (capacity < Number.MAX_VALUE) {
                var lruEntry = lruHash[key];
                if (!lruEntry)
                  return;
                if (lruEntry == freshEnd)
                  freshEnd = lruEntry.p;
                if (lruEntry == staleEnd)
                  staleEnd = lruEntry.n;
                link(lruEntry.n, lruEntry.p);
                delete lruHash[key];
              }
              delete data[key];
              size--;
            },
            removeAll: function() {
              data = {};
              size = 0;
              lruHash = {};
              freshEnd = staleEnd = null;
            },
            destroy: function() {
              data = null;
              stats = null;
              lruHash = null;
              delete caches[cacheId];
            },
            info: function() {
              return extend({}, stats, {size: size});
            }
          };
          function refresh(entry) {
            if (entry != freshEnd) {
              if (!staleEnd) {
                staleEnd = entry;
              } else if (staleEnd == entry) {
                staleEnd = entry.n;
              }
              link(entry.n, entry.p);
              link(entry, freshEnd);
              freshEnd = entry;
              freshEnd.n = null;
            }
          }
          function link(nextEntry, prevEntry) {
            if (nextEntry != prevEntry) {
              if (nextEntry)
                nextEntry.p = prevEntry;
              if (prevEntry)
                prevEntry.n = nextEntry;
            }
          }
        }
        cacheFactory.info = function() {
          var info = {};
          forEach(caches, function(cache, cacheId) {
            info[cacheId] = cache.info();
          });
          return info;
        };
        cacheFactory.get = function(cacheId) {
          return caches[cacheId];
        };
        return cacheFactory;
      };
    }
    function $TemplateCacheProvider() {
      this.$get = ['$cacheFactory', function($cacheFactory) {
        return $cacheFactory('templates');
      }];
    }
    var $compileMinErr = minErr('$compile');
    $CompileProvider.$inject = ['$provide', '$$sanitizeUriProvider'];
    function $CompileProvider($provide, $$sanitizeUriProvider) {
      var hasDirectives = {},
          Suffix = 'Directive',
          COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/,
          CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/,
          ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'),
          REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
      var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
      function parseIsolateBindings(scope, directiveName, isController) {
        var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/;
        var bindings = {};
        forEach(scope, function(definition, scopeName) {
          var match = definition.match(LOCAL_REGEXP);
          if (!match) {
            throw $compileMinErr('iscp', "Invalid {3} for directive '{0}'." + " Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, (isController ? "controller bindings definition" : "isolate scope definition"));
          }
          bindings[scopeName] = {
            mode: match[1][0],
            collection: match[2] === '*',
            optional: match[3] === '?',
            attrName: match[4] || scopeName
          };
        });
        return bindings;
      }
      function parseDirectiveBindings(directive, directiveName) {
        var bindings = {
          isolateScope: null,
          bindToController: null
        };
        if (isObject(directive.scope)) {
          if (directive.bindToController === true) {
            bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
            bindings.isolateScope = {};
          } else {
            bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
          }
        }
        if (isObject(directive.bindToController)) {
          bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
        }
        if (isObject(bindings.bindToController)) {
          var controller = directive.controller;
          var controllerAs = directive.controllerAs;
          if (!controller) {
            throw $compileMinErr('noctrl', "Cannot bind to controller without directive '{0}'s controller.", directiveName);
          } else if (!identifierForController(controller, controllerAs)) {
            throw $compileMinErr('noident', "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
          }
        }
        return bindings;
      }
      function assertValidDirectiveName(name) {
        var letter = name.charAt(0);
        if (!letter || letter !== lowercase(letter)) {
          throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
        }
        if (name !== name.trim()) {
          throw $compileMinErr('baddir', "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
        }
      }
      this.directive = function registerDirective(name, directiveFactory) {
        assertNotHasOwnProperty(name, 'directive');
        if (isString(name)) {
          assertValidDirectiveName(name);
          assertArg(directiveFactory, 'directiveFactory');
          if (!hasDirectives.hasOwnProperty(name)) {
            hasDirectives[name] = [];
            $provide.factory(name + Suffix, ['$injector', '$exceptionHandler', function($injector, $exceptionHandler) {
              var directives = [];
              forEach(hasDirectives[name], function(directiveFactory, index) {
                try {
                  var directive = $injector.invoke(directiveFactory);
                  if (isFunction(directive)) {
                    directive = {compile: valueFn(directive)};
                  } else if (!directive.compile && directive.link) {
                    directive.compile = valueFn(directive.link);
                  }
                  directive.priority = directive.priority || 0;
                  directive.index = index;
                  directive.name = directive.name || name;
                  directive.require = directive.require || (directive.controller && directive.name);
                  directive.restrict = directive.restrict || 'EA';
                  var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                  if (isObject(bindings.isolateScope)) {
                    directive.$$isolateBindings = bindings.isolateScope;
                  }
                  directive.$$moduleName = directiveFactory.$$moduleName;
                  directives.push(directive);
                } catch (e) {
                  $exceptionHandler(e);
                }
              });
              return directives;
            }]);
          }
          hasDirectives[name].push(directiveFactory);
        } else {
          forEach(name, reverseParams(registerDirective));
        }
        return this;
      };
      this.aHrefSanitizationWhitelist = function(regexp) {
        if (isDefined(regexp)) {
          $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
          return this;
        } else {
          return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }
      };
      this.imgSrcSanitizationWhitelist = function(regexp) {
        if (isDefined(regexp)) {
          $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
          return this;
        } else {
          return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        }
      };
      var debugInfoEnabled = true;
      this.debugInfoEnabled = function(enabled) {
        if (isDefined(enabled)) {
          debugInfoEnabled = enabled;
          return this;
        }
        return debugInfoEnabled;
      };
      this.$get = ['$injector', '$interpolate', '$exceptionHandler', '$templateRequest', '$parse', '$controller', '$rootScope', '$document', '$sce', '$animate', '$$sanitizeUri', function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
        var Attributes = function(element, attributesToCopy) {
          if (attributesToCopy) {
            var keys = Object.keys(attributesToCopy);
            var i,
                l,
                key;
            for (i = 0, l = keys.length; i < l; i++) {
              key = keys[i];
              this[key] = attributesToCopy[key];
            }
          } else {
            this.$attr = {};
          }
          this.$$element = element;
        };
        Attributes.prototype = {
          $normalize: directiveNormalize,
          $addClass: function(classVal) {
            if (classVal && classVal.length > 0) {
              $animate.addClass(this.$$element, classVal);
            }
          },
          $removeClass: function(classVal) {
            if (classVal && classVal.length > 0) {
              $animate.removeClass(this.$$element, classVal);
            }
          },
          $updateClass: function(newClasses, oldClasses) {
            var toAdd = tokenDifference(newClasses, oldClasses);
            if (toAdd && toAdd.length) {
              $animate.addClass(this.$$element, toAdd);
            }
            var toRemove = tokenDifference(oldClasses, newClasses);
            if (toRemove && toRemove.length) {
              $animate.removeClass(this.$$element, toRemove);
            }
          },
          $set: function(key, value, writeAttr, attrName) {
            var node = this.$$element[0],
                booleanKey = getBooleanAttrName(node, key),
                aliasedKey = getAliasedAttrName(node, key),
                observer = key,
                nodeName;
            if (booleanKey) {
              this.$$element.prop(key, value);
              attrName = booleanKey;
            } else if (aliasedKey) {
              this[aliasedKey] = value;
              observer = aliasedKey;
            }
            this[key] = value;
            if (attrName) {
              this.$attr[key] = attrName;
            } else {
              attrName = this.$attr[key];
              if (!attrName) {
                this.$attr[key] = attrName = snake_case(key, '-');
              }
            }
            nodeName = nodeName_(this.$$element);
            if ((nodeName === 'a' && key === 'href') || (nodeName === 'img' && key === 'src')) {
              this[key] = value = $$sanitizeUri(value, key === 'src');
            } else if (nodeName === 'img' && key === 'srcset') {
              var result = "";
              var trimmedSrcset = trim(value);
              var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
              var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
              var rawUris = trimmedSrcset.split(pattern);
              var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
              for (var i = 0; i < nbrUrisWith2parts; i++) {
                var innerIdx = i * 2;
                result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                result += (" " + trim(rawUris[innerIdx + 1]));
              }
              var lastTuple = trim(rawUris[i * 2]).split(/\s/);
              result += $$sanitizeUri(trim(lastTuple[0]), true);
              if (lastTuple.length === 2) {
                result += (" " + trim(lastTuple[1]));
              }
              this[key] = value = result;
            }
            if (writeAttr !== false) {
              if (value === null || value === undefined) {
                this.$$element.removeAttr(attrName);
              } else {
                this.$$element.attr(attrName, value);
              }
            }
            var $$observers = this.$$observers;
            $$observers && forEach($$observers[observer], function(fn) {
              try {
                fn(value);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
          },
          $observe: function(key, fn) {
            var attrs = this,
                $$observers = (attrs.$$observers || (attrs.$$observers = createMap())),
                listeners = ($$observers[key] || ($$observers[key] = []));
            listeners.push(fn);
            $rootScope.$evalAsync(function() {
              if (!listeners.$$inter && attrs.hasOwnProperty(key)) {
                fn(attrs[key]);
              }
            });
            return function() {
              arrayRemove(listeners, fn);
            };
          }
        };
        function safeAddClass($element, className) {
          try {
            $element.addClass(className);
          } catch (e) {}
        }
        var startSymbol = $interpolate.startSymbol(),
            endSymbol = $interpolate.endSymbol(),
            denormalizeTemplate = (startSymbol == '{{' || endSymbol == '}}') ? identity : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            },
            NG_ATTR_BINDING = /^ngAttr[A-Z]/;
        compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
          var bindings = $element.data('$binding') || [];
          if (isArray(binding)) {
            bindings = bindings.concat(binding);
          } else {
            bindings.push(binding);
          }
          $element.data('$binding', bindings);
        } : noop;
        compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
          safeAddClass($element, 'ng-binding');
        } : noop;
        compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
          var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
          $element.data(dataName, scope);
        } : noop;
        compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
          safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
        } : noop;
        return compile;
        function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
          if (!($compileNodes instanceof jqLite)) {
            $compileNodes = jqLite($compileNodes);
          }
          forEach($compileNodes, function(node, index) {
            if (node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/)) {
              $compileNodes[index] = jqLite(node).wrap('<span></span>').parent()[0];
            }
          });
          var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
          compile.$$addScopeClass($compileNodes);
          var namespace = null;
          return function publicLinkFn(scope, cloneConnectFn, options) {
            assertArg(scope, 'scope');
            options = options || {};
            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                transcludeControllers = options.transcludeControllers,
                futureParentElement = options.futureParentElement;
            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
              parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
            }
            if (!namespace) {
              namespace = detectNamespaceForChildElements(futureParentElement);
            }
            var $linkNode;
            if (namespace !== 'html') {
              $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
            } else if (cloneConnectFn) {
              $linkNode = JQLitePrototype.clone.call($compileNodes);
            } else {
              $linkNode = $compileNodes;
            }
            if (transcludeControllers) {
              for (var controllerName in transcludeControllers) {
                $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
              }
            }
            compile.$$addScopeInfo($linkNode, scope);
            if (cloneConnectFn)
              cloneConnectFn($linkNode, scope);
            if (compositeLinkFn)
              compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
            return $linkNode;
          };
        }
        function detectNamespaceForChildElements(parentElement) {
          var node = parentElement && parentElement[0];
          if (!node) {
            return 'html';
          } else {
            return nodeName_(node) !== 'foreignobject' && node.toString().match(/SVG/) ? 'svg' : 'html';
          }
        }
        function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
          var linkFns = [],
              attrs,
              directives,
              nodeLinkFn,
              childNodes,
              childLinkFn,
              linkFnFound,
              nodeLinkFnFound;
          for (var i = 0; i < nodeList.length; i++) {
            attrs = new Attributes();
            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
            nodeLinkFn = (directives.length) ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
            if (nodeLinkFn && nodeLinkFn.scope) {
              compile.$$addScopeClass(attrs.$$element);
            }
            childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length) ? null : compileNodes(childNodes, nodeLinkFn ? ((nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude) : transcludeFn);
            if (nodeLinkFn || childLinkFn) {
              linkFns.push(i, nodeLinkFn, childLinkFn);
              linkFnFound = true;
              nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
            }
            previousCompileContext = null;
          }
          return linkFnFound ? compositeLinkFn : null;
          function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
            var nodeLinkFn,
                childLinkFn,
                node,
                childScope,
                i,
                ii,
                idx,
                childBoundTranscludeFn;
            var stableNodeList;
            if (nodeLinkFnFound) {
              var nodeListLength = nodeList.length;
              stableNodeList = new Array(nodeListLength);
              for (i = 0; i < linkFns.length; i += 3) {
                idx = linkFns[i];
                stableNodeList[idx] = nodeList[idx];
              }
            } else {
              stableNodeList = nodeList;
            }
            for (i = 0, ii = linkFns.length; i < ii; ) {
              node = stableNodeList[linkFns[i++]];
              nodeLinkFn = linkFns[i++];
              childLinkFn = linkFns[i++];
              if (nodeLinkFn) {
                if (nodeLinkFn.scope) {
                  childScope = scope.$new();
                  compile.$$addScopeInfo(jqLite(node), childScope);
                  var destroyBindings = nodeLinkFn.$$destroyBindings;
                  if (destroyBindings) {
                    nodeLinkFn.$$destroyBindings = null;
                    childScope.$on('$destroyed', destroyBindings);
                  }
                } else {
                  childScope = scope;
                }
                if (nodeLinkFn.transcludeOnThisElement) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                  childBoundTranscludeFn = parentBoundTranscludeFn;
                } else if (!parentBoundTranscludeFn && transcludeFn) {
                  childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                } else {
                  childBoundTranscludeFn = null;
                }
                nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
              } else if (childLinkFn) {
                childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
              }
            }
          }
        }
        function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
          var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
            if (!transcludedScope) {
              transcludedScope = scope.$new(false, containingScope);
              transcludedScope.$$transcluded = true;
            }
            return transcludeFn(transcludedScope, cloneFn, {
              parentBoundTranscludeFn: previousBoundTranscludeFn,
              transcludeControllers: controllers,
              futureParentElement: futureParentElement
            });
          };
          return boundTranscludeFn;
        }
        function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
          var nodeType = node.nodeType,
              attrsMap = attrs.$attr,
              match,
              className;
          switch (nodeType) {
            case NODE_TYPE_ELEMENT:
              addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
              for (var attr,
                  name,
                  nName,
                  ngAttrName,
                  value,
                  isNgAttr,
                  nAttrs = node.attributes,
                  j = 0,
                  jj = nAttrs && nAttrs.length; j < jj; j++) {
                var attrStartName = false;
                var attrEndName = false;
                attr = nAttrs[j];
                name = attr.name;
                value = trim(attr.value);
                ngAttrName = directiveNormalize(name);
                if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                  name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function(match, letter) {
                    return letter.toUpperCase();
                  });
                }
                var directiveNName = ngAttrName.replace(/(Start|End)$/, '');
                if (directiveIsMultiElement(directiveNName)) {
                  if (ngAttrName === directiveNName + 'Start') {
                    attrStartName = name;
                    attrEndName = name.substr(0, name.length - 5) + 'end';
                    name = name.substr(0, name.length - 6);
                  }
                }
                nName = directiveNormalize(name.toLowerCase());
                attrsMap[nName] = name;
                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                  attrs[nName] = value;
                  if (getBooleanAttrName(node, nName)) {
                    attrs[nName] = true;
                  }
                }
                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
              }
              className = node.className;
              if (isObject(className)) {
                className = className.animVal;
              }
              if (isString(className) && className !== '') {
                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                  nName = directiveNormalize(match[2]);
                  if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                    attrs[nName] = trim(match[3]);
                  }
                  className = className.substr(match.index + match[0].length);
                }
              }
              break;
            case NODE_TYPE_TEXT:
              if (msie === 11) {
                while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                  node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                  node.parentNode.removeChild(node.nextSibling);
                }
              }
              addTextInterpolateDirective(directives, node.nodeValue);
              break;
            case NODE_TYPE_COMMENT:
              try {
                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                if (match) {
                  nName = directiveNormalize(match[1]);
                  if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                    attrs[nName] = trim(match[2]);
                  }
                }
              } catch (e) {}
              break;
          }
          directives.sort(byPriority);
          return directives;
        }
        function groupScan(node, attrStart, attrEnd) {
          var nodes = [];
          var depth = 0;
          if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
            do {
              if (!node) {
                throw $compileMinErr('uterdir', "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
              }
              if (node.nodeType == NODE_TYPE_ELEMENT) {
                if (node.hasAttribute(attrStart))
                  depth++;
                if (node.hasAttribute(attrEnd))
                  depth--;
              }
              nodes.push(node);
              node = node.nextSibling;
            } while (depth > 0);
          } else {
            nodes.push(node);
          }
          return jqLite(nodes);
        }
        function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
          return function(scope, element, attrs, controllers, transcludeFn) {
            element = groupScan(element[0], attrStart, attrEnd);
            return linkFn(scope, element, attrs, controllers, transcludeFn);
          };
        }
        function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
          previousCompileContext = previousCompileContext || {};
          var terminalPriority = -Number.MAX_VALUE,
              newScopeDirective = previousCompileContext.newScopeDirective,
              controllerDirectives = previousCompileContext.controllerDirectives,
              newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective,
              templateDirective = previousCompileContext.templateDirective,
              nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective,
              hasTranscludeDirective = false,
              hasTemplate = false,
              hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective,
              $compileNode = templateAttrs.$$element = jqLite(compileNode),
              directive,
              directiveName,
              $template,
              replaceDirective = originalReplaceDirective,
              childTranscludeFn = transcludeFn,
              linkFn,
              directiveValue;
          for (var i = 0,
              ii = directives.length; i < ii; i++) {
            directive = directives[i];
            var attrStart = directive.$$start;
            var attrEnd = directive.$$end;
            if (attrStart) {
              $compileNode = groupScan(compileNode, attrStart, attrEnd);
            }
            $template = undefined;
            if (terminalPriority > directive.priority) {
              break;
            }
            if (directiveValue = directive.scope) {
              if (!directive.templateUrl) {
                if (isObject(directiveValue)) {
                  assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                  newIsolateScopeDirective = directive;
                } else {
                  assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                }
              }
              newScopeDirective = newScopeDirective || directive;
            }
            directiveName = directive.name;
            if (!directive.templateUrl && directive.controller) {
              directiveValue = directive.controller;
              controllerDirectives = controllerDirectives || createMap();
              assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode);
              controllerDirectives[directiveName] = directive;
            }
            if (directiveValue = directive.transclude) {
              hasTranscludeDirective = true;
              if (!directive.$$tlb) {
                assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                nonTlbTranscludeDirective = directive;
              }
              if (directiveValue == 'element') {
                hasElementTranscludeDirective = true;
                terminalPriority = directive.priority;
                $template = $compileNode;
                $compileNode = templateAttrs.$$element = jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));
                compileNode = $compileNode[0];
                replaceWith(jqCollection, sliceArgs($template), compileNode);
                childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective});
              } else {
                $template = jqLite(jqLiteClone(compileNode)).contents();
                $compileNode.empty();
                childTranscludeFn = compile($template, transcludeFn);
              }
            }
            if (directive.template) {
              hasTemplate = true;
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              directiveValue = (isFunction(directive.template)) ? directive.template($compileNode, templateAttrs) : directive.template;
              directiveValue = denormalizeTemplate(directiveValue);
              if (directive.replace) {
                replaceDirective = directive;
                if (jqLiteIsTextNode(directiveValue)) {
                  $template = [];
                } else {
                  $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                }
                compileNode = $template[0];
                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                  throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", directiveName, '');
                }
                replaceWith(jqCollection, $compileNode, compileNode);
                var newTemplateAttrs = {$attr: {}};
                var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                if (newIsolateScopeDirective) {
                  markDirectivesAsIsolate(templateDirectives);
                }
                directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                ii = directives.length;
              } else {
                $compileNode.html(directiveValue);
              }
            }
            if (directive.templateUrl) {
              hasTemplate = true;
              assertNoDuplicate('template', templateDirective, directive, $compileNode);
              templateDirective = directive;
              if (directive.replace) {
                replaceDirective = directive;
              }
              nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                controllerDirectives: controllerDirectives,
                newScopeDirective: (newScopeDirective !== directive) && newScopeDirective,
                newIsolateScopeDirective: newIsolateScopeDirective,
                templateDirective: templateDirective,
                nonTlbTranscludeDirective: nonTlbTranscludeDirective
              });
              ii = directives.length;
            } else if (directive.compile) {
              try {
                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                if (isFunction(linkFn)) {
                  addLinkFns(null, linkFn, attrStart, attrEnd);
                } else if (linkFn) {
                  addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                }
              } catch (e) {
                $exceptionHandler(e, startingTag($compileNode));
              }
            }
            if (directive.terminal) {
              nodeLinkFn.terminal = true;
              terminalPriority = Math.max(terminalPriority, directive.priority);
            }
          }
          nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
          nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
          nodeLinkFn.templateOnThisElement = hasTemplate;
          nodeLinkFn.transclude = childTranscludeFn;
          previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
          return nodeLinkFn;
          function addLinkFns(pre, post, attrStart, attrEnd) {
            if (pre) {
              if (attrStart)
                pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
              pre.require = directive.require;
              pre.directiveName = directiveName;
              if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                pre = cloneAndAnnotateFn(pre, {isolateScope: true});
              }
              preLinkFns.push(pre);
            }
            if (post) {
              if (attrStart)
                post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
              post.require = directive.require;
              post.directiveName = directiveName;
              if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                post = cloneAndAnnotateFn(post, {isolateScope: true});
              }
              postLinkFns.push(post);
            }
          }
          function getControllers(directiveName, $__require, $element, elementControllers) {
            var value;
            if (isString($__require)) {
              var match = $__require.match(REQUIRE_PREFIX_REGEXP);
              var name = $__require.substring(match[0].length);
              var inheritType = match[1] || match[3];
              var optional = match[2] === '?';
              if (inheritType === '^^') {
                $element = $element.parent();
              } else {
                value = elementControllers && elementControllers[name];
                value = value && value.instance;
              }
              if (!value) {
                var dataName = '$' + name + 'Controller';
                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
              }
              if (!value && !optional) {
                throw $compileMinErr('ctreq', "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
              }
            } else if (isArray($__require)) {
              value = [];
              for (var i = 0,
                  ii = $__require.length; i < ii; i++) {
                value[i] = getControllers(directiveName, $__require[i], $element, elementControllers);
              }
            }
            return value || null;
          }
          function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
            var elementControllers = createMap();
            for (var controllerKey in controllerDirectives) {
              var directive = controllerDirectives[controllerKey];
              var locals = {
                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                $element: $element,
                $attrs: attrs,
                $transclude: transcludeFn
              };
              var controller = directive.controller;
              if (controller == '@') {
                controller = attrs[directive.name];
              }
              var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
              elementControllers[directive.name] = controllerInstance;
              if (!hasElementTranscludeDirective) {
                $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
              }
            }
            return elementControllers;
          }
          function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
            var i,
                ii,
                linkFn,
                controller,
                isolateScope,
                elementControllers,
                transcludeFn,
                $element,
                attrs;
            if (compileNode === linkNode) {
              attrs = templateAttrs;
              $element = templateAttrs.$$element;
            } else {
              $element = jqLite(linkNode);
              attrs = new Attributes($element, templateAttrs);
            }
            if (newIsolateScopeDirective) {
              isolateScope = scope.$new(true);
            }
            if (boundTranscludeFn) {
              transcludeFn = controllersBoundTransclude;
              transcludeFn.$$boundTransclude = boundTranscludeFn;
            }
            if (controllerDirectives) {
              elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope);
            }
            if (newIsolateScopeDirective) {
              compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
              compile.$$addScopeClass($element, true);
              isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
              initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope);
            }
            if (elementControllers) {
              var scopeDirective = newIsolateScopeDirective || newScopeDirective;
              var bindings;
              var controllerForBindings;
              if (scopeDirective && elementControllers[scopeDirective.name]) {
                bindings = scopeDirective.$$bindings.bindToController;
                controller = elementControllers[scopeDirective.name];
                if (controller && controller.identifier && bindings) {
                  controllerForBindings = controller;
                  thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective);
                }
              }
              for (i in elementControllers) {
                controller = elementControllers[i];
                var controllerResult = controller();
                if (controllerResult !== controller.instance) {
                  controller.instance = controllerResult;
                  $element.data('$' + i + 'Controller', controllerResult);
                  if (controller === controllerForBindings) {
                    thisLinkFn.$$destroyBindings();
                    thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective);
                  }
                }
              }
            }
            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
              linkFn = preLinkFns[i];
              invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
            }
            var scopeToChild = scope;
            if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
              scopeToChild = isolateScope;
            }
            childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
            for (i = postLinkFns.length - 1; i >= 0; i--) {
              linkFn = postLinkFns[i];
              invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
            }
            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
              var transcludeControllers;
              if (!isScope(scope)) {
                futureParentElement = cloneAttachFn;
                cloneAttachFn = scope;
                scope = undefined;
              }
              if (hasElementTranscludeDirective) {
                transcludeControllers = elementControllers;
              }
              if (!futureParentElement) {
                futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
              }
              return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
            }
          }
        }
        function markDirectivesAsIsolate(directives) {
          for (var j = 0,
              jj = directives.length; j < jj; j++) {
            directives[j] = inherit(directives[j], {$$isolateScope: true});
          }
        }
        function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
          if (name === ignoreDirective)
            return null;
          var match = null;
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive,
                directives = $injector.get(name + Suffix),
                i = 0,
                ii = directives.length; i < ii; i++) {
              try {
                directive = directives[i];
                if ((maxPriority === undefined || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                  if (startAttrName) {
                    directive = inherit(directive, {
                      $$start: startAttrName,
                      $$end: endAttrName
                    });
                  }
                  tDirectives.push(directive);
                  match = directive;
                }
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          }
          return match;
        }
        function directiveIsMultiElement(name) {
          if (hasDirectives.hasOwnProperty(name)) {
            for (var directive,
                directives = $injector.get(name + Suffix),
                i = 0,
                ii = directives.length; i < ii; i++) {
              directive = directives[i];
              if (directive.multiElement) {
                return true;
              }
            }
          }
          return false;
        }
        function mergeTemplateAttributes(dst, src) {
          var srcAttr = src.$attr,
              dstAttr = dst.$attr,
              $element = dst.$$element;
          forEach(dst, function(value, key) {
            if (key.charAt(0) != '$') {
              if (src[key] && src[key] !== value) {
                value += (key === 'style' ? ';' : ' ') + src[key];
              }
              dst.$set(key, value, true, srcAttr[key]);
            }
          });
          forEach(src, function(value, key) {
            if (key == 'class') {
              safeAddClass($element, value);
              dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
            } else if (key == 'style') {
              $element.attr('style', $element.attr('style') + ';' + value);
              dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
              dst[key] = value;
              dstAttr[key] = srcAttr[key];
            }
          });
        }
        function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
          var linkQueue = [],
              afterTemplateNodeLinkFn,
              afterTemplateChildLinkFn,
              beforeTemplateCompileNode = $compileNode[0],
              origAsyncDirective = directives.shift(),
              derivedSyncDirective = inherit(origAsyncDirective, {
                templateUrl: null,
                transclude: null,
                replace: null,
                $$originalDirective: origAsyncDirective
              }),
              templateUrl = (isFunction(origAsyncDirective.templateUrl)) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
              templateNamespace = origAsyncDirective.templateNamespace;
          $compileNode.empty();
          $templateRequest(templateUrl).then(function(content) {
            var compileNode,
                tempTemplateAttrs,
                $template,
                childBoundTranscludeFn;
            content = denormalizeTemplate(content);
            if (origAsyncDirective.replace) {
              if (jqLiteIsTextNode(content)) {
                $template = [];
              } else {
                $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
              }
              compileNode = $template[0];
              if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                throw $compileMinErr('tplrt', "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
              }
              tempTemplateAttrs = {$attr: {}};
              replaceWith($rootElement, $compileNode, compileNode);
              var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
              if (isObject(origAsyncDirective.scope)) {
                markDirectivesAsIsolate(templateDirectives);
              }
              directives = templateDirectives.concat(directives);
              mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
            } else {
              compileNode = beforeTemplateCompileNode;
              $compileNode.html(content);
            }
            directives.unshift(derivedSyncDirective);
            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
            forEach($rootElement, function(node, i) {
              if (node == compileNode) {
                $rootElement[i] = $compileNode[0];
              }
            });
            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
            while (linkQueue.length) {
              var scope = linkQueue.shift(),
                  beforeTemplateLinkNode = linkQueue.shift(),
                  linkRootElement = linkQueue.shift(),
                  boundTranscludeFn = linkQueue.shift(),
                  linkNode = $compileNode[0];
              if (scope.$$destroyed)
                continue;
              if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                var oldClasses = beforeTemplateLinkNode.className;
                if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                  linkNode = jqLiteClone(compileNode);
                }
                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                safeAddClass(jqLite(linkNode), oldClasses);
              }
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
              } else {
                childBoundTranscludeFn = boundTranscludeFn;
              }
              afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
            }
            linkQueue = null;
          });
          return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
            var childBoundTranscludeFn = boundTranscludeFn;
            if (scope.$$destroyed)
              return;
            if (linkQueue) {
              linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
            } else {
              if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
              }
              afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
            }
          };
        }
        function byPriority(a, b) {
          var diff = b.priority - a.priority;
          if (diff !== 0)
            return diff;
          if (a.name !== b.name)
            return (a.name < b.name) ? -1 : 1;
          return a.index - b.index;
        }
        function assertNoDuplicate(what, previousDirective, directive, element) {
          function wrapModuleNameIfDefined(moduleName) {
            return moduleName ? (' (module: ' + moduleName + ')') : '';
          }
          if (previousDirective) {
            throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
          }
        }
        function addTextInterpolateDirective(directives, text) {
          var interpolateFn = $interpolate(text, true);
          if (interpolateFn) {
            directives.push({
              priority: 0,
              compile: function textInterpolateCompileFn(templateNode) {
                var templateNodeParent = templateNode.parent(),
                    hasCompileParent = !!templateNodeParent.length;
                if (hasCompileParent)
                  compile.$$addBindingClass(templateNodeParent);
                return function textInterpolateLinkFn(scope, node) {
                  var parent = node.parent();
                  if (!hasCompileParent)
                    compile.$$addBindingClass(parent);
                  compile.$$addBindingInfo(parent, interpolateFn.expressions);
                  scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                    node[0].nodeValue = value;
                  });
                };
              }
            });
          }
        }
        function wrapTemplate(type, template) {
          type = lowercase(type || 'html');
          switch (type) {
            case 'svg':
            case 'math':
              var wrapper = document.createElement('div');
              wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
              return wrapper.childNodes[0].childNodes;
            default:
              return template;
          }
        }
        function getTrustedContext(node, attrNormalizedName) {
          if (attrNormalizedName == "srcdoc") {
            return $sce.HTML;
          }
          var tag = nodeName_(node);
          if (attrNormalizedName == "xlinkHref" || (tag == "form" && attrNormalizedName == "action") || (tag != "img" && (attrNormalizedName == "src" || attrNormalizedName == "ngSrc"))) {
            return $sce.RESOURCE_URL;
          }
        }
        function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
          var trustedContext = getTrustedContext(node, name);
          allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
          var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
          if (!interpolateFn)
            return;
          if (name === "multiple" && nodeName_(node) === "select") {
            throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
          }
          directives.push({
            priority: 100,
            compile: function() {
              return {pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                  var $$observers = (attr.$$observers || (attr.$$observers = {}));
                  if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                    throw $compileMinErr('nodomevents', "Interpolations for HTML DOM event attributes are disallowed.  Please use the " + "ng- versions (such as ng-click instead of onclick) instead.");
                  }
                  var newValue = attr[name];
                  if (newValue !== value) {
                    interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                    value = newValue;
                  }
                  if (!interpolateFn)
                    return;
                  attr[name] = interpolateFn(scope);
                  ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                  (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                    if (name === 'class' && newValue != oldValue) {
                      attr.$updateClass(newValue, oldValue);
                    } else {
                      attr.$set(name, newValue);
                    }
                  });
                }};
            }
          });
        }
        function replaceWith($rootElement, elementsToRemove, newNode) {
          var firstElementToRemove = elementsToRemove[0],
              removeCount = elementsToRemove.length,
              parent = firstElementToRemove.parentNode,
              i,
              ii;
          if ($rootElement) {
            for (i = 0, ii = $rootElement.length; i < ii; i++) {
              if ($rootElement[i] == firstElementToRemove) {
                $rootElement[i++] = newNode;
                for (var j = i,
                    j2 = j + removeCount - 1,
                    jj = $rootElement.length; j < jj; j++, j2++) {
                  if (j2 < jj) {
                    $rootElement[j] = $rootElement[j2];
                  } else {
                    delete $rootElement[j];
                  }
                }
                $rootElement.length -= removeCount - 1;
                if ($rootElement.context === firstElementToRemove) {
                  $rootElement.context = newNode;
                }
                break;
              }
            }
          }
          if (parent) {
            parent.replaceChild(newNode, firstElementToRemove);
          }
          var fragment = document.createDocumentFragment();
          fragment.appendChild(firstElementToRemove);
          if (jqLite.hasData(firstElementToRemove)) {
            jqLite(newNode).data(jqLite(firstElementToRemove).data());
            if (!jQuery) {
              delete jqLite.cache[firstElementToRemove[jqLite.expando]];
            } else {
              skipDestroyOnNextJQueryCleanData = true;
              jQuery.cleanData([firstElementToRemove]);
            }
          }
          for (var k = 1,
              kk = elementsToRemove.length; k < kk; k++) {
            var element = elementsToRemove[k];
            jqLite(element).remove();
            fragment.appendChild(element);
            delete elementsToRemove[k];
          }
          elementsToRemove[0] = newNode;
          elementsToRemove.length = 1;
        }
        function cloneAndAnnotateFn(fn, annotation) {
          return extend(function() {
            return fn.apply(null, arguments);
          }, fn, annotation);
        }
        function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
          try {
            linkFn(scope, $element, attrs, controllers, transcludeFn);
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }
        function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
          var onNewScopeDestroyed;
          forEach(bindings, function(definition, scopeName) {
            var attrName = definition.attrName,
                optional = definition.optional,
                mode = definition.mode,
                lastValue,
                parentGet,
                parentSet,
                compare;
            if (!hasOwnProperty.call(attrs, attrName)) {
              attrs[attrName] = undefined;
            }
            switch (mode) {
              case '@':
                if (!attrs[attrName] && !optional) {
                  destination[scopeName] = undefined;
                }
                attrs.$observe(attrName, function(value) {
                  destination[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = scope;
                if (attrs[attrName]) {
                  destination[scopeName] = $interpolate(attrs[attrName])(scope);
                }
                break;
              case '=':
                if (optional && !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                if (parentGet.literal) {
                  compare = equals;
                } else {
                  compare = function(a, b) {
                    return a === b || (a !== a && b !== b);
                  };
                }
                parentSet = parentGet.assign || function() {
                  lastValue = destination[scopeName] = parentGet(scope);
                  throw $compileMinErr('nonassign', "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                };
                lastValue = destination[scopeName] = parentGet(scope);
                var parentValueWatch = function parentValueWatch(parentValue) {
                  if (!compare(parentValue, destination[scopeName])) {
                    if (!compare(parentValue, lastValue)) {
                      destination[scopeName] = parentValue;
                    } else {
                      parentSet(scope, parentValue = destination[scopeName]);
                    }
                  }
                  return lastValue = parentValue;
                };
                parentValueWatch.$stateful = true;
                var unwatch;
                if (definition.collection) {
                  unwatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                } else {
                  unwatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                }
                onNewScopeDestroyed = (onNewScopeDestroyed || []);
                onNewScopeDestroyed.push(unwatch);
                break;
              case '&':
                parentGet = $parse(attrs[attrName]);
                if (parentGet === noop && optional)
                  break;
                destination[scopeName] = function(locals) {
                  return parentGet(scope, locals);
                };
                break;
            }
          });
          var destroyBindings = onNewScopeDestroyed ? function destroyBindings() {
            for (var i = 0,
                ii = onNewScopeDestroyed.length; i < ii; ++i) {
              onNewScopeDestroyed[i]();
            }
          } : noop;
          if (newScope && destroyBindings !== noop) {
            newScope.$on('$destroy', destroyBindings);
            return noop;
          }
          return destroyBindings;
        }
      }];
    }
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
    function directiveNormalize(name) {
      return camelCase(name.replace(PREFIX_REGEXP, ''));
    }
    function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {}
    function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {}
    function tokenDifference(str1, str2) {
      var values = '',
          tokens1 = str1.split(/\s+/),
          tokens2 = str2.split(/\s+/);
      outer: for (var i = 0; i < tokens1.length; i++) {
        var token = tokens1[i];
        for (var j = 0; j < tokens2.length; j++) {
          if (token == tokens2[j])
            continue outer;
        }
        values += (values.length > 0 ? ' ' : '') + token;
      }
      return values;
    }
    function removeComments(jqNodes) {
      jqNodes = jqLite(jqNodes);
      var i = jqNodes.length;
      if (i <= 1) {
        return jqNodes;
      }
      while (i--) {
        var node = jqNodes[i];
        if (node.nodeType === NODE_TYPE_COMMENT) {
          splice.call(jqNodes, i, 1);
        }
      }
      return jqNodes;
    }
    var $controllerMinErr = minErr('$controller');
    var CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
    function identifierForController(controller, ident) {
      if (ident && isString(ident))
        return ident;
      if (isString(controller)) {
        var match = CNTRL_REG.exec(controller);
        if (match)
          return match[3];
      }
    }
    function $ControllerProvider() {
      var controllers = {},
          globals = false;
      this.register = function(name, constructor) {
        assertNotHasOwnProperty(name, 'controller');
        if (isObject(name)) {
          extend(controllers, name);
        } else {
          controllers[name] = constructor;
        }
      };
      this.allowGlobals = function() {
        globals = true;
      };
      this.$get = ['$injector', '$window', function($injector, $window) {
        return function(expression, locals, later, ident) {
          var instance,
              match,
              constructor,
              identifier;
          later = later === true;
          if (ident && isString(ident)) {
            identifier = ident;
          }
          if (isString(expression)) {
            match = expression.match(CNTRL_REG);
            if (!match) {
              throw $controllerMinErr('ctrlfmt', "Badly formed controller string '{0}'. " + "Must match `__name__ as __id__` or `__name__`.", expression);
            }
            constructor = match[1], identifier = identifier || match[3];
            expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
            assertArgFn(expression, constructor, true);
          }
          if (later) {
            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
            instance = Object.create(controllerPrototype || null);
            if (identifier) {
              addIdentifier(locals, identifier, instance, constructor || expression.name);
            }
            var instantiate;
            return instantiate = extend(function() {
              var result = $injector.invoke(expression, instance, locals, constructor);
              if (result !== instance && (isObject(result) || isFunction(result))) {
                instance = result;
                if (identifier) {
                  addIdentifier(locals, identifier, instance, constructor || expression.name);
                }
              }
              return instance;
            }, {
              instance: instance,
              identifier: identifier
            });
          }
          instance = $injector.instantiate(expression, locals, constructor);
          if (identifier) {
            addIdentifier(locals, identifier, instance, constructor || expression.name);
          }
          return instance;
        };
        function addIdentifier(locals, identifier, instance, name) {
          if (!(locals && isObject(locals.$scope))) {
            throw minErr('$controller')('noscp', "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
          }
          locals.$scope[identifier] = instance;
        }
      }];
    }
    function $DocumentProvider() {
      this.$get = ['$window', function(window) {
        return jqLite(window.document);
      }];
    }
    function $ExceptionHandlerProvider() {
      this.$get = ['$log', function($log) {
        return function(exception, cause) {
          $log.error.apply($log, arguments);
        };
      }];
    }
    var APPLICATION_JSON = 'application/json';
    var CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': APPLICATION_JSON + ';charset=utf-8'};
    var JSON_START = /^\[|^\{(?!\{)/;
    var JSON_ENDS = {
      '[': /]$/,
      '{': /}$/
    };
    var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
    function serializeValue(v) {
      if (isObject(v)) {
        return isDate(v) ? v.toISOString() : toJson(v);
      }
      return v;
    }
    function $HttpParamSerializerProvider() {
      this.$get = function() {
        return function ngParamSerializer(params) {
          if (!params)
            return '';
          var parts = [];
          forEachSorted(params, function(value, key) {
            if (value === null || isUndefined(value))
              return;
            if (isArray(value)) {
              forEach(value, function(v, k) {
                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
              });
            } else {
              parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
            }
          });
          return parts.join('&');
        };
      };
    }
    function $HttpParamSerializerJQLikeProvider() {
      this.$get = function() {
        return function jQueryLikeParamSerializer(params) {
          if (!params)
            return '';
          var parts = [];
          serialize(params, '', true);
          return parts.join('&');
          function serialize(toSerialize, prefix, topLevel) {
            if (toSerialize === null || isUndefined(toSerialize))
              return;
            if (isArray(toSerialize)) {
              forEach(toSerialize, function(value) {
                serialize(value, prefix + '[]');
              });
            } else if (isObject(toSerialize) && !isDate(toSerialize)) {
              forEachSorted(toSerialize, function(value, key) {
                serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
              });
            } else {
              parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
            }
          }
        };
      };
    }
    function defaultHttpResponseTransform(data, headers) {
      if (isString(data)) {
        var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
        if (tempData) {
          var contentType = headers('Content-Type');
          if ((contentType && (contentType.indexOf(APPLICATION_JSON) === 0)) || isJsonLike(tempData)) {
            data = fromJson(tempData);
          }
        }
      }
      return data;
    }
    function isJsonLike(str) {
      var jsonStart = str.match(JSON_START);
      return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
      var parsed = createMap(),
          i;
      function fillInParsed(key, val) {
        if (key) {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      }
      if (isString(headers)) {
        forEach(headers.split('\n'), function(line) {
          i = line.indexOf(':');
          fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        });
      } else if (isObject(headers)) {
        forEach(headers, function(headerVal, headerKey) {
          fillInParsed(lowercase(headerKey), trim(headerVal));
        });
      }
      return parsed;
    }
    function headersGetter(headers) {
      var headersObj;
      return function(name) {
        if (!headersObj)
          headersObj = parseHeaders(headers);
        if (name) {
          var value = headersObj[lowercase(name)];
          if (value === void 0) {
            value = null;
          }
          return value;
        }
        return headersObj;
      };
    }
    function transformData(data, headers, status, fns) {
      if (isFunction(fns)) {
        return fns(data, headers, status);
      }
      forEach(fns, function(fn) {
        data = fn(data, headers, status);
      });
      return data;
    }
    function isSuccess(status) {
      return 200 <= status && status < 300;
    }
    function $HttpProvider() {
      var defaults = this.defaults = {
        transformResponse: [defaultHttpResponseTransform],
        transformRequest: [function(d) {
          return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
        }],
        headers: {
          common: {'Accept': 'application/json, text/plain, */*'},
          post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
          put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
          patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
        },
        xsrfCookieName: 'XSRF-TOKEN',
        xsrfHeaderName: 'X-XSRF-TOKEN',
        paramSerializer: '$httpParamSerializer'
      };
      var useApplyAsync = false;
      this.useApplyAsync = function(value) {
        if (isDefined(value)) {
          useApplyAsync = !!value;
          return this;
        }
        return useApplyAsync;
      };
      var interceptorFactories = this.interceptors = [];
      this.$get = ['$httpBackend', '$$cookieReader', '$cacheFactory', '$rootScope', '$q', '$injector', function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
        var defaultCache = $cacheFactory('$http');
        defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
        var reversedInterceptors = [];
        forEach(interceptorFactories, function(interceptorFactory) {
          reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
        });
        function $http(requestConfig) {
          if (!angular.isObject(requestConfig)) {
            throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
          }
          var config = extend({
            method: 'get',
            transformRequest: defaults.transformRequest,
            transformResponse: defaults.transformResponse,
            paramSerializer: defaults.paramSerializer
          }, requestConfig);
          config.headers = mergeHeaders(requestConfig);
          config.method = uppercase(config.method);
          config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
          var serverRequest = function(config) {
            var headers = config.headers;
            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
            if (isUndefined(reqData)) {
              forEach(headers, function(value, header) {
                if (lowercase(header) === 'content-type') {
                  delete headers[header];
                }
              });
            }
            if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
              config.withCredentials = defaults.withCredentials;
            }
            return sendReq(config, reqData).then(transformResponse, transformResponse);
          };
          var chain = [serverRequest, undefined];
          var promise = $q.when(config);
          forEach(reversedInterceptors, function(interceptor) {
            if (interceptor.request || interceptor.requestError) {
              chain.unshift(interceptor.request, interceptor.requestError);
            }
            if (interceptor.response || interceptor.responseError) {
              chain.push(interceptor.response, interceptor.responseError);
            }
          });
          while (chain.length) {
            var thenFn = chain.shift();
            var rejectFn = chain.shift();
            promise = promise.then(thenFn, rejectFn);
          }
          promise.success = function(fn) {
            assertArgFn(fn, 'fn');
            promise.then(function(response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          promise.error = function(fn) {
            assertArgFn(fn, 'fn');
            promise.then(null, function(response) {
              fn(response.data, response.status, response.headers, config);
            });
            return promise;
          };
          return promise;
          function transformResponse(response) {
            var resp = extend({}, response);
            if (!response.data) {
              resp.data = response.data;
            } else {
              resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
            }
            return (isSuccess(response.status)) ? resp : $q.reject(resp);
          }
          function executeHeaderFns(headers, config) {
            var headerContent,
                processedHeaders = {};
            forEach(headers, function(headerFn, header) {
              if (isFunction(headerFn)) {
                headerContent = headerFn(config);
                if (headerContent != null) {
                  processedHeaders[header] = headerContent;
                }
              } else {
                processedHeaders[header] = headerFn;
              }
            });
            return processedHeaders;
          }
          function mergeHeaders(config) {
            var defHeaders = defaults.headers,
                reqHeaders = extend({}, config.headers),
                defHeaderName,
                lowercaseDefHeaderName,
                reqHeaderName;
            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
            defaultHeadersIteration: for (defHeaderName in defHeaders) {
              lowercaseDefHeaderName = lowercase(defHeaderName);
              for (reqHeaderName in reqHeaders) {
                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                  continue defaultHeadersIteration;
                }
              }
              reqHeaders[defHeaderName] = defHeaders[defHeaderName];
            }
            return executeHeaderFns(reqHeaders, shallowCopy(config));
          }
        }
        $http.pendingRequests = [];
        createShortMethods('get', 'delete', 'head', 'jsonp');
        createShortMethodsWithData('post', 'put', 'patch');
        $http.defaults = defaults;
        return $http;
        function createShortMethods(names) {
          forEach(arguments, function(name) {
            $http[name] = function(url, config) {
              return $http(extend({}, config || {}, {
                method: name,
                url: url
              }));
            };
          });
        }
        function createShortMethodsWithData(name) {
          forEach(arguments, function(name) {
            $http[name] = function(url, data, config) {
              return $http(extend({}, config || {}, {
                method: name,
                url: url,
                data: data
              }));
            };
          });
        }
        function sendReq(config, reqData) {
          var deferred = $q.defer(),
              promise = deferred.promise,
              cache,
              cachedResp,
              reqHeaders = config.headers,
              url = buildUrl(config.url, config.paramSerializer(config.params));
          $http.pendingRequests.push(config);
          promise.then(removePendingReq, removePendingReq);
          if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
            cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
          }
          if (cache) {
            cachedResp = cache.get(url);
            if (isDefined(cachedResp)) {
              if (isPromiseLike(cachedResp)) {
                cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
              } else {
                if (isArray(cachedResp)) {
                  resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                } else {
                  resolvePromise(cachedResp, 200, {}, 'OK');
                }
              }
            } else {
              cache.put(url, promise);
            }
          }
          if (isUndefined(cachedResp)) {
            var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
            if (xsrfValue) {
              reqHeaders[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
            }
            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
          }
          return promise;
          function done(status, response, headersString, statusText) {
            if (cache) {
              if (isSuccess(status)) {
                cache.put(url, [status, response, parseHeaders(headersString), statusText]);
              } else {
                cache.remove(url);
              }
            }
            function resolveHttpPromise() {
              resolvePromise(response, status, headersString, statusText);
            }
            if (useApplyAsync) {
              $rootScope.$applyAsync(resolveHttpPromise);
            } else {
              resolveHttpPromise();
              if (!$rootScope.$$phase)
                $rootScope.$apply();
            }
          }
          function resolvePromise(response, status, headers, statusText) {
            status = Math.max(status, 0);
            (isSuccess(status) ? deferred.resolve : deferred.reject)({
              data: response,
              status: status,
              headers: headersGetter(headers),
              config: config,
              statusText: statusText
            });
          }
          function resolvePromiseWithResult(result) {
            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
          }
          function removePendingReq() {
            var idx = $http.pendingRequests.indexOf(config);
            if (idx !== -1)
              $http.pendingRequests.splice(idx, 1);
          }
        }
        function buildUrl(url, serializedParams) {
          if (serializedParams.length > 0) {
            url += ((url.indexOf('?') == -1) ? '?' : '&') + serializedParams;
          }
          return url;
        }
      }];
    }
    function createXhr() {
      return new window.XMLHttpRequest();
    }
    function $HttpBackendProvider() {
      this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
        return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
      }];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
      return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
        $browser.$$incOutstandingRequestCount();
        url = url || $browser.url();
        if (lowercase(method) == 'jsonp') {
          var callbackId = '_' + (callbacks.counter++).toString(36);
          callbacks[callbackId] = function(data) {
            callbacks[callbackId].data = data;
            callbacks[callbackId].called = true;
          };
          var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function(status, text) {
            completeRequest(callback, status, callbacks[callbackId].data, "", text);
            callbacks[callbackId] = noop;
          });
        } else {
          var xhr = createXhr();
          xhr.open(method, url, true);
          forEach(headers, function(value, key) {
            if (isDefined(value)) {
              xhr.setRequestHeader(key, value);
            }
          });
          xhr.onload = function requestLoaded() {
            var statusText = xhr.statusText || '';
            var response = ('response' in xhr) ? xhr.response : xhr.responseText;
            var status = xhr.status === 1223 ? 204 : xhr.status;
            if (status === 0) {
              status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
            }
            completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
          };
          var requestError = function() {
            completeRequest(callback, -1, null, null, '');
          };
          xhr.onerror = requestError;
          xhr.onabort = requestError;
          if (withCredentials) {
            xhr.withCredentials = true;
          }
          if (responseType) {
            try {
              xhr.responseType = responseType;
            } catch (e) {
              if (responseType !== 'json') {
                throw e;
              }
            }
          }
          xhr.send(post);
        }
        if (timeout > 0) {
          var timeoutId = $browserDefer(timeoutRequest, timeout);
        } else if (isPromiseLike(timeout)) {
          timeout.then(timeoutRequest);
        }
        function timeoutRequest() {
          jsonpDone && jsonpDone();
          xhr && xhr.abort();
        }
        function completeRequest(callback, status, response, headersString, statusText) {
          if (timeoutId !== undefined) {
            $browserDefer.cancel(timeoutId);
          }
          jsonpDone = xhr = null;
          callback(status, response, headersString, statusText);
          $browser.$$completeOutstandingRequest(noop);
        }
      };
      function jsonpReq(url, callbackId, done) {
        var script = rawDocument.createElement('script'),
            callback = null;
        script.type = "text/javascript";
        script.src = url;
        script.async = true;
        callback = function(event) {
          removeEventListenerFn(script, "load", callback);
          removeEventListenerFn(script, "error", callback);
          rawDocument.body.removeChild(script);
          script = null;
          var status = -1;
          var text = "unknown";
          if (event) {
            if (event.type === "load" && !callbacks[callbackId].called) {
              event = {type: "error"};
            }
            text = event.type;
            status = event.type === "error" ? 404 : 200;
          }
          if (done) {
            done(status, text);
          }
        };
        addEventListenerFn(script, "load", callback);
        addEventListenerFn(script, "error", callback);
        rawDocument.body.appendChild(script);
        return callback;
      }
    }
    var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
    $interpolateMinErr.throwNoconcat = function(text) {
      throw $interpolateMinErr('noconcat', "Error while interpolating: {0}\nStrict Contextual Escaping disallows " + "interpolations that concatenate multiple expressions when a trusted value is " + "required.  See http://docs.angularjs.org/api/ng.$sce", text);
    };
    $interpolateMinErr.interr = function(text, err) {
      return $interpolateMinErr('interr', "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    function $InterpolateProvider() {
      var startSymbol = '{{';
      var endSymbol = '}}';
      this.startSymbol = function(value) {
        if (value) {
          startSymbol = value;
          return this;
        } else {
          return startSymbol;
        }
      };
      this.endSymbol = function(value) {
        if (value) {
          endSymbol = value;
          return this;
        } else {
          return endSymbol;
        }
      };
      this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {
        var startSymbolLength = startSymbol.length,
            endSymbolLength = endSymbol.length,
            escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'),
            escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
        function escape(ch) {
          return '\\\\\\' + ch;
        }
        function unescapeText(text) {
          return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
        }
        function stringify(value) {
          if (value == null) {
            return '';
          }
          switch (typeof value) {
            case 'string':
              break;
            case 'number':
              value = '' + value;
              break;
            default:
              value = toJson(value);
          }
          return value;
        }
        function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
          allOrNothing = !!allOrNothing;
          var startIndex,
              endIndex,
              index = 0,
              expressions = [],
              parseFns = [],
              textLength = text.length,
              exp,
              concat = [],
              expressionPositions = [];
          while (index < textLength) {
            if (((startIndex = text.indexOf(startSymbol, index)) != -1) && ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1)) {
              if (index !== startIndex) {
                concat.push(unescapeText(text.substring(index, startIndex)));
              }
              exp = text.substring(startIndex + startSymbolLength, endIndex);
              expressions.push(exp);
              parseFns.push($parse(exp, parseStringifyInterceptor));
              index = endIndex + endSymbolLength;
              expressionPositions.push(concat.length);
              concat.push('');
            } else {
              if (index !== textLength) {
                concat.push(unescapeText(text.substring(index)));
              }
              break;
            }
          }
          if (trustedContext && concat.length > 1) {
            $interpolateMinErr.throwNoconcat(text);
          }
          if (!mustHaveExpression || expressions.length) {
            var compute = function(values) {
              for (var i = 0,
                  ii = expressions.length; i < ii; i++) {
                if (allOrNothing && isUndefined(values[i]))
                  return;
                concat[expressionPositions[i]] = values[i];
              }
              return concat.join('');
            };
            var getValue = function(value) {
              return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
            };
            return extend(function interpolationFn(context) {
              var i = 0;
              var ii = expressions.length;
              var values = new Array(ii);
              try {
                for (; i < ii; i++) {
                  values[i] = parseFns[i](context);
                }
                return compute(values);
              } catch (err) {
                $exceptionHandler($interpolateMinErr.interr(text, err));
              }
            }, {
              exp: text,
              expressions: expressions,
              $$watchDelegate: function(scope, listener) {
                var lastValue;
                return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                  var currValue = compute(values);
                  if (isFunction(listener)) {
                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                  }
                  lastValue = currValue;
                });
              }
            });
          }
          function parseStringifyInterceptor(value) {
            try {
              value = getValue(value);
              return allOrNothing && !isDefined(value) ? value : stringify(value);
            } catch (err) {
              $exceptionHandler($interpolateMinErr.interr(text, err));
            }
          }
        }
        $interpolate.startSymbol = function() {
          return startSymbol;
        };
        $interpolate.endSymbol = function() {
          return endSymbol;
        };
        return $interpolate;
      }];
    }
    function $IntervalProvider() {
      this.$get = ['$rootScope', '$window', '$q', '$$q', function($rootScope, $window, $q, $$q) {
        var intervals = {};
        function interval(fn, delay, count, invokeApply) {
          var hasParams = arguments.length > 4,
              args = hasParams ? sliceArgs(arguments, 4) : [],
              setInterval = $window.setInterval,
              clearInterval = $window.clearInterval,
              iteration = 0,
              skipApply = (isDefined(invokeApply) && !invokeApply),
              deferred = (skipApply ? $$q : $q).defer(),
              promise = deferred.promise;
          count = isDefined(count) ? count : 0;
          promise.then(null, null, (!hasParams) ? fn : function() {
            fn.apply(null, args);
          });
          promise.$$intervalId = setInterval(function tick() {
            deferred.notify(iteration++);
            if (count > 0 && iteration >= count) {
              deferred.resolve(iteration);
              clearInterval(promise.$$intervalId);
              delete intervals[promise.$$intervalId];
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          intervals[promise.$$intervalId] = deferred;
          return promise;
        }
        interval.cancel = function(promise) {
          if (promise && promise.$$intervalId in intervals) {
            intervals[promise.$$intervalId].reject('canceled');
            $window.clearInterval(promise.$$intervalId);
            delete intervals[promise.$$intervalId];
            return true;
          }
          return false;
        };
        return interval;
      }];
    }
    function $LocaleProvider() {
      this.$get = function() {
        return {
          id: 'en-us',
          NUMBER_FORMATS: {
            DECIMAL_SEP: '.',
            GROUP_SEP: ',',
            PATTERNS: [{
              minInt: 1,
              minFrac: 0,
              maxFrac: 3,
              posPre: '',
              posSuf: '',
              negPre: '-',
              negSuf: '',
              gSize: 3,
              lgSize: 3
            }, {
              minInt: 1,
              minFrac: 2,
              maxFrac: 2,
              posPre: '\u00A4',
              posSuf: '',
              negPre: '(\u00A4',
              negSuf: ')',
              gSize: 3,
              lgSize: 3
            }],
            CURRENCY_SYM: '$'
          },
          DATETIME_FORMATS: {
            MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
            SHORTMONTH: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
            DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
            SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
            AMPMS: ['AM', 'PM'],
            medium: 'MMM d, y h:mm:ss a',
            'short': 'M/d/yy h:mm a',
            fullDate: 'EEEE, MMMM d, y',
            longDate: 'MMMM d, y',
            mediumDate: 'MMM d, y',
            shortDate: 'M/d/yy',
            mediumTime: 'h:mm:ss a',
            shortTime: 'h:mm a',
            ERANAMES: ["Before Christ", "Anno Domini"],
            ERAS: ["BC", "AD"]
          },
          pluralCat: function(num) {
            if (num === 1) {
              return 'one';
            }
            return 'other';
          }
        };
      };
    }
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
        DEFAULT_PORTS = {
          'http': 80,
          'https': 443,
          'ftp': 21
        };
    var $locationMinErr = minErr('$location');
    function encodePath(path) {
      var segments = path.split('/'),
          i = segments.length;
      while (i--) {
        segments[i] = encodeUriSegment(segments[i]);
      }
      return segments.join('/');
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
      var parsedUrl = urlResolve(absoluteUrl);
      locationObj.$$protocol = parsedUrl.protocol;
      locationObj.$$host = parsedUrl.hostname;
      locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
      var prefixed = (relativeUrl.charAt(0) !== '/');
      if (prefixed) {
        relativeUrl = '/' + relativeUrl;
      }
      var match = urlResolve(relativeUrl);
      locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
      locationObj.$$search = parseKeyValue(match.search);
      locationObj.$$hash = decodeURIComponent(match.hash);
      if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
        locationObj.$$path = '/' + locationObj.$$path;
      }
    }
    function beginsWith(begin, whole) {
      if (whole.indexOf(begin) === 0) {
        return whole.substr(begin.length);
      }
    }
    function stripHash(url) {
      var index = url.indexOf('#');
      return index == -1 ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
      return url.replace(/(#.+)|#$/, '$1');
    }
    function stripFile(url) {
      return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
    }
    function serverBase(url) {
      return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
      this.$$html5 = true;
      basePrefix = basePrefix || '';
      var appBaseNoFile = stripFile(appBase);
      parseAbsoluteUrl(appBase, this);
      this.$$parse = function(url) {
        var pathUrl = beginsWith(appBaseNoFile, url);
        if (!isString(pathUrl)) {
          throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
        }
        parseAppUrl(pathUrl, this);
        if (!this.$$path) {
          this.$$path = '/';
        }
        this.$$compose();
      };
      this.$$compose = function() {
        var search = toKeyValue(this.$$search),
            hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
        this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
        this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
      };
      this.$$parseLinkUrl = function(url, relHref) {
        if (relHref && relHref[0] === '#') {
          this.hash(relHref.slice(1));
          return true;
        }
        var appUrl,
            prevAppUrl;
        var rewrittenUrl;
        if ((appUrl = beginsWith(appBase, url)) !== undefined) {
          prevAppUrl = appUrl;
          if ((appUrl = beginsWith(basePrefix, appUrl)) !== undefined) {
            rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
          } else {
            rewrittenUrl = appBase + prevAppUrl;
          }
        } else if ((appUrl = beginsWith(appBaseNoFile, url)) !== undefined) {
          rewrittenUrl = appBaseNoFile + appUrl;
        } else if (appBaseNoFile == url + '/') {
          rewrittenUrl = appBaseNoFile;
        }
        if (rewrittenUrl) {
          this.$$parse(rewrittenUrl);
        }
        return !!rewrittenUrl;
      };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
      var appBaseNoFile = stripFile(appBase);
      parseAbsoluteUrl(appBase, this);
      this.$$parse = function(url) {
        var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
        var withoutHashUrl;
        if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
          withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
          if (isUndefined(withoutHashUrl)) {
            withoutHashUrl = withoutBaseUrl;
          }
        } else {
          if (this.$$html5) {
            withoutHashUrl = withoutBaseUrl;
          } else {
            withoutHashUrl = '';
            if (isUndefined(withoutBaseUrl)) {
              appBase = url;
              this.replace();
            }
          }
        }
        parseAppUrl(withoutHashUrl, this);
        this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
        this.$$compose();
        function removeWindowsDriveName(path, url, base) {
          var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
          var firstPathSegmentMatch;
          if (url.indexOf(base) === 0) {
            url = url.replace(base, '');
          }
          if (windowsFilePathExp.exec(url)) {
            return path;
          }
          firstPathSegmentMatch = windowsFilePathExp.exec(path);
          return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
        }
      };
      this.$$compose = function() {
        var search = toKeyValue(this.$$search),
            hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
        this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
        this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
      };
      this.$$parseLinkUrl = function(url, relHref) {
        if (stripHash(appBase) == stripHash(url)) {
          this.$$parse(url);
          return true;
        }
        return false;
      };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
      this.$$html5 = true;
      LocationHashbangUrl.apply(this, arguments);
      var appBaseNoFile = stripFile(appBase);
      this.$$parseLinkUrl = function(url, relHref) {
        if (relHref && relHref[0] === '#') {
          this.hash(relHref.slice(1));
          return true;
        }
        var rewrittenUrl;
        var appUrl;
        if (appBase == stripHash(url)) {
          rewrittenUrl = url;
        } else if ((appUrl = beginsWith(appBaseNoFile, url))) {
          rewrittenUrl = appBase + hashPrefix + appUrl;
        } else if (appBaseNoFile === url + '/') {
          rewrittenUrl = appBaseNoFile;
        }
        if (rewrittenUrl) {
          this.$$parse(rewrittenUrl);
        }
        return !!rewrittenUrl;
      };
      this.$$compose = function() {
        var search = toKeyValue(this.$$search),
            hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
        this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
        this.$$absUrl = appBase + hashPrefix + this.$$url;
      };
    }
    var locationPrototype = {
      $$html5: false,
      $$replace: false,
      absUrl: locationGetter('$$absUrl'),
      url: function(url) {
        if (isUndefined(url)) {
          return this.$$url;
        }
        var match = PATH_MATCH.exec(url);
        if (match[1] || url === '')
          this.path(decodeURIComponent(match[1]));
        if (match[2] || match[1] || url === '')
          this.search(match[3] || '');
        this.hash(match[5] || '');
        return this;
      },
      protocol: locationGetter('$$protocol'),
      host: locationGetter('$$host'),
      port: locationGetter('$$port'),
      path: locationGetterSetter('$$path', function(path) {
        path = path !== null ? path.toString() : '';
        return path.charAt(0) == '/' ? path : '/' + path;
      }),
      search: function(search, paramValue) {
        switch (arguments.length) {
          case 0:
            return this.$$search;
          case 1:
            if (isString(search) || isNumber(search)) {
              search = search.toString();
              this.$$search = parseKeyValue(search);
            } else if (isObject(search)) {
              search = copy(search, {});
              forEach(search, function(value, key) {
                if (value == null)
                  delete search[key];
              });
              this.$$search = search;
            } else {
              throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
            }
            break;
          default:
            if (isUndefined(paramValue) || paramValue === null) {
              delete this.$$search[search];
            } else {
              this.$$search[search] = paramValue;
            }
        }
        this.$$compose();
        return this;
      },
      hash: locationGetterSetter('$$hash', function(hash) {
        return hash !== null ? hash.toString() : '';
      }),
      replace: function() {
        this.$$replace = true;
        return this;
      }
    };
    forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
      Location.prototype = Object.create(locationPrototype);
      Location.prototype.state = function(state) {
        if (!arguments.length) {
          return this.$$state;
        }
        if (Location !== LocationHtml5Url || !this.$$html5) {
          throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
        }
        this.$$state = isUndefined(state) ? null : state;
        return this;
      };
    });
    function locationGetter(property) {
      return function() {
        return this[property];
      };
    }
    function locationGetterSetter(property, preprocess) {
      return function(value) {
        if (isUndefined(value)) {
          return this[property];
        }
        this[property] = preprocess(value);
        this.$$compose();
        return this;
      };
    }
    function $LocationProvider() {
      var hashPrefix = '',
          html5Mode = {
            enabled: false,
            requireBase: true,
            rewriteLinks: true
          };
      this.hashPrefix = function(prefix) {
        if (isDefined(prefix)) {
          hashPrefix = prefix;
          return this;
        } else {
          return hashPrefix;
        }
      };
      this.html5Mode = function(mode) {
        if (isBoolean(mode)) {
          html5Mode.enabled = mode;
          return this;
        } else if (isObject(mode)) {
          if (isBoolean(mode.enabled)) {
            html5Mode.enabled = mode.enabled;
          }
          if (isBoolean(mode.requireBase)) {
            html5Mode.requireBase = mode.requireBase;
          }
          if (isBoolean(mode.rewriteLinks)) {
            html5Mode.rewriteLinks = mode.rewriteLinks;
          }
          return this;
        } else {
          return html5Mode;
        }
      };
      this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement', '$window', function($rootScope, $browser, $sniffer, $rootElement, $window) {
        var $location,
            LocationMode,
            baseHref = $browser.baseHref(),
            initialUrl = $browser.url(),
            appBase;
        if (html5Mode.enabled) {
          if (!baseHref && html5Mode.requireBase) {
            throw $locationMinErr('nobase', "$location in HTML5 mode requires a <base> tag to be present!");
          }
          appBase = serverBase(initialUrl) + (baseHref || '/');
          LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
        } else {
          appBase = stripHash(initialUrl);
          LocationMode = LocationHashbangUrl;
        }
        $location = new LocationMode(appBase, '#' + hashPrefix);
        $location.$$parseLinkUrl(initialUrl, initialUrl);
        $location.$$state = $browser.state();
        var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
        function setBrowserUrlWithFallback(url, replace, state) {
          var oldUrl = $location.url();
          var oldState = $location.$$state;
          try {
            $browser.url(url, replace, state);
            $location.$$state = $browser.state();
          } catch (e) {
            $location.url(oldUrl);
            $location.$$state = oldState;
            throw e;
          }
        }
        $rootElement.on('click', function(event) {
          if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
            return;
          var elm = jqLite(event.target);
          while (nodeName_(elm[0]) !== 'a') {
            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
              return;
          }
          var absHref = elm.prop('href');
          var relHref = elm.attr('href') || elm.attr('xlink:href');
          if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
            absHref = urlResolve(absHref.animVal).href;
          }
          if (IGNORE_URI_REGEXP.test(absHref))
            return;
          if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
            if ($location.$$parseLinkUrl(absHref, relHref)) {
              event.preventDefault();
              if ($location.absUrl() != $browser.url()) {
                $rootScope.$apply();
                $window.angular['ff-684208-preventDefault'] = true;
              }
            }
          }
        });
        if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
          $browser.url($location.absUrl(), true);
        }
        var initializing = true;
        $browser.onUrlChange(function(newUrl, newState) {
          $rootScope.$evalAsync(function() {
            var oldUrl = $location.absUrl();
            var oldState = $location.$$state;
            var defaultPrevented;
            $location.$$parse(newUrl);
            $location.$$state = newState;
            defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
            if ($location.absUrl() !== newUrl)
              return;
            if (defaultPrevented) {
              $location.$$parse(oldUrl);
              $location.$$state = oldState;
              setBrowserUrlWithFallback(oldUrl, false, oldState);
            } else {
              initializing = false;
              afterLocationChange(oldUrl, oldState);
            }
          });
          if (!$rootScope.$$phase)
            $rootScope.$digest();
        });
        $rootScope.$watch(function $locationWatch() {
          var oldUrl = trimEmptyHash($browser.url());
          var newUrl = trimEmptyHash($location.absUrl());
          var oldState = $browser.state();
          var currentReplace = $location.$$replace;
          var urlOrStateChanged = oldUrl !== newUrl || ($location.$$html5 && $sniffer.history && oldState !== $location.$$state);
          if (initializing || urlOrStateChanged) {
            initializing = false;
            $rootScope.$evalAsync(function() {
              var newUrl = $location.absUrl();
              var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
              if ($location.absUrl() !== newUrl)
                return;
              if (defaultPrevented) {
                $location.$$parse(oldUrl);
                $location.$$state = oldState;
              } else {
                if (urlOrStateChanged) {
                  setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                }
                afterLocationChange(oldUrl, oldState);
              }
            });
          }
          $location.$$replace = false;
        });
        return $location;
        function afterLocationChange(oldUrl, oldState) {
          $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
        }
      }];
    }
    function $LogProvider() {
      var debug = true,
          self = this;
      this.debugEnabled = function(flag) {
        if (isDefined(flag)) {
          debug = flag;
          return this;
        } else {
          return debug;
        }
      };
      this.$get = ['$window', function($window) {
        return {
          log: consoleLog('log'),
          info: consoleLog('info'),
          warn: consoleLog('warn'),
          error: consoleLog('error'),
          debug: (function() {
            var fn = consoleLog('debug');
            return function() {
              if (debug) {
                fn.apply(self, arguments);
              }
            };
          }())
        };
        function formatError(arg) {
          if (arg instanceof Error) {
            if (arg.stack) {
              arg = (arg.message && arg.stack.indexOf(arg.message) === -1) ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
            } else if (arg.sourceURL) {
              arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
            }
          }
          return arg;
        }
        function consoleLog(type) {
          var console = $window.console || {},
              logFn = console[type] || console.log || noop,
              hasApply = false;
          try {
            hasApply = !!logFn.apply;
          } catch (e) {}
          if (hasApply) {
            return function() {
              var args = [];
              forEach(arguments, function(arg) {
                args.push(formatError(arg));
              });
              return logFn.apply(console, args);
            };
          }
          return function(arg1, arg2) {
            logFn(arg1, arg2 == null ? '' : arg2);
          };
        }
      }];
    }
    var $parseMinErr = minErr('$parse');
    function ensureSafeMemberName(name, fullExpression) {
      if (name === "__defineGetter__" || name === "__defineSetter__" || name === "__lookupGetter__" || name === "__lookupSetter__" || name === "__proto__") {
        throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
      }
      return name;
    }
    function ensureSafeObject(obj, fullExpression) {
      if (obj) {
        if (obj.constructor === obj) {
          throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
        } else if (obj.window === obj) {
          throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
        } else if (obj.children && (obj.nodeName || (obj.prop && obj.attr && obj.find))) {
          throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
        } else if (obj === Object) {
          throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
        }
      }
      return obj;
    }
    var CALL = Function.prototype.call;
    var APPLY = Function.prototype.apply;
    var BIND = Function.prototype.bind;
    function ensureSafeFunction(obj, fullExpression) {
      if (obj) {
        if (obj.constructor === obj) {
          throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
        } else if (obj === CALL || obj === APPLY || obj === BIND) {
          throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
        }
      }
    }
    var OPERATORS = createMap();
    forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function(operator) {
      OPERATORS[operator] = true;
    });
    var ESCAPE = {
      "n": "\n",
      "f": "\f",
      "r": "\r",
      "t": "\t",
      "v": "\v",
      "'": "'",
      '"': '"'
    };
    var Lexer = function(options) {
      this.options = options;
    };
    Lexer.prototype = {
      constructor: Lexer,
      lex: function(text) {
        this.text = text;
        this.index = 0;
        this.tokens = [];
        while (this.index < this.text.length) {
          var ch = this.text.charAt(this.index);
          if (ch === '"' || ch === "'") {
            this.readString(ch);
          } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
            this.readNumber();
          } else if (this.isIdent(ch)) {
            this.readIdent();
          } else if (this.is(ch, '(){}[].,;:?')) {
            this.tokens.push({
              index: this.index,
              text: ch
            });
            this.index++;
          } else if (this.isWhitespace(ch)) {
            this.index++;
          } else {
            var ch2 = ch + this.peek();
            var ch3 = ch2 + this.peek(2);
            var op1 = OPERATORS[ch];
            var op2 = OPERATORS[ch2];
            var op3 = OPERATORS[ch3];
            if (op1 || op2 || op3) {
              var token = op3 ? ch3 : (op2 ? ch2 : ch);
              this.tokens.push({
                index: this.index,
                text: token,
                operator: true
              });
              this.index += token.length;
            } else {
              this.throwError('Unexpected next character ', this.index, this.index + 1);
            }
          }
        }
        return this.tokens;
      },
      is: function(ch, chars) {
        return chars.indexOf(ch) !== -1;
      },
      peek: function(i) {
        var num = i || 1;
        return (this.index + num < this.text.length) ? this.text.charAt(this.index + num) : false;
      },
      isNumber: function(ch) {
        return ('0' <= ch && ch <= '9') && typeof ch === "string";
      },
      isWhitespace: function(ch) {
        return (ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\v' || ch === '\u00A0');
      },
      isIdent: function(ch) {
        return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
      },
      isExpOperator: function(ch) {
        return (ch === '-' || ch === '+' || this.isNumber(ch));
      },
      throwError: function(error, start, end) {
        end = end || this.index;
        var colStr = (isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end);
        throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
      },
      readNumber: function() {
        var number = '';
        var start = this.index;
        while (this.index < this.text.length) {
          var ch = lowercase(this.text.charAt(this.index));
          if (ch == '.' || this.isNumber(ch)) {
            number += ch;
          } else {
            var peekCh = this.peek();
            if (ch == 'e' && this.isExpOperator(peekCh)) {
              number += ch;
            } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
              number += ch;
            } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
              this.throwError('Invalid exponent');
            } else {
              break;
            }
          }
          this.index++;
        }
        this.tokens.push({
          index: start,
          text: number,
          constant: true,
          value: Number(number)
        });
      },
      readIdent: function() {
        var start = this.index;
        while (this.index < this.text.length) {
          var ch = this.text.charAt(this.index);
          if (!(this.isIdent(ch) || this.isNumber(ch))) {
            break;
          }
          this.index++;
        }
        this.tokens.push({
          index: start,
          text: this.text.slice(start, this.index),
          identifier: true
        });
      },
      readString: function(quote) {
        var start = this.index;
        this.index++;
        var string = '';
        var rawString = quote;
        var escape = false;
        while (this.index < this.text.length) {
          var ch = this.text.charAt(this.index);
          rawString += ch;
          if (escape) {
            if (ch === 'u') {
              var hex = this.text.substring(this.index + 1, this.index + 5);
              if (!hex.match(/[\da-f]{4}/i)) {
                this.throwError('Invalid unicode escape [\\u' + hex + ']');
              }
              this.index += 4;
              string += String.fromCharCode(parseInt(hex, 16));
            } else {
              var rep = ESCAPE[ch];
              string = string + (rep || ch);
            }
            escape = false;
          } else if (ch === '\\') {
            escape = true;
          } else if (ch === quote) {
            this.index++;
            this.tokens.push({
              index: start,
              text: rawString,
              constant: true,
              value: string
            });
            return;
          } else {
            string += ch;
          }
          this.index++;
        }
        this.throwError('Unterminated quote', start);
      }
    };
    var AST = function(lexer, options) {
      this.lexer = lexer;
      this.options = options;
    };
    AST.Program = 'Program';
    AST.ExpressionStatement = 'ExpressionStatement';
    AST.AssignmentExpression = 'AssignmentExpression';
    AST.ConditionalExpression = 'ConditionalExpression';
    AST.LogicalExpression = 'LogicalExpression';
    AST.BinaryExpression = 'BinaryExpression';
    AST.UnaryExpression = 'UnaryExpression';
    AST.CallExpression = 'CallExpression';
    AST.MemberExpression = 'MemberExpression';
    AST.Identifier = 'Identifier';
    AST.Literal = 'Literal';
    AST.ArrayExpression = 'ArrayExpression';
    AST.Property = 'Property';
    AST.ObjectExpression = 'ObjectExpression';
    AST.ThisExpression = 'ThisExpression';
    AST.NGValueParameter = 'NGValueParameter';
    AST.prototype = {
      ast: function(text) {
        this.text = text;
        this.tokens = this.lexer.lex(text);
        var value = this.program();
        if (this.tokens.length !== 0) {
          this.throwError('is an unexpected token', this.tokens[0]);
        }
        return value;
      },
      program: function() {
        var body = [];
        while (true) {
          if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
            body.push(this.expressionStatement());
          if (!this.expect(';')) {
            return {
              type: AST.Program,
              body: body
            };
          }
        }
      },
      expressionStatement: function() {
        return {
          type: AST.ExpressionStatement,
          expression: this.filterChain()
        };
      },
      filterChain: function() {
        var left = this.expression();
        var token;
        while ((token = this.expect('|'))) {
          left = this.filter(left);
        }
        return left;
      },
      expression: function() {
        return this.assignment();
      },
      assignment: function() {
        var result = this.ternary();
        if (this.expect('=')) {
          result = {
            type: AST.AssignmentExpression,
            left: result,
            right: this.assignment(),
            operator: '='
          };
        }
        return result;
      },
      ternary: function() {
        var test = this.logicalOR();
        var alternate;
        var consequent;
        if (this.expect('?')) {
          alternate = this.expression();
          if (this.consume(':')) {
            consequent = this.expression();
            return {
              type: AST.ConditionalExpression,
              test: test,
              alternate: alternate,
              consequent: consequent
            };
          }
        }
        return test;
      },
      logicalOR: function() {
        var left = this.logicalAND();
        while (this.expect('||')) {
          left = {
            type: AST.LogicalExpression,
            operator: '||',
            left: left,
            right: this.logicalAND()
          };
        }
        return left;
      },
      logicalAND: function() {
        var left = this.equality();
        while (this.expect('&&')) {
          left = {
            type: AST.LogicalExpression,
            operator: '&&',
            left: left,
            right: this.equality()
          };
        }
        return left;
      },
      equality: function() {
        var left = this.relational();
        var token;
        while ((token = this.expect('==', '!=', '===', '!=='))) {
          left = {
            type: AST.BinaryExpression,
            operator: token.text,
            left: left,
            right: this.relational()
          };
        }
        return left;
      },
      relational: function() {
        var left = this.additive();
        var token;
        while ((token = this.expect('<', '>', '<=', '>='))) {
          left = {
            type: AST.BinaryExpression,
            operator: token.text,
            left: left,
            right: this.additive()
          };
        }
        return left;
      },
      additive: function() {
        var left = this.multiplicative();
        var token;
        while ((token = this.expect('+', '-'))) {
          left = {
            type: AST.BinaryExpression,
            operator: token.text,
            left: left,
            right: this.multiplicative()
          };
        }
        return left;
      },
      multiplicative: function() {
        var left = this.unary();
        var token;
        while ((token = this.expect('*', '/', '%'))) {
          left = {
            type: AST.BinaryExpression,
            operator: token.text,
            left: left,
            right: this.unary()
          };
        }
        return left;
      },
      unary: function() {
        var token;
        if ((token = this.expect('+', '-', '!'))) {
          return {
            type: AST.UnaryExpression,
            operator: token.text,
            prefix: true,
            argument: this.unary()
          };
        } else {
          return this.primary();
        }
      },
      primary: function() {
        var primary;
        if (this.expect('(')) {
          primary = this.filterChain();
          this.consume(')');
        } else if (this.expect('[')) {
          primary = this.arrayDeclaration();
        } else if (this.expect('{')) {
          primary = this.object();
        } else if (this.constants.hasOwnProperty(this.peek().text)) {
          primary = copy(this.constants[this.consume().text]);
        } else if (this.peek().identifier) {
          primary = this.identifier();
        } else if (this.peek().constant) {
          primary = this.constant();
        } else {
          this.throwError('not a primary expression', this.peek());
        }
        var next;
        while ((next = this.expect('(', '[', '.'))) {
          if (next.text === '(') {
            primary = {
              type: AST.CallExpression,
              callee: primary,
              arguments: this.parseArguments()
            };
            this.consume(')');
          } else if (next.text === '[') {
            primary = {
              type: AST.MemberExpression,
              object: primary,
              property: this.expression(),
              computed: true
            };
            this.consume(']');
          } else if (next.text === '.') {
            primary = {
              type: AST.MemberExpression,
              object: primary,
              property: this.identifier(),
              computed: false
            };
          } else {
            this.throwError('IMPOSSIBLE');
          }
        }
        return primary;
      },
      filter: function(baseExpression) {
        var args = [baseExpression];
        var result = {
          type: AST.CallExpression,
          callee: this.identifier(),
          arguments: args,
          filter: true
        };
        while (this.expect(':')) {
          args.push(this.expression());
        }
        return result;
      },
      parseArguments: function() {
        var args = [];
        if (this.peekToken().text !== ')') {
          do {
            args.push(this.expression());
          } while (this.expect(','));
        }
        return args;
      },
      identifier: function() {
        var token = this.consume();
        if (!token.identifier) {
          this.throwError('is not a valid identifier', token);
        }
        return {
          type: AST.Identifier,
          name: token.text
        };
      },
      constant: function() {
        return {
          type: AST.Literal,
          value: this.consume().value
        };
      },
      arrayDeclaration: function() {
        var elements = [];
        if (this.peekToken().text !== ']') {
          do {
            if (this.peek(']')) {
              break;
            }
            elements.push(this.expression());
          } while (this.expect(','));
        }
        this.consume(']');
        return {
          type: AST.ArrayExpression,
          elements: elements
        };
      },
      object: function() {
        var properties = [],
            property;
        if (this.peekToken().text !== '}') {
          do {
            if (this.peek('}')) {
              break;
            }
            property = {
              type: AST.Property,
              kind: 'init'
            };
            if (this.peek().constant) {
              property.key = this.constant();
            } else if (this.peek().identifier) {
              property.key = this.identifier();
            } else {
              this.throwError("invalid key", this.peek());
            }
            this.consume(':');
            property.value = this.expression();
            properties.push(property);
          } while (this.expect(','));
        }
        this.consume('}');
        return {
          type: AST.ObjectExpression,
          properties: properties
        };
      },
      throwError: function(msg, token) {
        throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, (token.index + 1), this.text, this.text.substring(token.index));
      },
      consume: function(e1) {
        if (this.tokens.length === 0) {
          throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
        }
        var token = this.expect(e1);
        if (!token) {
          this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
        }
        return token;
      },
      peekToken: function() {
        if (this.tokens.length === 0) {
          throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
        }
        return this.tokens[0];
      },
      peek: function(e1, e2, e3, e4) {
        return this.peekAhead(0, e1, e2, e3, e4);
      },
      peekAhead: function(i, e1, e2, e3, e4) {
        if (this.tokens.length > i) {
          var token = this.tokens[i];
          var t = token.text;
          if (t === e1 || t === e2 || t === e3 || t === e4 || (!e1 && !e2 && !e3 && !e4)) {
            return token;
          }
        }
        return false;
      },
      expect: function(e1, e2, e3, e4) {
        var token = this.peek(e1, e2, e3, e4);
        if (token) {
          this.tokens.shift();
          return token;
        }
        return false;
      },
      constants: {
        'true': {
          type: AST.Literal,
          value: true
        },
        'false': {
          type: AST.Literal,
          value: false
        },
        'null': {
          type: AST.Literal,
          value: null
        },
        'undefined': {
          type: AST.Literal,
          value: undefined
        },
        'this': {type: AST.ThisExpression}
      }
    };
    function ifDefined(v, d) {
      return typeof v !== 'undefined' ? v : d;
    }
    function plusFn(l, r) {
      if (typeof l === 'undefined')
        return r;
      if (typeof r === 'undefined')
        return l;
      return l + r;
    }
    function isStateless($filter, filterName) {
      var fn = $filter(filterName);
      return !fn.$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
      var allConstants;
      var argsToWatch;
      switch (ast.type) {
        case AST.Program:
          allConstants = true;
          forEach(ast.body, function(expr) {
            findConstantAndWatchExpressions(expr.expression, $filter);
            allConstants = allConstants && expr.expression.constant;
          });
          ast.constant = allConstants;
          break;
        case AST.Literal:
          ast.constant = true;
          ast.toWatch = [];
          break;
        case AST.UnaryExpression:
          findConstantAndWatchExpressions(ast.argument, $filter);
          ast.constant = ast.argument.constant;
          ast.toWatch = ast.argument.toWatch;
          break;
        case AST.BinaryExpression:
          findConstantAndWatchExpressions(ast.left, $filter);
          findConstantAndWatchExpressions(ast.right, $filter);
          ast.constant = ast.left.constant && ast.right.constant;
          ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
          break;
        case AST.LogicalExpression:
          findConstantAndWatchExpressions(ast.left, $filter);
          findConstantAndWatchExpressions(ast.right, $filter);
          ast.constant = ast.left.constant && ast.right.constant;
          ast.toWatch = ast.constant ? [] : [ast];
          break;
        case AST.ConditionalExpression:
          findConstantAndWatchExpressions(ast.test, $filter);
          findConstantAndWatchExpressions(ast.alternate, $filter);
          findConstantAndWatchExpressions(ast.consequent, $filter);
          ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
          ast.toWatch = ast.constant ? [] : [ast];
          break;
        case AST.Identifier:
          ast.constant = false;
          ast.toWatch = [ast];
          break;
        case AST.MemberExpression:
          findConstantAndWatchExpressions(ast.object, $filter);
          if (ast.computed) {
            findConstantAndWatchExpressions(ast.property, $filter);
          }
          ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
          ast.toWatch = [ast];
          break;
        case AST.CallExpression:
          allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
          argsToWatch = [];
          forEach(ast.arguments, function(expr) {
            findConstantAndWatchExpressions(expr, $filter);
            allConstants = allConstants && expr.constant;
            if (!expr.constant) {
              argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }
          });
          ast.constant = allConstants;
          ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
          break;
        case AST.AssignmentExpression:
          findConstantAndWatchExpressions(ast.left, $filter);
          findConstantAndWatchExpressions(ast.right, $filter);
          ast.constant = ast.left.constant && ast.right.constant;
          ast.toWatch = [ast];
          break;
        case AST.ArrayExpression:
          allConstants = true;
          argsToWatch = [];
          forEach(ast.elements, function(expr) {
            findConstantAndWatchExpressions(expr, $filter);
            allConstants = allConstants && expr.constant;
            if (!expr.constant) {
              argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }
          });
          ast.constant = allConstants;
          ast.toWatch = argsToWatch;
          break;
        case AST.ObjectExpression:
          allConstants = true;
          argsToWatch = [];
          forEach(ast.properties, function(property) {
            findConstantAndWatchExpressions(property.value, $filter);
            allConstants = allConstants && property.value.constant;
            if (!property.value.constant) {
              argsToWatch.push.apply(argsToWatch, property.value.toWatch);
            }
          });
          ast.constant = allConstants;
          ast.toWatch = argsToWatch;
          break;
        case AST.ThisExpression:
          ast.constant = false;
          ast.toWatch = [];
          break;
      }
    }
    function getInputs(body) {
      if (body.length != 1)
        return;
      var lastExpression = body[0].expression;
      var candidate = lastExpression.toWatch;
      if (candidate.length !== 1)
        return candidate;
      return candidate[0] !== lastExpression ? candidate : undefined;
    }
    function isAssignable(ast) {
      return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
      if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
        return {
          type: AST.AssignmentExpression,
          left: ast.body[0].expression,
          right: {type: AST.NGValueParameter},
          operator: '='
        };
      }
    }
    function isLiteral(ast) {
      return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
      return ast.constant;
    }
    function ASTCompiler(astBuilder, $filter) {
      this.astBuilder = astBuilder;
      this.$filter = $filter;
    }
    ASTCompiler.prototype = {
      compile: function(expression, expensiveChecks) {
        var self = this;
        var ast = this.astBuilder.ast(expression);
        this.state = {
          nextId: 0,
          filters: {},
          expensiveChecks: expensiveChecks,
          fn: {
            vars: [],
            body: [],
            own: {}
          },
          assign: {
            vars: [],
            body: [],
            own: {}
          },
          inputs: []
        };
        findConstantAndWatchExpressions(ast, self.$filter);
        var extra = '';
        var assignable;
        this.stage = 'assign';
        if ((assignable = assignableAST(ast))) {
          this.state.computing = 'assign';
          var result = this.nextId();
          this.recurse(assignable, result);
          extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
        }
        var toWatch = getInputs(ast.body);
        self.stage = 'inputs';
        forEach(toWatch, function(watch, key) {
          var fnKey = 'fn' + key;
          self.state[fnKey] = {
            vars: [],
            body: [],
            own: {}
          };
          self.state.computing = fnKey;
          var intoId = self.nextId();
          self.recurse(watch, intoId);
          self.return_(intoId);
          self.state.inputs.push(fnKey);
          watch.watchId = key;
        });
        this.state.computing = 'fn';
        this.stage = 'main';
        this.recurse(ast);
        var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
        var fn = (new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'ifDefined', 'plus', 'text', fnString))(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, ifDefined, plusFn, expression);
        this.state = this.stage = undefined;
        fn.literal = isLiteral(ast);
        fn.constant = isConstant(ast);
        return fn;
      },
      USE: 'use',
      STRICT: 'strict',
      watchFns: function() {
        var result = [];
        var fns = this.state.inputs;
        var self = this;
        forEach(fns, function(name) {
          result.push('var ' + name + '=' + self.generateFunction(name, 's'));
        });
        if (fns.length) {
          result.push('fn.inputs=[' + fns.join(',') + '];');
        }
        return result.join('');
      },
      generateFunction: function(name, params) {
        return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
      },
      filterPrefix: function() {
        var parts = [];
        var self = this;
        forEach(this.state.filters, function(id, filter) {
          parts.push(id + '=$filter(' + self.escape(filter) + ')');
        });
        if (parts.length)
          return 'var ' + parts.join(',') + ';';
        return '';
      },
      varsPrefix: function(section) {
        return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
      },
      body: function(section) {
        return this.state[section].body.join('');
      },
      recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
        var left,
            right,
            self = this,
            args,
            expression;
        recursionFn = recursionFn || noop;
        if (!skipWatchIdCheck && isDefined(ast.watchId)) {
          intoId = intoId || this.nextId();
          this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
          return;
        }
        switch (ast.type) {
          case AST.Program:
            forEach(ast.body, function(expression, pos) {
              self.recurse(expression.expression, undefined, undefined, function(expr) {
                right = expr;
              });
              if (pos !== ast.body.length - 1) {
                self.current().body.push(right, ';');
              } else {
                self.return_(right);
              }
            });
            break;
          case AST.Literal:
            expression = this.escape(ast.value);
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
          case AST.UnaryExpression:
            this.recurse(ast.argument, undefined, undefined, function(expr) {
              right = expr;
            });
            expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
          case AST.BinaryExpression:
            this.recurse(ast.left, undefined, undefined, function(expr) {
              left = expr;
            });
            this.recurse(ast.right, undefined, undefined, function(expr) {
              right = expr;
            });
            if (ast.operator === '+') {
              expression = this.plus(left, right);
            } else if (ast.operator === '-') {
              expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
            } else {
              expression = '(' + left + ')' + ast.operator + '(' + right + ')';
            }
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
          case AST.LogicalExpression:
            intoId = intoId || this.nextId();
            self.recurse(ast.left, intoId);
            self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
            recursionFn(intoId);
            break;
          case AST.ConditionalExpression:
            intoId = intoId || this.nextId();
            self.recurse(ast.test, intoId);
            self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
            recursionFn(intoId);
            break;
          case AST.Identifier:
            intoId = intoId || this.nextId();
            if (nameId) {
              nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
              nameId.computed = false;
              nameId.name = ast.name;
            }
            ensureSafeMemberName(ast.name);
            self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function() {
              self.if_(self.stage === 'inputs' || 's', function() {
                if (create && create !== 1) {
                  self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                }
                self.assign(intoId, self.nonComputedMember('s', ast.name));
              });
            }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
            if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
              self.addEnsureSafeObject(intoId);
            }
            recursionFn(intoId);
            break;
          case AST.MemberExpression:
            left = nameId && (nameId.context = this.nextId()) || this.nextId();
            intoId = intoId || this.nextId();
            self.recurse(ast.object, left, undefined, function() {
              self.if_(self.notNull(left), function() {
                if (ast.computed) {
                  right = self.nextId();
                  self.recurse(ast.property, right);
                  self.addEnsureSafeMemberName(right);
                  if (create && create !== 1) {
                    self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                  }
                  expression = self.ensureSafeObject(self.computedMember(left, right));
                  self.assign(intoId, expression);
                  if (nameId) {
                    nameId.computed = true;
                    nameId.name = right;
                  }
                } else {
                  ensureSafeMemberName(ast.property.name);
                  if (create && create !== 1) {
                    self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                  }
                  expression = self.nonComputedMember(left, ast.property.name);
                  if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                    expression = self.ensureSafeObject(expression);
                  }
                  self.assign(intoId, expression);
                  if (nameId) {
                    nameId.computed = false;
                    nameId.name = ast.property.name;
                  }
                }
              }, function() {
                self.assign(intoId, 'undefined');
              });
              recursionFn(intoId);
            }, !!create);
            break;
          case AST.CallExpression:
            intoId = intoId || this.nextId();
            if (ast.filter) {
              right = self.filter(ast.callee.name);
              args = [];
              forEach(ast.arguments, function(expr) {
                var argument = self.nextId();
                self.recurse(expr, argument);
                args.push(argument);
              });
              expression = right + '(' + args.join(',') + ')';
              self.assign(intoId, expression);
              recursionFn(intoId);
            } else {
              right = self.nextId();
              left = {};
              args = [];
              self.recurse(ast.callee, right, left, function() {
                self.if_(self.notNull(right), function() {
                  self.addEnsureSafeFunction(right);
                  forEach(ast.arguments, function(expr) {
                    self.recurse(expr, self.nextId(), undefined, function(argument) {
                      args.push(self.ensureSafeObject(argument));
                    });
                  });
                  if (left.name) {
                    if (!self.state.expensiveChecks) {
                      self.addEnsureSafeObject(left.context);
                    }
                    expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                  } else {
                    expression = right + '(' + args.join(',') + ')';
                  }
                  expression = self.ensureSafeObject(expression);
                  self.assign(intoId, expression);
                }, function() {
                  self.assign(intoId, 'undefined');
                });
                recursionFn(intoId);
              });
            }
            break;
          case AST.AssignmentExpression:
            right = this.nextId();
            left = {};
            if (!isAssignable(ast.left)) {
              throw $parseMinErr('lval', 'Trying to assing a value to a non l-value');
            }
            this.recurse(ast.left, undefined, left, function() {
              self.if_(self.notNull(left.context), function() {
                self.recurse(ast.right, right);
                self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                self.assign(intoId, expression);
                recursionFn(intoId || expression);
              });
            }, 1);
            break;
          case AST.ArrayExpression:
            args = [];
            forEach(ast.elements, function(expr) {
              self.recurse(expr, self.nextId(), undefined, function(argument) {
                args.push(argument);
              });
            });
            expression = '[' + args.join(',') + ']';
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
          case AST.ObjectExpression:
            args = [];
            forEach(ast.properties, function(property) {
              self.recurse(property.value, self.nextId(), undefined, function(expr) {
                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value)) + ':' + expr);
              });
            });
            expression = '{' + args.join(',') + '}';
            this.assign(intoId, expression);
            recursionFn(expression);
            break;
          case AST.ThisExpression:
            this.assign(intoId, 's');
            recursionFn('s');
            break;
          case AST.NGValueParameter:
            this.assign(intoId, 'v');
            recursionFn('v');
            break;
        }
      },
      getHasOwnProperty: function(element, property) {
        var key = element + '.' + property;
        var own = this.current().own;
        if (!own.hasOwnProperty(key)) {
          own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
        }
        return own[key];
      },
      assign: function(id, value) {
        if (!id)
          return;
        this.current().body.push(id, '=', value, ';');
        return id;
      },
      filter: function(filterName) {
        if (!this.state.filters.hasOwnProperty(filterName)) {
          this.state.filters[filterName] = this.nextId(true);
        }
        return this.state.filters[filterName];
      },
      ifDefined: function(id, defaultValue) {
        return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
      },
      plus: function(left, right) {
        return 'plus(' + left + ',' + right + ')';
      },
      return_: function(id) {
        this.current().body.push('return ', id, ';');
      },
      if_: function(test, alternate, consequent) {
        if (test === true) {
          alternate();
        } else {
          var body = this.current().body;
          body.push('if(', test, '){');
          alternate();
          body.push('}');
          if (consequent) {
            body.push('else{');
            consequent();
            body.push('}');
          }
        }
      },
      not: function(expression) {
        return '!(' + expression + ')';
      },
      notNull: function(expression) {
        return expression + '!=null';
      },
      nonComputedMember: function(left, right) {
        return left + '.' + right;
      },
      computedMember: function(left, right) {
        return left + '[' + right + ']';
      },
      member: function(left, right, computed) {
        if (computed)
          return this.computedMember(left, right);
        return this.nonComputedMember(left, right);
      },
      addEnsureSafeObject: function(item) {
        this.current().body.push(this.ensureSafeObject(item), ';');
      },
      addEnsureSafeMemberName: function(item) {
        this.current().body.push(this.ensureSafeMemberName(item), ';');
      },
      addEnsureSafeFunction: function(item) {
        this.current().body.push(this.ensureSafeFunction(item), ';');
      },
      ensureSafeObject: function(item) {
        return 'ensureSafeObject(' + item + ',text)';
      },
      ensureSafeMemberName: function(item) {
        return 'ensureSafeMemberName(' + item + ',text)';
      },
      ensureSafeFunction: function(item) {
        return 'ensureSafeFunction(' + item + ',text)';
      },
      lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
        var self = this;
        return function() {
          self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
        };
      },
      lazyAssign: function(id, value) {
        var self = this;
        return function() {
          self.assign(id, value);
        };
      },
      stringEscapeRegex: /[^ a-zA-Z0-9]/g,
      stringEscapeFn: function(c) {
        return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
      },
      escape: function(value) {
        if (isString(value))
          return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
        if (isNumber(value))
          return value.toString();
        if (value === true)
          return 'true';
        if (value === false)
          return 'false';
        if (value === null)
          return 'null';
        if (typeof value === 'undefined')
          return 'undefined';
        throw $parseMinErr('esc', 'IMPOSSIBLE');
      },
      nextId: function(skip, init) {
        var id = 'v' + (this.state.nextId++);
        if (!skip) {
          this.current().vars.push(id + (init ? '=' + init : ''));
        }
        return id;
      },
      current: function() {
        return this.state[this.state.computing];
      }
    };
    function ASTInterpreter(astBuilder, $filter) {
      this.astBuilder = astBuilder;
      this.$filter = $filter;
    }
    ASTInterpreter.prototype = {
      compile: function(expression, expensiveChecks) {
        var self = this;
        var ast = this.astBuilder.ast(expression);
        this.expression = expression;
        this.expensiveChecks = expensiveChecks;
        findConstantAndWatchExpressions(ast, self.$filter);
        var assignable;
        var assign;
        if ((assignable = assignableAST(ast))) {
          assign = this.recurse(assignable);
        }
        var toWatch = getInputs(ast.body);
        var inputs;
        if (toWatch) {
          inputs = [];
          forEach(toWatch, function(watch, key) {
            var input = self.recurse(watch);
            watch.input = input;
            inputs.push(input);
            watch.watchId = key;
          });
        }
        var expressions = [];
        forEach(ast.body, function(expression) {
          expressions.push(self.recurse(expression.expression));
        });
        var fn = ast.body.length === 0 ? function() {} : ast.body.length === 1 ? expressions[0] : function(scope, locals) {
          var lastValue;
          forEach(expressions, function(exp) {
            lastValue = exp(scope, locals);
          });
          return lastValue;
        };
        if (assign) {
          fn.assign = function(scope, value, locals) {
            return assign(scope, locals, value);
          };
        }
        if (inputs) {
          fn.inputs = inputs;
        }
        fn.literal = isLiteral(ast);
        fn.constant = isConstant(ast);
        return fn;
      },
      recurse: function(ast, context, create) {
        var left,
            right,
            self = this,
            args,
            expression;
        if (ast.input) {
          return this.inputs(ast.input, ast.watchId);
        }
        switch (ast.type) {
          case AST.Literal:
            return this.value(ast.value, context);
          case AST.UnaryExpression:
            right = this.recurse(ast.argument);
            return this['unary' + ast.operator](right, context);
          case AST.BinaryExpression:
            left = this.recurse(ast.left);
            right = this.recurse(ast.right);
            return this['binary' + ast.operator](left, right, context);
          case AST.LogicalExpression:
            left = this.recurse(ast.left);
            right = this.recurse(ast.right);
            return this['binary' + ast.operator](left, right, context);
          case AST.ConditionalExpression:
            return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
          case AST.Identifier:
            ensureSafeMemberName(ast.name, self.expression);
            return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
          case AST.MemberExpression:
            left = this.recurse(ast.object, false, !!create);
            if (!ast.computed) {
              ensureSafeMemberName(ast.property.name, self.expression);
              right = ast.property.name;
            }
            if (ast.computed)
              right = this.recurse(ast.property);
            return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
          case AST.CallExpression:
            args = [];
            forEach(ast.arguments, function(expr) {
              args.push(self.recurse(expr));
            });
            if (ast.filter)
              right = this.$filter(ast.callee.name);
            if (!ast.filter)
              right = this.recurse(ast.callee, true);
            return ast.filter ? function(scope, locals, assign, inputs) {
              var values = [];
              for (var i = 0; i < args.length; ++i) {
                values.push(args[i](scope, locals, assign, inputs));
              }
              var value = right.apply(undefined, values, inputs);
              return context ? {
                context: undefined,
                name: undefined,
                value: value
              } : value;
            } : function(scope, locals, assign, inputs) {
              var rhs = right(scope, locals, assign, inputs);
              var value;
              if (rhs.value != null) {
                ensureSafeObject(rhs.context, self.expression);
                ensureSafeFunction(rhs.value, self.expression);
                var values = [];
                for (var i = 0; i < args.length; ++i) {
                  values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                }
                value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
              }
              return context ? {value: value} : value;
            };
          case AST.AssignmentExpression:
            left = this.recurse(ast.left, true, 1);
            right = this.recurse(ast.right);
            return function(scope, locals, assign, inputs) {
              var lhs = left(scope, locals, assign, inputs);
              var rhs = right(scope, locals, assign, inputs);
              ensureSafeObject(lhs.value, self.expression);
              lhs.context[lhs.name] = rhs;
              return context ? {value: rhs} : rhs;
            };
          case AST.ArrayExpression:
            args = [];
            forEach(ast.elements, function(expr) {
              args.push(self.recurse(expr));
            });
            return function(scope, locals, assign, inputs) {
              var value = [];
              for (var i = 0; i < args.length; ++i) {
                value.push(args[i](scope, locals, assign, inputs));
              }
              return context ? {value: value} : value;
            };
          case AST.ObjectExpression:
            args = [];
            forEach(ast.properties, function(property) {
              args.push({
                key: property.key.type === AST.Identifier ? property.key.name : ('' + property.key.value),
                value: self.recurse(property.value)
              });
            });
            return function(scope, locals, assign, inputs) {
              var value = {};
              for (var i = 0; i < args.length; ++i) {
                value[args[i].key] = args[i].value(scope, locals, assign, inputs);
              }
              return context ? {value: value} : value;
            };
          case AST.ThisExpression:
            return function(scope) {
              return context ? {value: scope} : scope;
            };
          case AST.NGValueParameter:
            return function(scope, locals, assign, inputs) {
              return context ? {value: assign} : assign;
            };
        }
      },
      'unary+': function(argument, context) {
        return function(scope, locals, assign, inputs) {
          var arg = argument(scope, locals, assign, inputs);
          if (isDefined(arg)) {
            arg = +arg;
          } else {
            arg = 0;
          }
          return context ? {value: arg} : arg;
        };
      },
      'unary-': function(argument, context) {
        return function(scope, locals, assign, inputs) {
          var arg = argument(scope, locals, assign, inputs);
          if (isDefined(arg)) {
            arg = -arg;
          } else {
            arg = 0;
          }
          return context ? {value: arg} : arg;
        };
      },
      'unary!': function(argument, context) {
        return function(scope, locals, assign, inputs) {
          var arg = !argument(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary+': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var lhs = left(scope, locals, assign, inputs);
          var rhs = right(scope, locals, assign, inputs);
          var arg = plusFn(lhs, rhs);
          return context ? {value: arg} : arg;
        };
      },
      'binary-': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var lhs = left(scope, locals, assign, inputs);
          var rhs = right(scope, locals, assign, inputs);
          var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
          return context ? {value: arg} : arg;
        };
      },
      'binary*': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary/': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary%': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary===': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary!==': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary==': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary!=': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary<': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary>': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary<=': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary>=': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary&&': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'binary||': function(left, right, context) {
        return function(scope, locals, assign, inputs) {
          var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      'ternary?:': function(test, alternate, consequent, context) {
        return function(scope, locals, assign, inputs) {
          var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
          return context ? {value: arg} : arg;
        };
      },
      value: function(value, context) {
        return function() {
          return context ? {
            context: undefined,
            name: undefined,
            value: value
          } : value;
        };
      },
      identifier: function(name, expensiveChecks, context, create, expression) {
        return function(scope, locals, assign, inputs) {
          var base = locals && (name in locals) ? locals : scope;
          if (create && create !== 1 && base && !(base[name])) {
            base[name] = {};
          }
          var value = base ? base[name] : undefined;
          if (expensiveChecks) {
            ensureSafeObject(value, expression);
          }
          if (context) {
            return {
              context: base,
              name: name,
              value: value
            };
          } else {
            return value;
          }
        };
      },
      computedMember: function(left, right, context, create, expression) {
        return function(scope, locals, assign, inputs) {
          var lhs = left(scope, locals, assign, inputs);
          var rhs;
          var value;
          if (lhs != null) {
            rhs = right(scope, locals, assign, inputs);
            ensureSafeMemberName(rhs, expression);
            if (create && create !== 1 && lhs && !(lhs[rhs])) {
              lhs[rhs] = {};
            }
            value = lhs[rhs];
            ensureSafeObject(value, expression);
          }
          if (context) {
            return {
              context: lhs,
              name: rhs,
              value: value
            };
          } else {
            return value;
          }
        };
      },
      nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
        return function(scope, locals, assign, inputs) {
          var lhs = left(scope, locals, assign, inputs);
          if (create && create !== 1 && lhs && !(lhs[right])) {
            lhs[right] = {};
          }
          var value = lhs != null ? lhs[right] : undefined;
          if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
            ensureSafeObject(value, expression);
          }
          if (context) {
            return {
              context: lhs,
              name: right,
              value: value
            };
          } else {
            return value;
          }
        };
      },
      inputs: function(input, watchId) {
        return function(scope, value, locals, inputs) {
          if (inputs)
            return inputs[watchId];
          return input(scope, value, locals);
        };
      }
    };
    var Parser = function(lexer, $filter, options) {
      this.lexer = lexer;
      this.$filter = $filter;
      this.options = options;
      this.ast = new AST(this.lexer);
      this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
    };
    Parser.prototype = {
      constructor: Parser,
      parse: function(text) {
        return this.astCompiler.compile(text, this.options.expensiveChecks);
      }
    };
    function setter(obj, path, setValue, fullExp) {
      ensureSafeObject(obj, fullExp);
      var element = path.split('.'),
          key;
      for (var i = 0; element.length > 1; i++) {
        key = ensureSafeMemberName(element.shift(), fullExp);
        var propertyObj = ensureSafeObject(obj[key], fullExp);
        if (!propertyObj) {
          propertyObj = {};
          obj[key] = propertyObj;
        }
        obj = propertyObj;
      }
      key = ensureSafeMemberName(element.shift(), fullExp);
      ensureSafeObject(obj[key], fullExp);
      obj[key] = setValue;
      return setValue;
    }
    var getterFnCacheDefault = createMap();
    var getterFnCacheExpensive = createMap();
    function isPossiblyDangerousMemberName(name) {
      return name == 'constructor';
    }
    var objectValueOf = Object.prototype.valueOf;
    function getValueOf(value) {
      return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
      var cacheDefault = createMap();
      var cacheExpensive = createMap();
      this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {
        var $parseOptions = {
          csp: $sniffer.csp,
          expensiveChecks: false
        },
            $parseOptionsExpensive = {
              csp: $sniffer.csp,
              expensiveChecks: true
            };
        return function $parse(exp, interceptorFn, expensiveChecks) {
          var parsedExpression,
              oneTime,
              cacheKey;
          switch (typeof exp) {
            case 'string':
              exp = exp.trim();
              cacheKey = exp;
              var cache = (expensiveChecks ? cacheExpensive : cacheDefault);
              parsedExpression = cache[cacheKey];
              if (!parsedExpression) {
                if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                  oneTime = true;
                  exp = exp.substring(2);
                }
                var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                var lexer = new Lexer(parseOptions);
                var parser = new Parser(lexer, $filter, parseOptions);
                parsedExpression = parser.parse(exp);
                if (parsedExpression.constant) {
                  parsedExpression.$$watchDelegate = constantWatchDelegate;
                } else if (oneTime) {
                  parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                } else if (parsedExpression.inputs) {
                  parsedExpression.$$watchDelegate = inputsWatchDelegate;
                }
                cache[cacheKey] = parsedExpression;
              }
              return addInterceptor(parsedExpression, interceptorFn);
            case 'function':
              return addInterceptor(exp, interceptorFn);
            default:
              return noop;
          }
        };
        function expressionInputDirtyCheck(newValue, oldValueOfValue) {
          if (newValue == null || oldValueOfValue == null) {
            return newValue === oldValueOfValue;
          }
          if (typeof newValue === 'object') {
            newValue = getValueOf(newValue);
            if (typeof newValue === 'object') {
              return false;
            }
          }
          return newValue === oldValueOfValue || (newValue !== newValue && oldValueOfValue !== oldValueOfValue);
        }
        function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
          var inputExpressions = parsedExpression.inputs;
          var lastResult;
          if (inputExpressions.length === 1) {
            var oldInputValueOf = expressionInputDirtyCheck;
            inputExpressions = inputExpressions[0];
            return scope.$watch(function expressionInputWatch(scope) {
              var newInputValue = inputExpressions(scope);
              if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                oldInputValueOf = newInputValue && getValueOf(newInputValue);
              }
              return lastResult;
            }, listener, objectEquality, prettyPrintExpression);
          }
          var oldInputValueOfValues = [];
          var oldInputValues = [];
          for (var i = 0,
              ii = inputExpressions.length; i < ii; i++) {
            oldInputValueOfValues[i] = expressionInputDirtyCheck;
            oldInputValues[i] = null;
          }
          return scope.$watch(function expressionInputsWatch(scope) {
            var changed = false;
            for (var i = 0,
                ii = inputExpressions.length; i < ii; i++) {
              var newInputValue = inputExpressions[i](scope);
              if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                oldInputValues[i] = newInputValue;
                oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
              }
            }
            if (changed) {
              lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
            }
            return lastResult;
          }, listener, objectEquality, prettyPrintExpression);
        }
        function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
          var unwatch,
              lastValue;
          return unwatch = scope.$watch(function oneTimeWatch(scope) {
            return parsedExpression(scope);
          }, function oneTimeListener(value, old, scope) {
            lastValue = value;
            if (isFunction(listener)) {
              listener.apply(this, arguments);
            }
            if (isDefined(value)) {
              scope.$$postDigest(function() {
                if (isDefined(lastValue)) {
                  unwatch();
                }
              });
            }
          }, objectEquality);
        }
        function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
          var unwatch,
              lastValue;
          return unwatch = scope.$watch(function oneTimeWatch(scope) {
            return parsedExpression(scope);
          }, function oneTimeListener(value, old, scope) {
            lastValue = value;
            if (isFunction(listener)) {
              listener.call(this, value, old, scope);
            }
            if (isAllDefined(value)) {
              scope.$$postDigest(function() {
                if (isAllDefined(lastValue))
                  unwatch();
              });
            }
          }, objectEquality);
          function isAllDefined(value) {
            var allDefined = true;
            forEach(value, function(val) {
              if (!isDefined(val))
                allDefined = false;
            });
            return allDefined;
          }
        }
        function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
          var unwatch;
          return unwatch = scope.$watch(function constantWatch(scope) {
            return parsedExpression(scope);
          }, function constantListener(value, old, scope) {
            if (isFunction(listener)) {
              listener.apply(this, arguments);
            }
            unwatch();
          }, objectEquality);
        }
        function addInterceptor(parsedExpression, interceptorFn) {
          if (!interceptorFn)
            return parsedExpression;
          var watchDelegate = parsedExpression.$$watchDelegate;
          var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
          var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
            var value = parsedExpression(scope, locals, assign, inputs);
            return interceptorFn(value, scope, locals);
          } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
            var value = parsedExpression(scope, locals, assign, inputs);
            var result = interceptorFn(value, scope, locals);
            return isDefined(value) ? result : value;
          };
          if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
            fn.$$watchDelegate = parsedExpression.$$watchDelegate;
          } else if (!interceptorFn.$stateful) {
            fn.$$watchDelegate = inputsWatchDelegate;
            fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
          }
          return fn;
        }
      }];
    }
    function $QProvider() {
      this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
        return qFactory(function(callback) {
          $rootScope.$evalAsync(callback);
        }, $exceptionHandler);
      }];
    }
    function $$QProvider() {
      this.$get = ['$browser', '$exceptionHandler', function($browser, $exceptionHandler) {
        return qFactory(function(callback) {
          $browser.defer(callback);
        }, $exceptionHandler);
      }];
    }
    function qFactory(nextTick, exceptionHandler) {
      var $qMinErr = minErr('$q', TypeError);
      function callOnce(self, resolveFn, rejectFn) {
        var called = false;
        function wrap(fn) {
          return function(value) {
            if (called)
              return;
            called = true;
            fn.call(self, value);
          };
        }
        return [wrap(resolveFn), wrap(rejectFn)];
      }
      var defer = function() {
        return new Deferred();
      };
      function Promise() {
        this.$$state = {status: 0};
      }
      Promise.prototype = {
        then: function(onFulfilled, onRejected, progressBack) {
          var result = new Deferred();
          this.$$state.pending = this.$$state.pending || [];
          this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]);
          if (this.$$state.status > 0)
            scheduleProcessQueue(this.$$state);
          return result.promise;
        },
        "catch": function(callback) {
          return this.then(null, callback);
        },
        "finally": function(callback, progressBack) {
          return this.then(function(value) {
            return handleCallback(value, true, callback);
          }, function(error) {
            return handleCallback(error, false, callback);
          }, progressBack);
        }
      };
      function simpleBind(context, fn) {
        return function(value) {
          fn.call(context, value);
        };
      }
      function processQueue(state) {
        var fn,
            deferred,
            pending;
        pending = state.pending;
        state.processScheduled = false;
        state.pending = undefined;
        for (var i = 0,
            ii = pending.length; i < ii; ++i) {
          deferred = pending[i][0];
          fn = pending[i][state.status];
          try {
            if (isFunction(fn)) {
              deferred.resolve(fn(state.value));
            } else if (state.status === 1) {
              deferred.resolve(state.value);
            } else {
              deferred.reject(state.value);
            }
          } catch (e) {
            deferred.reject(e);
            exceptionHandler(e);
          }
        }
      }
      function scheduleProcessQueue(state) {
        if (state.processScheduled || !state.pending)
          return;
        state.processScheduled = true;
        nextTick(function() {
          processQueue(state);
        });
      }
      function Deferred() {
        this.promise = new Promise();
        this.resolve = simpleBind(this, this.resolve);
        this.reject = simpleBind(this, this.reject);
        this.notify = simpleBind(this, this.notify);
      }
      Deferred.prototype = {
        resolve: function(val) {
          if (this.promise.$$state.status)
            return;
          if (val === this.promise) {
            this.$$reject($qMinErr('qcycle', "Expected promise to be resolved with value other than itself '{0}'", val));
          } else {
            this.$$resolve(val);
          }
        },
        $$resolve: function(val) {
          var then,
              fns;
          fns = callOnce(this, this.$$resolve, this.$$reject);
          try {
            if ((isObject(val) || isFunction(val)))
              then = val && val.then;
            if (isFunction(then)) {
              this.promise.$$state.status = -1;
              then.call(val, fns[0], fns[1], this.notify);
            } else {
              this.promise.$$state.value = val;
              this.promise.$$state.status = 1;
              scheduleProcessQueue(this.promise.$$state);
            }
          } catch (e) {
            fns[1](e);
            exceptionHandler(e);
          }
        },
        reject: function(reason) {
          if (this.promise.$$state.status)
            return;
          this.$$reject(reason);
        },
        $$reject: function(reason) {
          this.promise.$$state.value = reason;
          this.promise.$$state.status = 2;
          scheduleProcessQueue(this.promise.$$state);
        },
        notify: function(progress) {
          var callbacks = this.promise.$$state.pending;
          if ((this.promise.$$state.status <= 0) && callbacks && callbacks.length) {
            nextTick(function() {
              var callback,
                  result;
              for (var i = 0,
                  ii = callbacks.length; i < ii; i++) {
                result = callbacks[i][0];
                callback = callbacks[i][3];
                try {
                  result.notify(isFunction(callback) ? callback(progress) : progress);
                } catch (e) {
                  exceptionHandler(e);
                }
              }
            });
          }
        }
      };
      var reject = function(reason) {
        var result = new Deferred();
        result.reject(reason);
        return result.promise;
      };
      var makePromise = function makePromise(value, resolved) {
        var result = new Deferred();
        if (resolved) {
          result.resolve(value);
        } else {
          result.reject(value);
        }
        return result.promise;
      };
      var handleCallback = function handleCallback(value, isResolved, callback) {
        var callbackOutput = null;
        try {
          if (isFunction(callback))
            callbackOutput = callback();
        } catch (e) {
          return makePromise(e, false);
        }
        if (isPromiseLike(callbackOutput)) {
          return callbackOutput.then(function() {
            return makePromise(value, isResolved);
          }, function(error) {
            return makePromise(error, false);
          });
        } else {
          return makePromise(value, isResolved);
        }
      };
      var when = function(value, callback, errback, progressBack) {
        var result = new Deferred();
        result.resolve(value);
        return result.promise.then(callback, errback, progressBack);
      };
      var resolve = when;
      function all(promises) {
        var deferred = new Deferred(),
            counter = 0,
            results = isArray(promises) ? [] : {};
        forEach(promises, function(promise, key) {
          counter++;
          when(promise).then(function(value) {
            if (results.hasOwnProperty(key))
              return;
            results[key] = value;
            if (!(--counter))
              deferred.resolve(results);
          }, function(reason) {
            if (results.hasOwnProperty(key))
              return;
            deferred.reject(reason);
          });
        });
        if (counter === 0) {
          deferred.resolve(results);
        }
        return deferred.promise;
      }
      var $Q = function Q(resolver) {
        if (!isFunction(resolver)) {
          throw $qMinErr('norslvr', "Expected resolverFn, got '{0}'", resolver);
        }
        if (!(this instanceof Q)) {
          return new Q(resolver);
        }
        var deferred = new Deferred();
        function resolveFn(value) {
          deferred.resolve(value);
        }
        function rejectFn(reason) {
          deferred.reject(reason);
        }
        resolver(resolveFn, rejectFn);
        return deferred.promise;
      };
      $Q.defer = defer;
      $Q.reject = reject;
      $Q.when = when;
      $Q.resolve = resolve;
      $Q.all = all;
      return $Q;
    }
    function $$RAFProvider() {
      this.$get = ['$window', '$timeout', function($window, $timeout) {
        var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
        var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
        var rafSupported = !!requestAnimationFrame;
        var rafFn = rafSupported ? function(fn) {
          var id = requestAnimationFrame(fn);
          return function() {
            cancelAnimationFrame(id);
          };
        } : function(fn) {
          var timer = $timeout(fn, 16.66, false);
          return function() {
            $timeout.cancel(timer);
          };
        };
        queueFn.supported = rafSupported;
        var cancelLastRAF;
        var taskCount = 0;
        var taskQueue = [];
        return queueFn;
        function flush() {
          for (var i = 0; i < taskQueue.length; i++) {
            var task = taskQueue[i];
            if (task) {
              taskQueue[i] = null;
              task();
            }
          }
          taskCount = taskQueue.length = 0;
        }
        function queueFn(asyncFn) {
          var index = taskQueue.length;
          taskCount++;
          taskQueue.push(asyncFn);
          if (index === 0) {
            cancelLastRAF = rafFn(flush);
          }
          return function cancelQueueFn() {
            if (index >= 0) {
              taskQueue[index] = null;
              index = null;
              if (--taskCount === 0 && cancelLastRAF) {
                cancelLastRAF();
                cancelLastRAF = null;
                taskQueue.length = 0;
              }
            }
          };
        }
      }];
    }
    function $RootScopeProvider() {
      var TTL = 10;
      var $rootScopeMinErr = minErr('$rootScope');
      var lastDirtyWatch = null;
      var applyAsyncId = null;
      this.digestTtl = function(value) {
        if (arguments.length) {
          TTL = value;
        }
        return TTL;
      };
      function createChildScopeClass(parent) {
        function ChildScope() {
          this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
          this.$$listeners = {};
          this.$$listenerCount = {};
          this.$$watchersCount = 0;
          this.$id = nextUid();
          this.$$ChildScope = null;
        }
        ChildScope.prototype = parent;
        return ChildScope;
      }
      this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser', function($injector, $exceptionHandler, $parse, $browser) {
        function destroyChildScope($event) {
          $event.currentScope.$$destroyed = true;
        }
        function Scope() {
          this.$id = nextUid();
          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
          this.$root = this;
          this.$$destroyed = false;
          this.$$listeners = {};
          this.$$listenerCount = {};
          this.$$watchersCount = 0;
          this.$$isolateBindings = null;
        }
        Scope.prototype = {
          constructor: Scope,
          $new: function(isolate, parent) {
            var child;
            parent = parent || this;
            if (isolate) {
              child = new Scope();
              child.$root = this.$root;
            } else {
              if (!this.$$ChildScope) {
                this.$$ChildScope = createChildScopeClass(this);
              }
              child = new this.$$ChildScope();
            }
            child.$parent = parent;
            child.$$prevSibling = parent.$$childTail;
            if (parent.$$childHead) {
              parent.$$childTail.$$nextSibling = child;
              parent.$$childTail = child;
            } else {
              parent.$$childHead = parent.$$childTail = child;
            }
            if (isolate || parent != this)
              child.$on('$destroy', destroyChildScope);
            return child;
          },
          $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
            var get = $parse(watchExp);
            if (get.$$watchDelegate) {
              return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
            }
            var scope = this,
                array = scope.$$watchers,
                watcher = {
                  fn: listener,
                  last: initWatchVal,
                  get: get,
                  exp: prettyPrintExpression || watchExp,
                  eq: !!objectEquality
                };
            lastDirtyWatch = null;
            if (!isFunction(listener)) {
              watcher.fn = noop;
            }
            if (!array) {
              array = scope.$$watchers = [];
            }
            array.unshift(watcher);
            incrementWatchersCount(this, 1);
            return function deregisterWatch() {
              if (arrayRemove(array, watcher) >= 0) {
                incrementWatchersCount(scope, -1);
              }
              lastDirtyWatch = null;
            };
          },
          $watchGroup: function(watchExpressions, listener) {
            var oldValues = new Array(watchExpressions.length);
            var newValues = new Array(watchExpressions.length);
            var deregisterFns = [];
            var self = this;
            var changeReactionScheduled = false;
            var firstRun = true;
            if (!watchExpressions.length) {
              var shouldCall = true;
              self.$evalAsync(function() {
                if (shouldCall)
                  listener(newValues, newValues, self);
              });
              return function deregisterWatchGroup() {
                shouldCall = false;
              };
            }
            if (watchExpressions.length === 1) {
              return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                newValues[0] = value;
                oldValues[0] = oldValue;
                listener(newValues, (value === oldValue) ? newValues : oldValues, scope);
              });
            }
            forEach(watchExpressions, function(expr, i) {
              var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                newValues[i] = value;
                oldValues[i] = oldValue;
                if (!changeReactionScheduled) {
                  changeReactionScheduled = true;
                  self.$evalAsync(watchGroupAction);
                }
              });
              deregisterFns.push(unwatchFn);
            });
            function watchGroupAction() {
              changeReactionScheduled = false;
              if (firstRun) {
                firstRun = false;
                listener(newValues, newValues, self);
              } else {
                listener(newValues, oldValues, self);
              }
            }
            return function deregisterWatchGroup() {
              while (deregisterFns.length) {
                deregisterFns.shift()();
              }
            };
          },
          $watchCollection: function(obj, listener) {
            $watchCollectionInterceptor.$stateful = true;
            var self = this;
            var newValue;
            var oldValue;
            var veryOldValue;
            var trackVeryOldValue = (listener.length > 1);
            var changeDetected = 0;
            var changeDetector = $parse(obj, $watchCollectionInterceptor);
            var internalArray = [];
            var internalObject = {};
            var initRun = true;
            var oldLength = 0;
            function $watchCollectionInterceptor(_value) {
              newValue = _value;
              var newLength,
                  key,
                  bothNaN,
                  newItem,
                  oldItem;
              if (isUndefined(newValue))
                return;
              if (!isObject(newValue)) {
                if (oldValue !== newValue) {
                  oldValue = newValue;
                  changeDetected++;
                }
              } else if (isArrayLike(newValue)) {
                if (oldValue !== internalArray) {
                  oldValue = internalArray;
                  oldLength = oldValue.length = 0;
                  changeDetected++;
                }
                newLength = newValue.length;
                if (oldLength !== newLength) {
                  changeDetected++;
                  oldValue.length = oldLength = newLength;
                }
                for (var i = 0; i < newLength; i++) {
                  oldItem = oldValue[i];
                  newItem = newValue[i];
                  bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                  if (!bothNaN && (oldItem !== newItem)) {
                    changeDetected++;
                    oldValue[i] = newItem;
                  }
                }
              } else {
                if (oldValue !== internalObject) {
                  oldValue = internalObject = {};
                  oldLength = 0;
                  changeDetected++;
                }
                newLength = 0;
                for (key in newValue) {
                  if (newValue.hasOwnProperty(key)) {
                    newLength++;
                    newItem = newValue[key];
                    oldItem = oldValue[key];
                    if (key in oldValue) {
                      bothNaN = (oldItem !== oldItem) && (newItem !== newItem);
                      if (!bothNaN && (oldItem !== newItem)) {
                        changeDetected++;
                        oldValue[key] = newItem;
                      }
                    } else {
                      oldLength++;
                      oldValue[key] = newItem;
                      changeDetected++;
                    }
                  }
                }
                if (oldLength > newLength) {
                  changeDetected++;
                  for (key in oldValue) {
                    if (!newValue.hasOwnProperty(key)) {
                      oldLength--;
                      delete oldValue[key];
                    }
                  }
                }
              }
              return changeDetected;
            }
            function $watchCollectionAction() {
              if (initRun) {
                initRun = false;
                listener(newValue, newValue, self);
              } else {
                listener(newValue, veryOldValue, self);
              }
              if (trackVeryOldValue) {
                if (!isObject(newValue)) {
                  veryOldValue = newValue;
                } else if (isArrayLike(newValue)) {
                  veryOldValue = new Array(newValue.length);
                  for (var i = 0; i < newValue.length; i++) {
                    veryOldValue[i] = newValue[i];
                  }
                } else {
                  veryOldValue = {};
                  for (var key in newValue) {
                    if (hasOwnProperty.call(newValue, key)) {
                      veryOldValue[key] = newValue[key];
                    }
                  }
                }
              }
            }
            return this.$watch(changeDetector, $watchCollectionAction);
          },
          $digest: function() {
            var watch,
                value,
                last,
                watchers,
                length,
                dirty,
                ttl = TTL,
                next,
                current,
                target = this,
                watchLog = [],
                logIdx,
                logMsg,
                asyncTask;
            beginPhase('$digest');
            $browser.$$checkUrlChange();
            if (this === $rootScope && applyAsyncId !== null) {
              $browser.defer.cancel(applyAsyncId);
              flushApplyAsync();
            }
            lastDirtyWatch = null;
            do {
              dirty = false;
              current = target;
              while (asyncQueue.length) {
                try {
                  asyncTask = asyncQueue.shift();
                  asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                } catch (e) {
                  $exceptionHandler(e);
                }
                lastDirtyWatch = null;
              }
              traverseScopesLoop: do {
                if ((watchers = current.$$watchers)) {
                  length = watchers.length;
                  while (length--) {
                    try {
                      watch = watchers[length];
                      if (watch) {
                        if ((value = watch.get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : (typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last)))) {
                          dirty = true;
                          lastDirtyWatch = watch;
                          watch.last = watch.eq ? copy(value, null) : value;
                          watch.fn(value, ((last === initWatchVal) ? value : last), current);
                          if (ttl < 5) {
                            logIdx = 4 - ttl;
                            if (!watchLog[logIdx])
                              watchLog[logIdx] = [];
                            watchLog[logIdx].push({
                              msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                              newVal: value,
                              oldVal: last
                            });
                          }
                        } else if (watch === lastDirtyWatch) {
                          dirty = false;
                          break traverseScopesLoop;
                        }
                      }
                    } catch (e) {
                      $exceptionHandler(e);
                    }
                  }
                }
                if (!(next = ((current.$$watchersCount && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                  while (current !== target && !(next = current.$$nextSibling)) {
                    current = current.$parent;
                  }
                }
              } while ((current = next));
              if ((dirty || asyncQueue.length) && !(ttl--)) {
                clearPhase();
                throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
              }
            } while (dirty || asyncQueue.length);
            clearPhase();
            while (postDigestQueue.length) {
              try {
                postDigestQueue.shift()();
              } catch (e) {
                $exceptionHandler(e);
              }
            }
          },
          $destroy: function() {
            if (this.$$destroyed)
              return;
            var parent = this.$parent;
            this.$broadcast('$destroy');
            this.$$destroyed = true;
            if (this === $rootScope) {
              $browser.$$applicationDestroyed();
            }
            incrementWatchersCount(this, -this.$$watchersCount);
            for (var eventName in this.$$listenerCount) {
              decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
            }
            if (parent && parent.$$childHead == this)
              parent.$$childHead = this.$$nextSibling;
            if (parent && parent.$$childTail == this)
              parent.$$childTail = this.$$prevSibling;
            if (this.$$prevSibling)
              this.$$prevSibling.$$nextSibling = this.$$nextSibling;
            if (this.$$nextSibling)
              this.$$nextSibling.$$prevSibling = this.$$prevSibling;
            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
            this.$on = this.$watch = this.$watchGroup = function() {
              return noop;
            };
            this.$$listeners = {};
            this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
          },
          $eval: function(expr, locals) {
            return $parse(expr)(this, locals);
          },
          $evalAsync: function(expr, locals) {
            if (!$rootScope.$$phase && !asyncQueue.length) {
              $browser.defer(function() {
                if (asyncQueue.length) {
                  $rootScope.$digest();
                }
              });
            }
            asyncQueue.push({
              scope: this,
              expression: expr,
              locals: locals
            });
          },
          $$postDigest: function(fn) {
            postDigestQueue.push(fn);
          },
          $apply: function(expr) {
            try {
              beginPhase('$apply');
              return this.$eval(expr);
            } catch (e) {
              $exceptionHandler(e);
            } finally {
              clearPhase();
              try {
                $rootScope.$digest();
              } catch (e) {
                $exceptionHandler(e);
                throw e;
              }
            }
          },
          $applyAsync: function(expr) {
            var scope = this;
            expr && applyAsyncQueue.push($applyAsyncExpression);
            scheduleApplyAsync();
            function $applyAsyncExpression() {
              scope.$eval(expr);
            }
          },
          $on: function(name, listener) {
            var namedListeners = this.$$listeners[name];
            if (!namedListeners) {
              this.$$listeners[name] = namedListeners = [];
            }
            namedListeners.push(listener);
            var current = this;
            do {
              if (!current.$$listenerCount[name]) {
                current.$$listenerCount[name] = 0;
              }
              current.$$listenerCount[name]++;
            } while ((current = current.$parent));
            var self = this;
            return function() {
              var indexOfListener = namedListeners.indexOf(listener);
              if (indexOfListener !== -1) {
                namedListeners[indexOfListener] = null;
                decrementListenerCount(self, 1, name);
              }
            };
          },
          $emit: function(name, args) {
            var empty = [],
                namedListeners,
                scope = this,
                stopPropagation = false,
                event = {
                  name: name,
                  targetScope: scope,
                  stopPropagation: function() {
                    stopPropagation = true;
                  },
                  preventDefault: function() {
                    event.defaultPrevented = true;
                  },
                  defaultPrevented: false
                },
                listenerArgs = concat([event], arguments, 1),
                i,
                length;
            do {
              namedListeners = scope.$$listeners[name] || empty;
              event.currentScope = scope;
              for (i = 0, length = namedListeners.length; i < length; i++) {
                if (!namedListeners[i]) {
                  namedListeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  namedListeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (stopPropagation) {
                event.currentScope = null;
                return event;
              }
              scope = scope.$parent;
            } while (scope);
            event.currentScope = null;
            return event;
          },
          $broadcast: function(name, args) {
            var target = this,
                current = target,
                next = target,
                event = {
                  name: name,
                  targetScope: target,
                  preventDefault: function() {
                    event.defaultPrevented = true;
                  },
                  defaultPrevented: false
                };
            if (!target.$$listenerCount[name])
              return event;
            var listenerArgs = concat([event], arguments, 1),
                listeners,
                i,
                length;
            while ((current = next)) {
              event.currentScope = current;
              listeners = current.$$listeners[name] || [];
              for (i = 0, length = listeners.length; i < length; i++) {
                if (!listeners[i]) {
                  listeners.splice(i, 1);
                  i--;
                  length--;
                  continue;
                }
                try {
                  listeners[i].apply(null, listenerArgs);
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
              if (!(next = ((current.$$listenerCount[name] && current.$$childHead) || (current !== target && current.$$nextSibling)))) {
                while (current !== target && !(next = current.$$nextSibling)) {
                  current = current.$parent;
                }
              }
            }
            event.currentScope = null;
            return event;
          }
        };
        var $rootScope = new Scope();
        var asyncQueue = $rootScope.$$asyncQueue = [];
        var postDigestQueue = $rootScope.$$postDigestQueue = [];
        var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
        return $rootScope;
        function beginPhase(phase) {
          if ($rootScope.$$phase) {
            throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
          }
          $rootScope.$$phase = phase;
        }
        function clearPhase() {
          $rootScope.$$phase = null;
        }
        function incrementWatchersCount(current, count) {
          do {
            current.$$watchersCount += count;
          } while ((current = current.$parent));
        }
        function decrementListenerCount(current, count, name) {
          do {
            current.$$listenerCount[name] -= count;
            if (current.$$listenerCount[name] === 0) {
              delete current.$$listenerCount[name];
            }
          } while ((current = current.$parent));
        }
        function initWatchVal() {}
        function flushApplyAsync() {
          while (applyAsyncQueue.length) {
            try {
              applyAsyncQueue.shift()();
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          applyAsyncId = null;
        }
        function scheduleApplyAsync() {
          if (applyAsyncId === null) {
            applyAsyncId = $browser.defer(function() {
              $rootScope.$apply(flushApplyAsync);
            });
          }
        }
      }];
    }
    function $$SanitizeUriProvider() {
      var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/,
          imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
      this.aHrefSanitizationWhitelist = function(regexp) {
        if (isDefined(regexp)) {
          aHrefSanitizationWhitelist = regexp;
          return this;
        }
        return aHrefSanitizationWhitelist;
      };
      this.imgSrcSanitizationWhitelist = function(regexp) {
        if (isDefined(regexp)) {
          imgSrcSanitizationWhitelist = regexp;
          return this;
        }
        return imgSrcSanitizationWhitelist;
      };
      this.$get = function() {
        return function sanitizeUri(uri, isImage) {
          var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
          var normalizedVal;
          normalizedVal = urlResolve(uri).href;
          if (normalizedVal !== '' && !normalizedVal.match(regex)) {
            return 'unsafe:' + normalizedVal;
          }
          return uri;
        };
      };
    }
    var $sceMinErr = minErr('$sce');
    var SCE_CONTEXTS = {
      HTML: 'html',
      CSS: 'css',
      URL: 'url',
      RESOURCE_URL: 'resourceUrl',
      JS: 'js'
    };
    function adjustMatcher(matcher) {
      if (matcher === 'self') {
        return matcher;
      } else if (isString(matcher)) {
        if (matcher.indexOf('***') > -1) {
          throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
        }
        matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
        return new RegExp('^' + matcher + '$');
      } else if (isRegExp(matcher)) {
        return new RegExp('^' + matcher.source + '$');
      } else {
        throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
      }
    }
    function adjustMatchers(matchers) {
      var adjustedMatchers = [];
      if (isDefined(matchers)) {
        forEach(matchers, function(matcher) {
          adjustedMatchers.push(adjustMatcher(matcher));
        });
      }
      return adjustedMatchers;
    }
    function $SceDelegateProvider() {
      this.SCE_CONTEXTS = SCE_CONTEXTS;
      var resourceUrlWhitelist = ['self'],
          resourceUrlBlacklist = [];
      this.resourceUrlWhitelist = function(value) {
        if (arguments.length) {
          resourceUrlWhitelist = adjustMatchers(value);
        }
        return resourceUrlWhitelist;
      };
      this.resourceUrlBlacklist = function(value) {
        if (arguments.length) {
          resourceUrlBlacklist = adjustMatchers(value);
        }
        return resourceUrlBlacklist;
      };
      this.$get = ['$injector', function($injector) {
        var htmlSanitizer = function htmlSanitizer(html) {
          throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
        };
        if ($injector.has('$sanitize')) {
          htmlSanitizer = $injector.get('$sanitize');
        }
        function matchUrl(matcher, parsedUrl) {
          if (matcher === 'self') {
            return urlIsSameOrigin(parsedUrl);
          } else {
            return !!matcher.exec(parsedUrl.href);
          }
        }
        function isResourceUrlAllowedByPolicy(url) {
          var parsedUrl = urlResolve(url.toString());
          var i,
              n,
              allowed = false;
          for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
              allowed = true;
              break;
            }
          }
          if (allowed) {
            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
              if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                allowed = false;
                break;
              }
            }
          }
          return allowed;
        }
        function generateHolderType(Base) {
          var holderType = function TrustedValueHolderType(trustedValue) {
            this.$$unwrapTrustedValue = function() {
              return trustedValue;
            };
          };
          if (Base) {
            holderType.prototype = new Base();
          }
          holderType.prototype.valueOf = function sceValueOf() {
            return this.$$unwrapTrustedValue();
          };
          holderType.prototype.toString = function sceToString() {
            return this.$$unwrapTrustedValue().toString();
          };
          return holderType;
        }
        var trustedValueHolderBase = generateHolderType(),
            byType = {};
        byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
        byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
        function trustAs(type, trustedValue) {
          var Constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
          if (!Constructor) {
            throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
          }
          if (trustedValue === null || trustedValue === undefined || trustedValue === '') {
            return trustedValue;
          }
          if (typeof trustedValue !== 'string') {
            throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
          }
          return new Constructor(trustedValue);
        }
        function valueOf(maybeTrusted) {
          if (maybeTrusted instanceof trustedValueHolderBase) {
            return maybeTrusted.$$unwrapTrustedValue();
          } else {
            return maybeTrusted;
          }
        }
        function getTrusted(type, maybeTrusted) {
          if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {
            return maybeTrusted;
          }
          var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);
          if (constructor && maybeTrusted instanceof constructor) {
            return maybeTrusted.$$unwrapTrustedValue();
          }
          if (type === SCE_CONTEXTS.RESOURCE_URL) {
            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
              return maybeTrusted;
            } else {
              throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
            }
          } else if (type === SCE_CONTEXTS.HTML) {
            return htmlSanitizer(maybeTrusted);
          }
          throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
        }
        return {
          trustAs: trustAs,
          getTrusted: getTrusted,
          valueOf: valueOf
        };
      }];
    }
    function $SceProvider() {
      var enabled = true;
      this.enabled = function(value) {
        if (arguments.length) {
          enabled = !!value;
        }
        return enabled;
      };
      this.$get = ['$parse', '$sceDelegate', function($parse, $sceDelegate) {
        if (enabled && msie < 8) {
          throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
        }
        var sce = shallowCopy(SCE_CONTEXTS);
        sce.isEnabled = function() {
          return enabled;
        };
        sce.trustAs = $sceDelegate.trustAs;
        sce.getTrusted = $sceDelegate.getTrusted;
        sce.valueOf = $sceDelegate.valueOf;
        if (!enabled) {
          sce.trustAs = sce.getTrusted = function(type, value) {
            return value;
          };
          sce.valueOf = identity;
        }
        sce.parseAs = function sceParseAs(type, expr) {
          var parsed = $parse(expr);
          if (parsed.literal && parsed.constant) {
            return parsed;
          } else {
            return $parse(expr, function(value) {
              return sce.getTrusted(type, value);
            });
          }
        };
        var parse = sce.parseAs,
            getTrusted = sce.getTrusted,
            trustAs = sce.trustAs;
        forEach(SCE_CONTEXTS, function(enumValue, name) {
          var lName = lowercase(name);
          sce[camelCase("parse_as_" + lName)] = function(expr) {
            return parse(enumValue, expr);
          };
          sce[camelCase("get_trusted_" + lName)] = function(value) {
            return getTrusted(enumValue, value);
          };
          sce[camelCase("trust_as_" + lName)] = function(value) {
            return trustAs(enumValue, value);
          };
        });
        return sce;
      }];
    }
    function $SnifferProvider() {
      this.$get = ['$window', '$document', function($window, $document) {
        var eventSupport = {},
            android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
            boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
            document = $document[0] || {},
            vendorPrefix,
            vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/,
            bodyStyle = document.body && document.body.style,
            transitions = false,
            animations = false,
            match;
        if (bodyStyle) {
          for (var prop in bodyStyle) {
            if (match = vendorRegex.exec(prop)) {
              vendorPrefix = match[0];
              vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
              break;
            }
          }
          if (!vendorPrefix) {
            vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';
          }
          transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));
          animations = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));
          if (android && (!transitions || !animations)) {
            transitions = isString(bodyStyle.webkitTransition);
            animations = isString(bodyStyle.webkitAnimation);
          }
        }
        return {
          history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),
          hasEvent: function(event) {
            if (event === 'input' && msie <= 11)
              return false;
            if (isUndefined(eventSupport[event])) {
              var divElm = document.createElement('div');
              eventSupport[event] = 'on' + event in divElm;
            }
            return eventSupport[event];
          },
          csp: csp(),
          vendorPrefix: vendorPrefix,
          transitions: transitions,
          animations: animations,
          android: android
        };
      }];
    }
    var $compileMinErr = minErr('$compile');
    function $TemplateRequestProvider() {
      this.$get = ['$templateCache', '$http', '$q', '$sce', function($templateCache, $http, $q, $sce) {
        function handleRequestFn(tpl, ignoreRequestError) {
          handleRequestFn.totalPendingRequests++;
          if (!isString(tpl) || !$templateCache.get(tpl)) {
            tpl = $sce.getTrustedResourceUrl(tpl);
          }
          var transformResponse = $http.defaults && $http.defaults.transformResponse;
          if (isArray(transformResponse)) {
            transformResponse = transformResponse.filter(function(transformer) {
              return transformer !== defaultHttpResponseTransform;
            });
          } else if (transformResponse === defaultHttpResponseTransform) {
            transformResponse = null;
          }
          var httpOptions = {
            cache: $templateCache,
            transformResponse: transformResponse
          };
          return $http.get(tpl, httpOptions)['finally'](function() {
            handleRequestFn.totalPendingRequests--;
          }).then(function(response) {
            $templateCache.put(tpl, response.data);
            return response.data;
          }, handleError);
          function handleError(resp) {
            if (!ignoreRequestError) {
              throw $compileMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
            }
            return $q.reject(resp);
          }
        }
        handleRequestFn.totalPendingRequests = 0;
        return handleRequestFn;
      }];
    }
    function $$TestabilityProvider() {
      this.$get = ['$rootScope', '$browser', '$location', function($rootScope, $browser, $location) {
        var testability = {};
        testability.findBindings = function(element, expression, opt_exactMatch) {
          var bindings = element.getElementsByClassName('ng-binding');
          var matches = [];
          forEach(bindings, function(binding) {
            var dataBinding = angular.element(binding).data('$binding');
            if (dataBinding) {
              forEach(dataBinding, function(bindingName) {
                if (opt_exactMatch) {
                  var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                  if (matcher.test(bindingName)) {
                    matches.push(binding);
                  }
                } else {
                  if (bindingName.indexOf(expression) != -1) {
                    matches.push(binding);
                  }
                }
              });
            }
          });
          return matches;
        };
        testability.findModels = function(element, expression, opt_exactMatch) {
          var prefixes = ['ng-', 'data-ng-', 'ng\\:'];
          for (var p = 0; p < prefixes.length; ++p) {
            var attributeEquals = opt_exactMatch ? '=' : '*=';
            var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
            var elements = element.querySelectorAll(selector);
            if (elements.length) {
              return elements;
            }
          }
        };
        testability.getLocation = function() {
          return $location.url();
        };
        testability.setLocation = function(url) {
          if (url !== $location.url()) {
            $location.url(url);
            $rootScope.$digest();
          }
        };
        testability.whenStable = function(callback) {
          $browser.notifyWhenNoOutstandingRequests(callback);
        };
        return testability;
      }];
    }
    function $TimeoutProvider() {
      this.$get = ['$rootScope', '$browser', '$q', '$$q', '$exceptionHandler', function($rootScope, $browser, $q, $$q, $exceptionHandler) {
        var deferreds = {};
        function timeout(fn, delay, invokeApply) {
          if (!isFunction(fn)) {
            invokeApply = delay;
            delay = fn;
            fn = noop;
          }
          var args = sliceArgs(arguments, 3),
              skipApply = (isDefined(invokeApply) && !invokeApply),
              deferred = (skipApply ? $$q : $q).defer(),
              promise = deferred.promise,
              timeoutId;
          timeoutId = $browser.defer(function() {
            try {
              deferred.resolve(fn.apply(null, args));
            } catch (e) {
              deferred.reject(e);
              $exceptionHandler(e);
            } finally {
              delete deferreds[promise.$$timeoutId];
            }
            if (!skipApply)
              $rootScope.$apply();
          }, delay);
          promise.$$timeoutId = timeoutId;
          deferreds[timeoutId] = deferred;
          return promise;
        }
        timeout.cancel = function(promise) {
          if (promise && promise.$$timeoutId in deferreds) {
            deferreds[promise.$$timeoutId].reject('canceled');
            delete deferreds[promise.$$timeoutId];
            return $browser.defer.cancel(promise.$$timeoutId);
          }
          return false;
        };
        return timeout;
      }];
    }
    var urlParsingNode = document.createElement("a");
    var originUrl = urlResolve(window.location.href);
    function urlResolve(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute('href', href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }
    function urlIsSameOrigin(requestUrl) {
      var parsed = (isString(requestUrl)) ? urlResolve(requestUrl) : requestUrl;
      return (parsed.protocol === originUrl.protocol && parsed.host === originUrl.host);
    }
    function $WindowProvider() {
      this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
      var rawDocument = $document[0] || {};
      var lastCookies = {};
      var lastCookieString = '';
      function safeDecodeURIComponent(str) {
        try {
          return decodeURIComponent(str);
        } catch (e) {
          return str;
        }
      }
      return function() {
        var cookieArray,
            cookie,
            i,
            index,
            name;
        var currentCookieString = rawDocument.cookie || '';
        if (currentCookieString !== lastCookieString) {
          lastCookieString = currentCookieString;
          cookieArray = lastCookieString.split('; ');
          lastCookies = {};
          for (i = 0; i < cookieArray.length; i++) {
            cookie = cookieArray[i];
            index = cookie.indexOf('=');
            if (index > 0) {
              name = safeDecodeURIComponent(cookie.substring(0, index));
              if (lastCookies[name] === undefined) {
                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
              }
            }
          }
        }
        return lastCookies;
      };
    }
    $$CookieReader.$inject = ['$document'];
    function $$CookieReaderProvider() {
      this.$get = $$CookieReader;
    }
    $FilterProvider.$inject = ['$provide'];
    function $FilterProvider($provide) {
      var suffix = 'Filter';
      function register(name, factory) {
        if (isObject(name)) {
          var filters = {};
          forEach(name, function(filter, key) {
            filters[key] = register(key, filter);
          });
          return filters;
        } else {
          return $provide.factory(name + suffix, factory);
        }
      }
      this.register = register;
      this.$get = ['$injector', function($injector) {
        return function(name) {
          return $injector.get(name + suffix);
        };
      }];
      register('currency', currencyFilter);
      register('date', dateFilter);
      register('filter', filterFilter);
      register('json', jsonFilter);
      register('limitTo', limitToFilter);
      register('lowercase', lowercaseFilter);
      register('number', numberFilter);
      register('orderBy', orderByFilter);
      register('uppercase', uppercaseFilter);
    }
    function filterFilter() {
      return function(array, expression, comparator) {
        if (!isArrayLike(array)) {
          if (array == null) {
            return array;
          } else {
            throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
          }
        }
        var expressionType = getTypeForFilter(expression);
        var predicateFn;
        var matchAgainstAnyProp;
        switch (expressionType) {
          case 'function':
            predicateFn = expression;
            break;
          case 'boolean':
          case 'null':
          case 'number':
          case 'string':
            matchAgainstAnyProp = true;
          case 'object':
            predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
            break;
          default:
            return array;
        }
        return Array.prototype.filter.call(array, predicateFn);
      };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
      var shouldMatchPrimitives = isObject(expression) && ('$' in expression);
      var predicateFn;
      if (comparator === true) {
        comparator = equals;
      } else if (!isFunction(comparator)) {
        comparator = function(actual, expected) {
          if (isUndefined(actual)) {
            return false;
          }
          if ((actual === null) || (expected === null)) {
            return actual === expected;
          }
          if (isObject(expected) || (isObject(actual) && !hasCustomToString(actual))) {
            return false;
          }
          actual = lowercase('' + actual);
          expected = lowercase('' + expected);
          return actual.indexOf(expected) !== -1;
        };
      }
      predicateFn = function(item) {
        if (shouldMatchPrimitives && !isObject(item)) {
          return deepCompare(item, expression.$, comparator, false);
        }
        return deepCompare(item, expression, comparator, matchAgainstAnyProp);
      };
      return predicateFn;
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
      var actualType = getTypeForFilter(actual);
      var expectedType = getTypeForFilter(expected);
      if ((expectedType === 'string') && (expected.charAt(0) === '!')) {
        return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
      } else if (isArray(actual)) {
        return actual.some(function(item) {
          return deepCompare(item, expected, comparator, matchAgainstAnyProp);
        });
      }
      switch (actualType) {
        case 'object':
          var key;
          if (matchAgainstAnyProp) {
            for (key in actual) {
              if ((key.charAt(0) !== '$') && deepCompare(actual[key], expected, comparator, true)) {
                return true;
              }
            }
            return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
          } else if (expectedType === 'object') {
            for (key in expected) {
              var expectedVal = expected[key];
              if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                continue;
              }
              var matchAnyProperty = key === '$';
              var actualVal = matchAnyProperty ? actual : actual[key];
              if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                return false;
              }
            }
            return true;
          } else {
            return comparator(actual, expected);
          }
          break;
        case 'function':
          return false;
        default:
          return comparator(actual, expected);
      }
    }
    function getTypeForFilter(val) {
      return (val === null) ? 'null' : typeof val;
    }
    currencyFilter.$inject = ['$locale'];
    function currencyFilter($locale) {
      var formats = $locale.NUMBER_FORMATS;
      return function(amount, currencySymbol, fractionSize) {
        if (isUndefined(currencySymbol)) {
          currencySymbol = formats.CURRENCY_SYM;
        }
        if (isUndefined(fractionSize)) {
          fractionSize = formats.PATTERNS[1].maxFrac;
        }
        return (amount == null) ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
      };
    }
    numberFilter.$inject = ['$locale'];
    function numberFilter($locale) {
      var formats = $locale.NUMBER_FORMATS;
      return function(number, fractionSize) {
        return (number == null) ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
      };
    }
    var DECIMAL_SEP = '.';
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
      if (isObject(number))
        return '';
      var isNegative = number < 0;
      number = Math.abs(number);
      var isInfinity = number === Infinity;
      if (!isInfinity && !isFinite(number))
        return '';
      var numStr = number + '',
          formatedText = '',
          hasExponent = false,
          parts = [];
      if (isInfinity)
        formatedText = '\u221e';
      if (!isInfinity && numStr.indexOf('e') !== -1) {
        var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
        if (match && match[2] == '-' && match[3] > fractionSize + 1) {
          number = 0;
        } else {
          formatedText = numStr;
          hasExponent = true;
        }
      }
      if (!isInfinity && !hasExponent) {
        var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;
        if (isUndefined(fractionSize)) {
          fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
        }
        number = +(Math.round(+(number.toString() + 'e' + fractionSize)).toString() + 'e' + -fractionSize);
        var fraction = ('' + number).split(DECIMAL_SEP);
        var whole = fraction[0];
        fraction = fraction[1] || '';
        var i,
            pos = 0,
            lgroup = pattern.lgSize,
            group = pattern.gSize;
        if (whole.length >= (lgroup + group)) {
          pos = whole.length - lgroup;
          for (i = 0; i < pos; i++) {
            if ((pos - i) % group === 0 && i !== 0) {
              formatedText += groupSep;
            }
            formatedText += whole.charAt(i);
          }
        }
        for (i = pos; i < whole.length; i++) {
          if ((whole.length - i) % lgroup === 0 && i !== 0) {
            formatedText += groupSep;
          }
          formatedText += whole.charAt(i);
        }
        while (fraction.length < fractionSize) {
          fraction += '0';
        }
        if (fractionSize && fractionSize !== "0")
          formatedText += decimalSep + fraction.substr(0, fractionSize);
      } else {
        if (fractionSize > 0 && number < 1) {
          formatedText = number.toFixed(fractionSize);
          number = parseFloat(formatedText);
        }
      }
      if (number === 0) {
        isNegative = false;
      }
      parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf);
      return parts.join('');
    }
    function padNumber(num, digits, trim) {
      var neg = '';
      if (num < 0) {
        neg = '-';
        num = -num;
      }
      num = '' + num;
      while (num.length < digits)
        num = '0' + num;
      if (trim) {
        num = num.substr(num.length - digits);
      }
      return neg + num;
    }
    function dateGetter(name, size, offset, trim) {
      offset = offset || 0;
      return function(date) {
        var value = date['get' + name]();
        if (offset > 0 || value > -offset) {
          value += offset;
        }
        if (value === 0 && offset == -12)
          value = 12;
        return padNumber(value, size, trim);
      };
    }
    function dateStrGetter(name, shortForm) {
      return function(date, formats) {
        var value = date['get' + name]();
        var get = uppercase(shortForm ? ('SHORT' + name) : name);
        return formats[get][value];
      };
    }
    function timeZoneGetter(date, formats, offset) {
      var zone = -1 * offset;
      var paddedZone = (zone >= 0) ? "+" : "";
      paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
      return paddedZone;
    }
    function getFirstThursdayOfYear(year) {
      var dayOfWeekOnFirst = (new Date(year, 0, 1)).getDay();
      return new Date(year, 0, ((dayOfWeekOnFirst <= 4) ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
      return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
      return function(date) {
        var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
            thisThurs = getThursdayThisWeek(date);
        var diff = +thisThurs - +firstThurs,
            result = 1 + Math.round(diff / 6.048e8);
        return padNumber(result, size);
      };
    }
    function ampmGetter(date, formats) {
      return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
      return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
      return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    var DATE_FORMATS = {
      yyyy: dateGetter('FullYear', 4),
      yy: dateGetter('FullYear', 2, 0, true),
      y: dateGetter('FullYear', 1),
      MMMM: dateStrGetter('Month'),
      MMM: dateStrGetter('Month', true),
      MM: dateGetter('Month', 2, 1),
      M: dateGetter('Month', 1, 1),
      dd: dateGetter('Date', 2),
      d: dateGetter('Date', 1),
      HH: dateGetter('Hours', 2),
      H: dateGetter('Hours', 1),
      hh: dateGetter('Hours', 2, -12),
      h: dateGetter('Hours', 1, -12),
      mm: dateGetter('Minutes', 2),
      m: dateGetter('Minutes', 1),
      ss: dateGetter('Seconds', 2),
      s: dateGetter('Seconds', 1),
      sss: dateGetter('Milliseconds', 3),
      EEEE: dateStrGetter('Day'),
      EEE: dateStrGetter('Day', true),
      a: ampmGetter,
      Z: timeZoneGetter,
      ww: weekGetter(2),
      w: weekGetter(1),
      G: eraGetter,
      GG: eraGetter,
      GGG: eraGetter,
      GGGG: longEraGetter
    };
    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,
        NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = ['$locale'];
    function dateFilter($locale) {
      var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
      function jsonStringToDate(string) {
        var match;
        if (match = string.match(R_ISO8601_STR)) {
          var date = new Date(0),
              tzHour = 0,
              tzMin = 0,
              dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
              timeSetter = match[8] ? date.setUTCHours : date.setHours;
          if (match[9]) {
            tzHour = toInt(match[9] + match[10]);
            tzMin = toInt(match[9] + match[11]);
          }
          dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
          var h = toInt(match[4] || 0) - tzHour;
          var m = toInt(match[5] || 0) - tzMin;
          var s = toInt(match[6] || 0);
          var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
          timeSetter.call(date, h, m, s, ms);
          return date;
        }
        return string;
      }
      return function(date, format, timezone) {
        var text = '',
            parts = [],
            fn,
            match;
        format = format || 'mediumDate';
        format = $locale.DATETIME_FORMATS[format] || format;
        if (isString(date)) {
          date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
        }
        if (isNumber(date)) {
          date = new Date(date);
        }
        if (!isDate(date) || !isFinite(date.getTime())) {
          return date;
        }
        while (format) {
          match = DATE_FORMATS_SPLIT.exec(format);
          if (match) {
            parts = concat(parts, match, 1);
            format = parts.pop();
          } else {
            parts.push(format);
            format = null;
          }
        }
        var dateTimezoneOffset = date.getTimezoneOffset();
        if (timezone) {
          dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
          date = convertTimezoneToLocal(date, timezone, true);
        }
        forEach(parts, function(value) {
          fn = DATE_FORMATS[value];
          text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
        });
        return text;
      };
    }
    function jsonFilter() {
      return function(object, spacing) {
        if (isUndefined(spacing)) {
          spacing = 2;
        }
        return toJson(object, spacing);
      };
    }
    var lowercaseFilter = valueFn(lowercase);
    var uppercaseFilter = valueFn(uppercase);
    function limitToFilter() {
      return function(input, limit, begin) {
        if (Math.abs(Number(limit)) === Infinity) {
          limit = Number(limit);
        } else {
          limit = toInt(limit);
        }
        if (isNaN(limit))
          return input;
        if (isNumber(input))
          input = input.toString();
        if (!isArray(input) && !isString(input))
          return input;
        begin = (!begin || isNaN(begin)) ? 0 : toInt(begin);
        begin = (begin < 0 && begin >= -input.length) ? input.length + begin : begin;
        if (limit >= 0) {
          return input.slice(begin, begin + limit);
        } else {
          if (begin === 0) {
            return input.slice(limit, input.length);
          } else {
            return input.slice(Math.max(0, begin + limit), begin);
          }
        }
      };
    }
    orderByFilter.$inject = ['$parse'];
    function orderByFilter($parse) {
      return function(array, sortPredicate, reverseOrder) {
        if (!(isArrayLike(array)))
          return array;
        if (!isArray(sortPredicate)) {
          sortPredicate = [sortPredicate];
        }
        if (sortPredicate.length === 0) {
          sortPredicate = ['+'];
        }
        var predicates = processPredicates(sortPredicate, reverseOrder);
        var compareValues = Array.prototype.map.call(array, getComparisonObject);
        compareValues.sort(doComparison);
        array = compareValues.map(function(item) {
          return item.value;
        });
        return array;
        function getComparisonObject(value, index) {
          return {
            value: value,
            predicateValues: predicates.map(function(predicate) {
              return getPredicateValue(predicate.get(value), index);
            })
          };
        }
        function doComparison(v1, v2) {
          var result = 0;
          for (var index = 0,
              length = predicates.length; index < length; ++index) {
            result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
            if (result)
              break;
          }
          return result;
        }
      };
      function processPredicates(sortPredicate, reverseOrder) {
        reverseOrder = reverseOrder ? -1 : 1;
        return sortPredicate.map(function(predicate) {
          var descending = 1,
              get = identity;
          if (isFunction(predicate)) {
            get = predicate;
          } else if (isString(predicate)) {
            if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
              descending = predicate.charAt(0) == '-' ? -1 : 1;
              predicate = predicate.substring(1);
            }
            if (predicate !== '') {
              get = $parse(predicate);
              if (get.constant) {
                var key = get();
                get = function(value) {
                  return value[key];
                };
              }
            }
          }
          return {
            get: get,
            descending: descending * reverseOrder
          };
        });
      }
      function isPrimitive(value) {
        switch (typeof value) {
          case 'number':
          case 'boolean':
          case 'string':
            return true;
          default:
            return false;
        }
      }
      function objectValue(value, index) {
        if (typeof value.valueOf === 'function') {
          value = value.valueOf();
          if (isPrimitive(value))
            return value;
        }
        if (hasCustomToString(value)) {
          value = value.toString();
          if (isPrimitive(value))
            return value;
        }
        return index;
      }
      function getPredicateValue(value, index) {
        var type = typeof value;
        if (value === null) {
          type = 'string';
          value = 'null';
        } else if (type === 'string') {
          value = value.toLowerCase();
        } else if (type === 'object') {
          value = objectValue(value, index);
        }
        return {
          value: value,
          type: type
        };
      }
      function compare(v1, v2) {
        var result = 0;
        if (v1.type === v2.type) {
          if (v1.value !== v2.value) {
            result = v1.value < v2.value ? -1 : 1;
          }
        } else {
          result = v1.type < v2.type ? -1 : 1;
        }
        return result;
      }
    }
    function ngDirective(directive) {
      if (isFunction(directive)) {
        directive = {link: directive};
      }
      directive.restrict = directive.restrict || 'AC';
      return valueFn(directive);
    }
    var htmlAnchorDirective = valueFn({
      restrict: 'E',
      compile: function(element, attr) {
        if (!attr.href && !attr.xlinkHref) {
          return function(scope, element) {
            if (element[0].nodeName.toLowerCase() !== 'a')
              return;
            var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
            element.on('click', function(event) {
              if (!element.attr(href)) {
                event.preventDefault();
              }
            });
          };
        }
      }
    });
    var ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
      if (propName == "multiple")
        return;
      function defaultLinkFn(scope, element, attr) {
        scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
          attr.$set(attrName, !!value);
        });
      }
      var normalized = directiveNormalize('ng-' + attrName);
      var linkFn = defaultLinkFn;
      if (propName === 'checked') {
        linkFn = function(scope, element, attr) {
          if (attr.ngModel !== attr[normalized]) {
            defaultLinkFn(scope, element, attr);
          }
        };
      }
      ngAttributeAliasDirectives[normalized] = function() {
        return {
          restrict: 'A',
          priority: 100,
          link: linkFn
        };
      };
    });
    forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
      ngAttributeAliasDirectives[ngAttr] = function() {
        return {
          priority: 100,
          link: function(scope, element, attr) {
            if (ngAttr === "ngPattern" && attr.ngPattern.charAt(0) == "/") {
              var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
              if (match) {
                attr.$set("ngPattern", new RegExp(match[1], match[2]));
                return;
              }
            }
            scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
              attr.$set(ngAttr, value);
            });
          }
        };
      };
    });
    forEach(['src', 'srcset', 'href'], function(attrName) {
      var normalized = directiveNormalize('ng-' + attrName);
      ngAttributeAliasDirectives[normalized] = function() {
        return {
          priority: 99,
          link: function(scope, element, attr) {
            var propName = attrName,
                name = attrName;
            if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
              name = 'xlinkHref';
              attr.$attr[name] = 'xlink:href';
              propName = null;
            }
            attr.$observe(normalized, function(value) {
              if (!value) {
                if (attrName === 'href') {
                  attr.$set(name, null);
                }
                return;
              }
              attr.$set(name, value);
              if (msie && propName)
                element.prop(propName, attr[name]);
            });
          }
        };
      };
    });
    var nullFormCtrl = {
      $addControl: noop,
      $$renameControl: nullFormRenameControl,
      $removeControl: noop,
      $setValidity: noop,
      $setDirty: noop,
      $setPristine: noop,
      $setSubmitted: noop
    },
        SUBMITTED_CLASS = 'ng-submitted';
    function nullFormRenameControl(control, name) {
      control.$name = name;
    }
    FormController.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate'];
    function FormController(element, attrs, $scope, $animate, $interpolate) {
      var form = this,
          controls = [];
      var parentForm = form.$$parentForm = element.parent().controller('form') || nullFormCtrl;
      form.$error = {};
      form.$$success = {};
      form.$pending = undefined;
      form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
      form.$dirty = false;
      form.$pristine = true;
      form.$valid = true;
      form.$invalid = false;
      form.$submitted = false;
      parentForm.$addControl(form);
      form.$rollbackViewValue = function() {
        forEach(controls, function(control) {
          control.$rollbackViewValue();
        });
      };
      form.$commitViewValue = function() {
        forEach(controls, function(control) {
          control.$commitViewValue();
        });
      };
      form.$addControl = function(control) {
        assertNotHasOwnProperty(control.$name, 'input');
        controls.push(control);
        if (control.$name) {
          form[control.$name] = control;
        }
      };
      form.$$renameControl = function(control, newName) {
        var oldName = control.$name;
        if (form[oldName] === control) {
          delete form[oldName];
        }
        form[newName] = control;
        control.$name = newName;
      };
      form.$removeControl = function(control) {
        if (control.$name && form[control.$name] === control) {
          delete form[control.$name];
        }
        forEach(form.$pending, function(value, name) {
          form.$setValidity(name, null, control);
        });
        forEach(form.$error, function(value, name) {
          form.$setValidity(name, null, control);
        });
        forEach(form.$$success, function(value, name) {
          form.$setValidity(name, null, control);
        });
        arrayRemove(controls, control);
      };
      addSetValidityMethod({
        ctrl: this,
        $element: element,
        set: function(object, property, controller) {
          var list = object[property];
          if (!list) {
            object[property] = [controller];
          } else {
            var index = list.indexOf(controller);
            if (index === -1) {
              list.push(controller);
            }
          }
        },
        unset: function(object, property, controller) {
          var list = object[property];
          if (!list) {
            return;
          }
          arrayRemove(list, controller);
          if (list.length === 0) {
            delete object[property];
          }
        },
        parentForm: parentForm,
        $animate: $animate
      });
      form.$setDirty = function() {
        $animate.removeClass(element, PRISTINE_CLASS);
        $animate.addClass(element, DIRTY_CLASS);
        form.$dirty = true;
        form.$pristine = false;
        parentForm.$setDirty();
      };
      form.$setPristine = function() {
        $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
        form.$dirty = false;
        form.$pristine = true;
        form.$submitted = false;
        forEach(controls, function(control) {
          control.$setPristine();
        });
      };
      form.$setUntouched = function() {
        forEach(controls, function(control) {
          control.$setUntouched();
        });
      };
      form.$setSubmitted = function() {
        $animate.addClass(element, SUBMITTED_CLASS);
        form.$submitted = true;
        parentForm.$setSubmitted();
      };
    }
    var formDirectiveFactory = function(isNgForm) {
      return ['$timeout', function($timeout) {
        var formDirective = {
          name: 'form',
          restrict: isNgForm ? 'EAC' : 'E',
          controller: FormController,
          compile: function ngFormCompile(formElement, attr) {
            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
            var nameAttr = attr.name ? 'name' : (isNgForm && attr.ngForm ? 'ngForm' : false);
            return {pre: function ngFormPreLink(scope, formElement, attr, controller) {
                if (!('action' in attr)) {
                  var handleFormSubmission = function(event) {
                    scope.$apply(function() {
                      controller.$commitViewValue();
                      controller.$setSubmitted();
                    });
                    event.preventDefault();
                  };
                  addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                  formElement.on('$destroy', function() {
                    $timeout(function() {
                      removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                    }, 0, false);
                  });
                }
                var parentFormCtrl = controller.$$parentForm;
                if (nameAttr) {
                  setter(scope, controller.$name, controller, controller.$name);
                  attr.$observe(nameAttr, function(newValue) {
                    if (controller.$name === newValue)
                      return;
                    setter(scope, controller.$name, undefined, controller.$name);
                    parentFormCtrl.$$renameControl(controller, newValue);
                    setter(scope, controller.$name, controller, controller.$name);
                  });
                }
                formElement.on('$destroy', function() {
                  parentFormCtrl.$removeControl(controller);
                  if (nameAttr) {
                    setter(scope, attr[nameAttr], undefined, controller.$name);
                  }
                  extend(controller, nullFormCtrl);
                });
              }};
          }
        };
        return formDirective;
      }];
    };
    var formDirective = formDirectiveFactory();
    var ngFormDirective = formDirectiveFactory(true);
    var ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/;
    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
    var DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/;
    var DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var WEEK_REGEXP = /^(\d{4})-W(\d\d)$/;
    var MONTH_REGEXP = /^(\d{4})-(\d\d)$/;
    var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
    var inputType = {
      'text': textInputType,
      'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),
      'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss', 'sss']), 'yyyy-MM-ddTHH:mm:ss.sss'),
      'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),
      'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
      'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, ['yyyy', 'MM']), 'yyyy-MM'),
      'number': numberInputType,
      'url': urlInputType,
      'email': emailInputType,
      'radio': radioInputType,
      'checkbox': checkboxInputType,
      'hidden': noop,
      'button': noop,
      'submit': noop,
      'reset': noop,
      'file': noop
    };
    function stringBasedInputType(ctrl) {
      ctrl.$formatters.push(function(value) {
        return ctrl.$isEmpty(value) ? value : value.toString();
      });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
      var type = lowercase(element[0].type);
      if (!$sniffer.android) {
        var composing = false;
        element.on('compositionstart', function(data) {
          composing = true;
        });
        element.on('compositionend', function() {
          composing = false;
          listener();
        });
      }
      var listener = function(ev) {
        if (timeout) {
          $browser.defer.cancel(timeout);
          timeout = null;
        }
        if (composing)
          return;
        var value = element.val(),
            event = ev && ev.type;
        if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
          value = trim(value);
        }
        if (ctrl.$viewValue !== value || (value === '' && ctrl.$$hasNativeValidators)) {
          ctrl.$setViewValue(value, event);
        }
      };
      if ($sniffer.hasEvent('input')) {
        element.on('input', listener);
      } else {
        var timeout;
        var deferListener = function(ev, input, origValue) {
          if (!timeout) {
            timeout = $browser.defer(function() {
              timeout = null;
              if (!input || input.value !== origValue) {
                listener(ev);
              }
            });
          }
        };
        element.on('keydown', function(event) {
          var key = event.keyCode;
          if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40))
            return;
          deferListener(event, this, this.value);
        });
        if ($sniffer.hasEvent('paste')) {
          element.on('paste cut', deferListener);
        }
      }
      element.on('change', listener);
      ctrl.$render = function() {
        element.val(ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
      };
    }
    function weekParser(isoWeek, existingDate) {
      if (isDate(isoWeek)) {
        return isoWeek;
      }
      if (isString(isoWeek)) {
        WEEK_REGEXP.lastIndex = 0;
        var parts = WEEK_REGEXP.exec(isoWeek);
        if (parts) {
          var year = +parts[1],
              week = +parts[2],
              hours = 0,
              minutes = 0,
              seconds = 0,
              milliseconds = 0,
              firstThurs = getFirstThursdayOfYear(year),
              addDays = (week - 1) * 7;
          if (existingDate) {
            hours = existingDate.getHours();
            minutes = existingDate.getMinutes();
            seconds = existingDate.getSeconds();
            milliseconds = existingDate.getMilliseconds();
          }
          return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
        }
      }
      return NaN;
    }
    function createDateParser(regexp, mapping) {
      return function(iso, date) {
        var parts,
            map;
        if (isDate(iso)) {
          return iso;
        }
        if (isString(iso)) {
          if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
            iso = iso.substring(1, iso.length - 1);
          }
          if (ISO_DATE_REGEXP.test(iso)) {
            return new Date(iso);
          }
          regexp.lastIndex = 0;
          parts = regexp.exec(iso);
          if (parts) {
            parts.shift();
            if (date) {
              map = {
                yyyy: date.getFullYear(),
                MM: date.getMonth() + 1,
                dd: date.getDate(),
                HH: date.getHours(),
                mm: date.getMinutes(),
                ss: date.getSeconds(),
                sss: date.getMilliseconds() / 1000
              };
            } else {
              map = {
                yyyy: 1970,
                MM: 1,
                dd: 1,
                HH: 0,
                mm: 0,
                ss: 0,
                sss: 0
              };
            }
            forEach(parts, function(part, index) {
              if (index < mapping.length) {
                map[mapping[index]] = +part;
              }
            });
            return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
          }
        }
        return NaN;
      };
    }
    function createDateInputType(type, regexp, parseDate, format) {
      return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
        badInputChecker(scope, element, attr, ctrl);
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
        var previousDate;
        ctrl.$$parserName = type;
        ctrl.$parsers.push(function(value) {
          if (ctrl.$isEmpty(value))
            return null;
          if (regexp.test(value)) {
            var parsedDate = parseDate(value, previousDate);
            if (timezone) {
              parsedDate = convertTimezoneToLocal(parsedDate, timezone);
            }
            return parsedDate;
          }
          return undefined;
        });
        ctrl.$formatters.push(function(value) {
          if (value && !isDate(value)) {
            throw $ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
          }
          if (isValidDate(value)) {
            previousDate = value;
            if (previousDate && timezone) {
              previousDate = convertTimezoneToLocal(previousDate, timezone, true);
            }
            return $filter('date')(value, format, timezone);
          } else {
            previousDate = null;
            return '';
          }
        });
        if (isDefined(attr.min) || attr.ngMin) {
          var minVal;
          ctrl.$validators.min = function(value) {
            return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
          };
          attr.$observe('min', function(val) {
            minVal = parseObservedDateValue(val);
            ctrl.$validate();
          });
        }
        if (isDefined(attr.max) || attr.ngMax) {
          var maxVal;
          ctrl.$validators.max = function(value) {
            return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
          };
          attr.$observe('max', function(val) {
            maxVal = parseObservedDateValue(val);
            ctrl.$validate();
          });
        }
        function isValidDate(value) {
          return value && !(value.getTime && value.getTime() !== value.getTime());
        }
        function parseObservedDateValue(val) {
          return isDefined(val) ? (isDate(val) ? val : parseDate(val)) : undefined;
        }
      };
    }
    function badInputChecker(scope, element, attr, ctrl) {
      var node = element[0];
      var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
      if (nativeValidation) {
        ctrl.$parsers.push(function(value) {
          var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
          return validity.badInput && !validity.typeMismatch ? undefined : value;
        });
      }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
      badInputChecker(scope, element, attr, ctrl);
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      ctrl.$$parserName = 'number';
      ctrl.$parsers.push(function(value) {
        if (ctrl.$isEmpty(value))
          return null;
        if (NUMBER_REGEXP.test(value))
          return parseFloat(value);
        return undefined;
      });
      ctrl.$formatters.push(function(value) {
        if (!ctrl.$isEmpty(value)) {
          if (!isNumber(value)) {
            throw $ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
          }
          value = value.toString();
        }
        return value;
      });
      if (isDefined(attr.min) || attr.ngMin) {
        var minVal;
        ctrl.$validators.min = function(value) {
          return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
        };
        attr.$observe('min', function(val) {
          if (isDefined(val) && !isNumber(val)) {
            val = parseFloat(val, 10);
          }
          minVal = isNumber(val) && !isNaN(val) ? val : undefined;
          ctrl.$validate();
        });
      }
      if (isDefined(attr.max) || attr.ngMax) {
        var maxVal;
        ctrl.$validators.max = function(value) {
          return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
        };
        attr.$observe('max', function(val) {
          if (isDefined(val) && !isNumber(val)) {
            val = parseFloat(val, 10);
          }
          maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
          ctrl.$validate();
        });
      }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      stringBasedInputType(ctrl);
      ctrl.$$parserName = 'url';
      ctrl.$validators.url = function(modelValue, viewValue) {
        var value = modelValue || viewValue;
        return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
      };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
      baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
      stringBasedInputType(ctrl);
      ctrl.$$parserName = 'email';
      ctrl.$validators.email = function(modelValue, viewValue) {
        var value = modelValue || viewValue;
        return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
      };
    }
    function radioInputType(scope, element, attr, ctrl) {
      if (isUndefined(attr.name)) {
        element.attr('name', nextUid());
      }
      var listener = function(ev) {
        if (element[0].checked) {
          ctrl.$setViewValue(attr.value, ev && ev.type);
        }
      };
      element.on('click', listener);
      ctrl.$render = function() {
        var value = attr.value;
        element[0].checked = (value == ctrl.$viewValue);
      };
      attr.$observe('value', ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
      var parseFn;
      if (isDefined(expression)) {
        parseFn = $parse(expression);
        if (!parseFn.constant) {
          throw minErr('ngModel')('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
        }
        return parseFn(context);
      }
      return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
      var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
      var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
      var listener = function(ev) {
        ctrl.$setViewValue(element[0].checked, ev && ev.type);
      };
      element.on('click', listener);
      ctrl.$render = function() {
        element[0].checked = ctrl.$viewValue;
      };
      ctrl.$isEmpty = function(value) {
        return value === false;
      };
      ctrl.$formatters.push(function(value) {
        return equals(value, trueValue);
      });
      ctrl.$parsers.push(function(value) {
        return value ? trueValue : falseValue;
      });
    }
    var inputDirective = ['$browser', '$sniffer', '$filter', '$parse', function($browser, $sniffer, $filter, $parse) {
      return {
        restrict: 'E',
        require: ['?ngModel'],
        link: {pre: function(scope, element, attr, ctrls) {
            if (ctrls[0]) {
              (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
            }
          }}
      };
    }];
    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
    var ngValueDirective = function() {
      return {
        restrict: 'A',
        priority: 100,
        compile: function(tpl, tplAttr) {
          if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
            return function ngValueConstantLink(scope, elm, attr) {
              attr.$set('value', scope.$eval(attr.ngValue));
            };
          } else {
            return function ngValueLink(scope, elm, attr) {
              scope.$watch(attr.ngValue, function valueWatchAction(value) {
                attr.$set('value', value);
              });
            };
          }
        }
      };
    };
    var ngBindDirective = ['$compile', function($compile) {
      return {
        restrict: 'AC',
        compile: function ngBindCompile(templateElement) {
          $compile.$$addBindingClass(templateElement);
          return function ngBindLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBind);
            element = element[0];
            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
              element.textContent = value === undefined ? '' : value;
            });
          };
        }
      };
    }];
    var ngBindTemplateDirective = ['$interpolate', '$compile', function($interpolate, $compile) {
      return {compile: function ngBindTemplateCompile(templateElement) {
          $compile.$$addBindingClass(templateElement);
          return function ngBindTemplateLink(scope, element, attr) {
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            $compile.$$addBindingInfo(element, interpolateFn.expressions);
            element = element[0];
            attr.$observe('ngBindTemplate', function(value) {
              element.textContent = value === undefined ? '' : value;
            });
          };
        }};
    }];
    var ngBindHtmlDirective = ['$sce', '$parse', '$compile', function($sce, $parse, $compile) {
      return {
        restrict: 'A',
        compile: function ngBindHtmlCompile(tElement, tAttrs) {
          var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
          var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
            return (value || '').toString();
          });
          $compile.$$addBindingClass(tElement);
          return function ngBindHtmlLink(scope, element, attr) {
            $compile.$$addBindingInfo(element, attr.ngBindHtml);
            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
              element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
            });
          };
        }
      };
    }];
    var ngChangeDirective = valueFn({
      restrict: 'A',
      require: 'ngModel',
      link: function(scope, element, attr, ctrl) {
        ctrl.$viewChangeListeners.push(function() {
          scope.$eval(attr.ngChange);
        });
      }
    });
    function classDirective(name, selector) {
      name = 'ngClass' + name;
      return ['$animate', function($animate) {
        return {
          restrict: 'AC',
          link: function(scope, element, attr) {
            var oldVal;
            scope.$watch(attr[name], ngClassWatchAction, true);
            attr.$observe('class', function(value) {
              ngClassWatchAction(scope.$eval(attr[name]));
            });
            if (name !== 'ngClass') {
              scope.$watch('$index', function($index, old$index) {
                var mod = $index & 1;
                if (mod !== (old$index & 1)) {
                  var classes = arrayClasses(scope.$eval(attr[name]));
                  mod === selector ? addClasses(classes) : removeClasses(classes);
                }
              });
            }
            function addClasses(classes) {
              var newClasses = digestClassCounts(classes, 1);
              attr.$addClass(newClasses);
            }
            function removeClasses(classes) {
              var newClasses = digestClassCounts(classes, -1);
              attr.$removeClass(newClasses);
            }
            function digestClassCounts(classes, count) {
              var classCounts = element.data('$classCounts') || createMap();
              var classesToUpdate = [];
              forEach(classes, function(className) {
                if (count > 0 || classCounts[className]) {
                  classCounts[className] = (classCounts[className] || 0) + count;
                  if (classCounts[className] === +(count > 0)) {
                    classesToUpdate.push(className);
                  }
                }
              });
              element.data('$classCounts', classCounts);
              return classesToUpdate.join(' ');
            }
            function updateClasses(oldClasses, newClasses) {
              var toAdd = arrayDifference(newClasses, oldClasses);
              var toRemove = arrayDifference(oldClasses, newClasses);
              toAdd = digestClassCounts(toAdd, 1);
              toRemove = digestClassCounts(toRemove, -1);
              if (toAdd && toAdd.length) {
                $animate.addClass(element, toAdd);
              }
              if (toRemove && toRemove.length) {
                $animate.removeClass(element, toRemove);
              }
            }
            function ngClassWatchAction(newVal) {
              if (selector === true || scope.$index % 2 === selector) {
                var newClasses = arrayClasses(newVal || []);
                if (!oldVal) {
                  addClasses(newClasses);
                } else if (!equals(newVal, oldVal)) {
                  var oldClasses = arrayClasses(oldVal);
                  updateClasses(oldClasses, newClasses);
                }
              }
              oldVal = shallowCopy(newVal);
            }
          }
        };
        function arrayDifference(tokens1, tokens2) {
          var values = [];
          outer: for (var i = 0; i < tokens1.length; i++) {
            var token = tokens1[i];
            for (var j = 0; j < tokens2.length; j++) {
              if (token == tokens2[j])
                continue outer;
            }
            values.push(token);
          }
          return values;
        }
        function arrayClasses(classVal) {
          var classes = [];
          if (isArray(classVal)) {
            forEach(classVal, function(v) {
              classes = classes.concat(arrayClasses(v));
            });
            return classes;
          } else if (isString(classVal)) {
            return classVal.split(' ');
          } else if (isObject(classVal)) {
            forEach(classVal, function(v, k) {
              if (v) {
                classes = classes.concat(k.split(' '));
              }
            });
            return classes;
          }
          return classVal;
        }
      }];
    }
    var ngClassDirective = classDirective('', true);
    var ngClassOddDirective = classDirective('Odd', 0);
    var ngClassEvenDirective = classDirective('Even', 1);
    var ngCloakDirective = ngDirective({compile: function(element, attr) {
        attr.$set('ngCloak', undefined);
        element.removeClass('ng-cloak');
      }});
    var ngControllerDirective = [function() {
      return {
        restrict: 'A',
        scope: true,
        controller: '@',
        priority: 500
      };
    }];
    var ngEventDirectives = {};
    var forceAsyncEvents = {
      'blur': true,
      'focus': true
    };
    forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function(eventName) {
      var directiveName = directiveNormalize('ng-' + eventName);
      ngEventDirectives[directiveName] = ['$parse', '$rootScope', function($parse, $rootScope) {
        return {
          restrict: 'A',
          compile: function($element, attr) {
            var fn = $parse(attr[directiveName], null, true);
            return function ngEventHandler(scope, element) {
              element.on(eventName, function(event) {
                var callback = function() {
                  fn(scope, {$event: event});
                };
                if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                  scope.$evalAsync(callback);
                } else {
                  scope.$apply(callback);
                }
              });
            };
          }
        };
      }];
    });
    var ngIfDirective = ['$animate', function($animate) {
      return {
        multiElement: true,
        transclude: 'element',
        priority: 600,
        terminal: true,
        restrict: 'A',
        $$tlb: true,
        link: function($scope, $element, $attr, ctrl, $transclude) {
          var block,
              childScope,
              previousElements;
          $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
            if (value) {
              if (!childScope) {
                $transclude(function(clone, newScope) {
                  childScope = newScope;
                  clone[clone.length++] = document.createComment(' end ngIf: ' + $attr.ngIf + ' ');
                  block = {clone: clone};
                  $animate.enter(clone, $element.parent(), $element);
                });
              }
            } else {
              if (previousElements) {
                previousElements.remove();
                previousElements = null;
              }
              if (childScope) {
                childScope.$destroy();
                childScope = null;
              }
              if (block) {
                previousElements = getBlockNodes(block.clone);
                $animate.leave(previousElements).then(function() {
                  previousElements = null;
                });
                block = null;
              }
            }
          });
        }
      };
    }];
    var ngIncludeDirective = ['$templateRequest', '$anchorScroll', '$animate', function($templateRequest, $anchorScroll, $animate) {
      return {
        restrict: 'ECA',
        priority: 400,
        terminal: true,
        transclude: 'element',
        controller: angular.noop,
        compile: function(element, attr) {
          var srcExp = attr.ngInclude || attr.src,
              onloadExp = attr.onload || '',
              autoScrollExp = attr.autoscroll;
          return function(scope, $element, $attr, ctrl, $transclude) {
            var changeCounter = 0,
                currentScope,
                previousElement,
                currentElement;
            var cleanupLastIncludeContent = function() {
              if (previousElement) {
                previousElement.remove();
                previousElement = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentElement) {
                $animate.leave(currentElement).then(function() {
                  previousElement = null;
                });
                previousElement = currentElement;
                currentElement = null;
              }
            };
            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
              var afterAnimation = function() {
                if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                  $anchorScroll();
                }
              };
              var thisChangeId = ++changeCounter;
              if (src) {
                $templateRequest(src, true).then(function(response) {
                  if (thisChangeId !== changeCounter)
                    return;
                  var newScope = scope.$new();
                  ctrl.template = response;
                  var clone = $transclude(newScope, function(clone) {
                    cleanupLastIncludeContent();
                    $animate.enter(clone, null, $element).then(afterAnimation);
                  });
                  currentScope = newScope;
                  currentElement = clone;
                  currentScope.$emit('$includeContentLoaded', src);
                  scope.$eval(onloadExp);
                }, function() {
                  if (thisChangeId === changeCounter) {
                    cleanupLastIncludeContent();
                    scope.$emit('$includeContentError', src);
                  }
                });
                scope.$emit('$includeContentRequested', src);
              } else {
                cleanupLastIncludeContent();
                ctrl.template = null;
              }
            });
          };
        }
      };
    }];
    var ngIncludeFillContentDirective = ['$compile', function($compile) {
      return {
        restrict: 'ECA',
        priority: -400,
        require: 'ngInclude',
        link: function(scope, $element, $attr, ctrl) {
          if (/SVG/.test($element[0].toString())) {
            $element.empty();
            $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function namespaceAdaptedClone(clone) {
              $element.append(clone);
            }, {futureParentElement: $element});
            return;
          }
          $element.html(ctrl.template);
          $compile($element.contents())(scope);
        }
      };
    }];
    var ngInitDirective = ngDirective({
      priority: 450,
      compile: function() {
        return {pre: function(scope, element, attrs) {
            scope.$eval(attrs.ngInit);
          }};
      }
    });
    var ngListDirective = function() {
      return {
        restrict: 'A',
        priority: 100,
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
          var ngList = element.attr(attr.$attr.ngList) || ', ';
          var trimValues = attr.ngTrim !== 'false';
          var separator = trimValues ? trim(ngList) : ngList;
          var parse = function(viewValue) {
            if (isUndefined(viewValue))
              return;
            var list = [];
            if (viewValue) {
              forEach(viewValue.split(separator), function(value) {
                if (value)
                  list.push(trimValues ? trim(value) : value);
              });
            }
            return list;
          };
          ctrl.$parsers.push(parse);
          ctrl.$formatters.push(function(value) {
            if (isArray(value)) {
              return value.join(ngList);
            }
            return undefined;
          });
          ctrl.$isEmpty = function(value) {
            return !value || !value.length;
          };
        }
      };
    };
    var VALID_CLASS = 'ng-valid',
        INVALID_CLASS = 'ng-invalid',
        PRISTINE_CLASS = 'ng-pristine',
        DIRTY_CLASS = 'ng-dirty',
        UNTOUCHED_CLASS = 'ng-untouched',
        TOUCHED_CLASS = 'ng-touched',
        PENDING_CLASS = 'ng-pending';
    var $ngModelMinErr = new minErr('ngModel');
    var NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse', '$animate', '$timeout', '$rootScope', '$q', '$interpolate', function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
      this.$viewValue = Number.NaN;
      this.$modelValue = Number.NaN;
      this.$$rawModelValue = undefined;
      this.$validators = {};
      this.$asyncValidators = {};
      this.$parsers = [];
      this.$formatters = [];
      this.$viewChangeListeners = [];
      this.$untouched = true;
      this.$touched = false;
      this.$pristine = true;
      this.$dirty = false;
      this.$valid = true;
      this.$invalid = false;
      this.$error = {};
      this.$$success = {};
      this.$pending = undefined;
      this.$name = $interpolate($attr.name || '', false)($scope);
      var parsedNgModel = $parse($attr.ngModel),
          parsedNgModelAssign = parsedNgModel.assign,
          ngModelGet = parsedNgModel,
          ngModelSet = parsedNgModelAssign,
          pendingDebounce = null,
          parserValid,
          ctrl = this;
      this.$$setOptions = function(options) {
        ctrl.$options = options;
        if (options && options.getterSetter) {
          var invokeModelGetter = $parse($attr.ngModel + '()'),
              invokeModelSetter = $parse($attr.ngModel + '($$$p)');
          ngModelGet = function($scope) {
            var modelValue = parsedNgModel($scope);
            if (isFunction(modelValue)) {
              modelValue = invokeModelGetter($scope);
            }
            return modelValue;
          };
          ngModelSet = function($scope, newValue) {
            if (isFunction(parsedNgModel($scope))) {
              invokeModelSetter($scope, {$$$p: ctrl.$modelValue});
            } else {
              parsedNgModelAssign($scope, ctrl.$modelValue);
            }
          };
        } else if (!parsedNgModel.assign) {
          throw $ngModelMinErr('nonassign', "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        }
      };
      this.$render = noop;
      this.$isEmpty = function(value) {
        return isUndefined(value) || value === '' || value === null || value !== value;
      };
      var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
          currentValidationRunId = 0;
      addSetValidityMethod({
        ctrl: this,
        $element: $element,
        set: function(object, property) {
          object[property] = true;
        },
        unset: function(object, property) {
          delete object[property];
        },
        parentForm: parentForm,
        $animate: $animate
      });
      this.$setPristine = function() {
        ctrl.$dirty = false;
        ctrl.$pristine = true;
        $animate.removeClass($element, DIRTY_CLASS);
        $animate.addClass($element, PRISTINE_CLASS);
      };
      this.$setDirty = function() {
        ctrl.$dirty = true;
        ctrl.$pristine = false;
        $animate.removeClass($element, PRISTINE_CLASS);
        $animate.addClass($element, DIRTY_CLASS);
        parentForm.$setDirty();
      };
      this.$setUntouched = function() {
        ctrl.$touched = false;
        ctrl.$untouched = true;
        $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
      };
      this.$setTouched = function() {
        ctrl.$touched = true;
        ctrl.$untouched = false;
        $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
      };
      this.$rollbackViewValue = function() {
        $timeout.cancel(pendingDebounce);
        ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
        ctrl.$render();
      };
      this.$validate = function() {
        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
          return;
        }
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = ctrl.$$rawModelValue;
        var prevValid = ctrl.$valid;
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
        ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
          if (!allowInvalid && prevValid !== allValid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            if (ctrl.$modelValue !== prevModelValue) {
              ctrl.$$writeModelToScope();
            }
          }
        });
      };
      this.$$runValidators = function(modelValue, viewValue, doneCallback) {
        currentValidationRunId++;
        var localValidationRunId = currentValidationRunId;
        if (!processParseErrors()) {
          validationDone(false);
          return;
        }
        if (!processSyncValidators()) {
          validationDone(false);
          return;
        }
        processAsyncValidators();
        function processParseErrors() {
          var errorKey = ctrl.$$parserName || 'parse';
          if (parserValid === undefined) {
            setValidity(errorKey, null);
          } else {
            if (!parserValid) {
              forEach(ctrl.$validators, function(v, name) {
                setValidity(name, null);
              });
              forEach(ctrl.$asyncValidators, function(v, name) {
                setValidity(name, null);
              });
            }
            setValidity(errorKey, parserValid);
            return parserValid;
          }
          return true;
        }
        function processSyncValidators() {
          var syncValidatorsValid = true;
          forEach(ctrl.$validators, function(validator, name) {
            var result = validator(modelValue, viewValue);
            syncValidatorsValid = syncValidatorsValid && result;
            setValidity(name, result);
          });
          if (!syncValidatorsValid) {
            forEach(ctrl.$asyncValidators, function(v, name) {
              setValidity(name, null);
            });
            return false;
          }
          return true;
        }
        function processAsyncValidators() {
          var validatorPromises = [];
          var allValid = true;
          forEach(ctrl.$asyncValidators, function(validator, name) {
            var promise = validator(modelValue, viewValue);
            if (!isPromiseLike(promise)) {
              throw $ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
            }
            setValidity(name, undefined);
            validatorPromises.push(promise.then(function() {
              setValidity(name, true);
            }, function(error) {
              allValid = false;
              setValidity(name, false);
            }));
          });
          if (!validatorPromises.length) {
            validationDone(true);
          } else {
            $q.all(validatorPromises).then(function() {
              validationDone(allValid);
            }, noop);
          }
        }
        function setValidity(name, isValid) {
          if (localValidationRunId === currentValidationRunId) {
            ctrl.$setValidity(name, isValid);
          }
        }
        function validationDone(allValid) {
          if (localValidationRunId === currentValidationRunId) {
            doneCallback(allValid);
          }
        }
      };
      this.$commitViewValue = function() {
        var viewValue = ctrl.$viewValue;
        $timeout.cancel(pendingDebounce);
        if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
          return;
        }
        ctrl.$$lastCommittedViewValue = viewValue;
        if (ctrl.$pristine) {
          this.$setDirty();
        }
        this.$$parseAndValidate();
      };
      this.$$parseAndValidate = function() {
        var viewValue = ctrl.$$lastCommittedViewValue;
        var modelValue = viewValue;
        parserValid = isUndefined(modelValue) ? undefined : true;
        if (parserValid) {
          for (var i = 0; i < ctrl.$parsers.length; i++) {
            modelValue = ctrl.$parsers[i](modelValue);
            if (isUndefined(modelValue)) {
              parserValid = false;
              break;
            }
          }
        }
        if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
          ctrl.$modelValue = ngModelGet($scope);
        }
        var prevModelValue = ctrl.$modelValue;
        var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
        ctrl.$$rawModelValue = modelValue;
        if (allowInvalid) {
          ctrl.$modelValue = modelValue;
          writeToModelIfNeeded();
        }
        ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
          if (!allowInvalid) {
            ctrl.$modelValue = allValid ? modelValue : undefined;
            writeToModelIfNeeded();
          }
        });
        function writeToModelIfNeeded() {
          if (ctrl.$modelValue !== prevModelValue) {
            ctrl.$$writeModelToScope();
          }
        }
      };
      this.$$writeModelToScope = function() {
        ngModelSet($scope, ctrl.$modelValue);
        forEach(ctrl.$viewChangeListeners, function(listener) {
          try {
            listener();
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      };
      this.$setViewValue = function(value, trigger) {
        ctrl.$viewValue = value;
        if (!ctrl.$options || ctrl.$options.updateOnDefault) {
          ctrl.$$debounceViewValueCommit(trigger);
        }
      };
      this.$$debounceViewValueCommit = function(trigger) {
        var debounceDelay = 0,
            options = ctrl.$options,
            debounce;
        if (options && isDefined(options.debounce)) {
          debounce = options.debounce;
          if (isNumber(debounce)) {
            debounceDelay = debounce;
          } else if (isNumber(debounce[trigger])) {
            debounceDelay = debounce[trigger];
          } else if (isNumber(debounce['default'])) {
            debounceDelay = debounce['default'];
          }
        }
        $timeout.cancel(pendingDebounce);
        if (debounceDelay) {
          pendingDebounce = $timeout(function() {
            ctrl.$commitViewValue();
          }, debounceDelay);
        } else if ($rootScope.$$phase) {
          ctrl.$commitViewValue();
        } else {
          $scope.$apply(function() {
            ctrl.$commitViewValue();
          });
        }
      };
      $scope.$watch(function ngModelWatch() {
        var modelValue = ngModelGet($scope);
        if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
          ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
          parserValid = undefined;
          var formatters = ctrl.$formatters,
              idx = formatters.length;
          var viewValue = modelValue;
          while (idx--) {
            viewValue = formatters[idx](viewValue);
          }
          if (ctrl.$viewValue !== viewValue) {
            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
            ctrl.$render();
            ctrl.$$runValidators(modelValue, viewValue, noop);
          }
        }
        return modelValue;
      });
    }];
    var ngModelDirective = ['$rootScope', function($rootScope) {
      return {
        restrict: 'A',
        require: ['ngModel', '^?form', '^?ngModelOptions'],
        controller: NgModelController,
        priority: 1,
        compile: function ngModelCompile(element) {
          element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
          return {
            pre: function ngModelPreLink(scope, element, attr, ctrls) {
              var modelCtrl = ctrls[0],
                  formCtrl = ctrls[1] || nullFormCtrl;
              modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
              formCtrl.$addControl(modelCtrl);
              attr.$observe('name', function(newValue) {
                if (modelCtrl.$name !== newValue) {
                  formCtrl.$$renameControl(modelCtrl, newValue);
                }
              });
              scope.$on('$destroy', function() {
                formCtrl.$removeControl(modelCtrl);
              });
            },
            post: function ngModelPostLink(scope, element, attr, ctrls) {
              var modelCtrl = ctrls[0];
              if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                element.on(modelCtrl.$options.updateOn, function(ev) {
                  modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                });
              }
              element.on('blur', function(ev) {
                if (modelCtrl.$touched)
                  return;
                if ($rootScope.$$phase) {
                  scope.$evalAsync(modelCtrl.$setTouched);
                } else {
                  scope.$apply(modelCtrl.$setTouched);
                }
              });
            }
          };
        }
      };
    }];
    var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    var ngModelOptionsDirective = function() {
      return {
        restrict: 'A',
        controller: ['$scope', '$attrs', function($scope, $attrs) {
          var that = this;
          this.$options = copy($scope.$eval($attrs.ngModelOptions));
          if (this.$options.updateOn !== undefined) {
            this.$options.updateOnDefault = false;
            this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
              that.$options.updateOnDefault = true;
              return ' ';
            }));
          } else {
            this.$options.updateOnDefault = true;
          }
        }]
      };
    };
    function addSetValidityMethod(context) {
      var ctrl = context.ctrl,
          $element = context.$element,
          classCache = {},
          set = context.set,
          unset = context.unset,
          parentForm = context.parentForm,
          $animate = context.$animate;
      classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
      ctrl.$setValidity = setValidity;
      function setValidity(validationErrorKey, state, controller) {
        if (state === undefined) {
          createAndSet('$pending', validationErrorKey, controller);
        } else {
          unsetAndCleanup('$pending', validationErrorKey, controller);
        }
        if (!isBoolean(state)) {
          unset(ctrl.$error, validationErrorKey, controller);
          unset(ctrl.$$success, validationErrorKey, controller);
        } else {
          if (state) {
            unset(ctrl.$error, validationErrorKey, controller);
            set(ctrl.$$success, validationErrorKey, controller);
          } else {
            set(ctrl.$error, validationErrorKey, controller);
            unset(ctrl.$$success, validationErrorKey, controller);
          }
        }
        if (ctrl.$pending) {
          cachedToggleClass(PENDING_CLASS, true);
          ctrl.$valid = ctrl.$invalid = undefined;
          toggleValidationCss('', null);
        } else {
          cachedToggleClass(PENDING_CLASS, false);
          ctrl.$valid = isObjectEmpty(ctrl.$error);
          ctrl.$invalid = !ctrl.$valid;
          toggleValidationCss('', ctrl.$valid);
        }
        var combinedState;
        if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
          combinedState = undefined;
        } else if (ctrl.$error[validationErrorKey]) {
          combinedState = false;
        } else if (ctrl.$$success[validationErrorKey]) {
          combinedState = true;
        } else {
          combinedState = null;
        }
        toggleValidationCss(validationErrorKey, combinedState);
        parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
      }
      function createAndSet(name, value, controller) {
        if (!ctrl[name]) {
          ctrl[name] = {};
        }
        set(ctrl[name], value, controller);
      }
      function unsetAndCleanup(name, value, controller) {
        if (ctrl[name]) {
          unset(ctrl[name], value, controller);
        }
        if (isObjectEmpty(ctrl[name])) {
          ctrl[name] = undefined;
        }
      }
      function cachedToggleClass(className, switchValue) {
        if (switchValue && !classCache[className]) {
          $animate.addClass($element, className);
          classCache[className] = true;
        } else if (!switchValue && classCache[className]) {
          $animate.removeClass($element, className);
          classCache[className] = false;
        }
      }
      function toggleValidationCss(validationErrorKey, isValid) {
        validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
        cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
        cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
      }
    }
    function isObjectEmpty(obj) {
      if (obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            return false;
          }
        }
      }
      return true;
    }
    var ngNonBindableDirective = ngDirective({
      terminal: true,
      priority: 1000
    });
    var ngOptionsMinErr = minErr('ngOptions');
    var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
    var ngOptionsDirective = ['$compile', '$parse', function($compile, $parse) {
      function parseOptionsExpression(optionsExp, selectElement, scope) {
        var match = optionsExp.match(NG_OPTIONS_REGEXP);
        if (!(match)) {
          throw ngOptionsMinErr('iexp', "Expected expression in form of " + "'_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" + " but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
        }
        var valueName = match[5] || match[7];
        var keyName = match[6];
        var selectAs = / as /.test(match[0]) && match[1];
        var trackBy = match[9];
        var valueFn = $parse(match[2] ? match[1] : valueName);
        var selectAsFn = selectAs && $parse(selectAs);
        var viewValueFn = selectAsFn || valueFn;
        var trackByFn = trackBy && $parse(trackBy);
        var getTrackByValueFn = trackBy ? function(value, locals) {
          return trackByFn(scope, locals);
        } : function getHashOfValue(value) {
          return hashKey(value);
        };
        var getTrackByValue = function(value, key) {
          return getTrackByValueFn(value, getLocals(value, key));
        };
        var displayFn = $parse(match[2] || match[1]);
        var groupByFn = $parse(match[3] || '');
        var disableWhenFn = $parse(match[4] || '');
        var valuesFn = $parse(match[8]);
        var locals = {};
        var getLocals = keyName ? function(value, key) {
          locals[keyName] = key;
          locals[valueName] = value;
          return locals;
        } : function(value) {
          locals[valueName] = value;
          return locals;
        };
        function Option(selectValue, viewValue, label, group, disabled) {
          this.selectValue = selectValue;
          this.viewValue = viewValue;
          this.label = label;
          this.group = group;
          this.disabled = disabled;
        }
        function getOptionValuesKeys(optionValues) {
          var optionValuesKeys;
          if (!keyName && isArrayLike(optionValues)) {
            optionValuesKeys = optionValues;
          } else {
            optionValuesKeys = [];
            for (var itemKey in optionValues) {
              if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                optionValuesKeys.push(itemKey);
              }
            }
          }
          return optionValuesKeys;
        }
        return {
          trackBy: trackBy,
          getTrackByValue: getTrackByValue,
          getWatchables: $parse(valuesFn, function(optionValues) {
            var watchedArray = [];
            optionValues = optionValues || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
              var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
              var value = optionValues[key];
              var locals = getLocals(optionValues[key], key);
              var selectValue = getTrackByValueFn(optionValues[key], locals);
              watchedArray.push(selectValue);
              if (match[2] || match[1]) {
                var label = displayFn(scope, locals);
                watchedArray.push(label);
              }
              if (match[4]) {
                var disableWhen = disableWhenFn(scope, locals);
                watchedArray.push(disableWhen);
              }
            }
            return watchedArray;
          }),
          getOptions: function() {
            var optionItems = [];
            var selectValueMap = {};
            var optionValues = valuesFn(scope) || [];
            var optionValuesKeys = getOptionValuesKeys(optionValues);
            var optionValuesLength = optionValuesKeys.length;
            for (var index = 0; index < optionValuesLength; index++) {
              var key = (optionValues === optionValuesKeys) ? index : optionValuesKeys[index];
              var value = optionValues[key];
              var locals = getLocals(value, key);
              var viewValue = viewValueFn(scope, locals);
              var selectValue = getTrackByValueFn(viewValue, locals);
              var label = displayFn(scope, locals);
              var group = groupByFn(scope, locals);
              var disabled = disableWhenFn(scope, locals);
              var optionItem = new Option(selectValue, viewValue, label, group, disabled);
              optionItems.push(optionItem);
              selectValueMap[selectValue] = optionItem;
            }
            return {
              items: optionItems,
              selectValueMap: selectValueMap,
              getOptionFromViewValue: function(value) {
                return selectValueMap[getTrackByValue(value)];
              },
              getViewValueFromOption: function(option) {
                return trackBy ? angular.copy(option.viewValue) : option.viewValue;
              }
            };
          }
        };
      }
      var optionTemplate = document.createElement('option'),
          optGroupTemplate = document.createElement('optgroup');
      return {
        restrict: 'A',
        terminal: true,
        require: ['select', '?ngModel'],
        link: function(scope, selectElement, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          var multiple = attr.multiple;
          var emptyOption;
          for (var i = 0,
              children = selectElement.children(),
              ii = children.length; i < ii; i++) {
            if (children[i].value === '') {
              emptyOption = children.eq(i);
              break;
            }
          }
          var providedEmptyOption = !!emptyOption;
          var unknownOption = jqLite(optionTemplate.cloneNode(false));
          unknownOption.val('?');
          var options;
          var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
          var renderEmptyOption = function() {
            if (!providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            selectElement.val('');
            emptyOption.prop('selected', true);
            emptyOption.attr('selected', true);
          };
          var removeEmptyOption = function() {
            if (!providedEmptyOption) {
              emptyOption.remove();
            }
          };
          var renderUnknownOption = function() {
            selectElement.prepend(unknownOption);
            selectElement.val('?');
            unknownOption.prop('selected', true);
            unknownOption.attr('selected', true);
          };
          var removeUnknownOption = function() {
            unknownOption.remove();
          };
          if (!multiple) {
            selectCtrl.writeValue = function writeNgOptionsValue(value) {
              var option = options.getOptionFromViewValue(value);
              if (option && !option.disabled) {
                if (selectElement[0].value !== option.selectValue) {
                  removeUnknownOption();
                  removeEmptyOption();
                  selectElement[0].value = option.selectValue;
                  option.element.selected = true;
                  option.element.setAttribute('selected', 'selected');
                }
              } else {
                if (value === null || providedEmptyOption) {
                  removeUnknownOption();
                  renderEmptyOption();
                } else {
                  removeEmptyOption();
                  renderUnknownOption();
                }
              }
            };
            selectCtrl.readValue = function readNgOptionsValue() {
              var selectedOption = options.selectValueMap[selectElement.val()];
              if (selectedOption && !selectedOption.disabled) {
                removeEmptyOption();
                removeUnknownOption();
                return options.getViewValueFromOption(selectedOption);
              }
              return null;
            };
            if (ngOptions.trackBy) {
              scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
              }, function() {
                ngModelCtrl.$render();
              });
            }
          } else {
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
            selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
              options.items.forEach(function(option) {
                option.element.selected = false;
              });
              if (value) {
                value.forEach(function(item) {
                  var option = options.getOptionFromViewValue(item);
                  if (option && !option.disabled)
                    option.element.selected = true;
                });
              }
            };
            selectCtrl.readValue = function readNgOptionsMultiple() {
              var selectedValues = selectElement.val() || [],
                  selections = [];
              forEach(selectedValues, function(value) {
                var option = options.selectValueMap[value];
                if (!option.disabled)
                  selections.push(options.getViewValueFromOption(option));
              });
              return selections;
            };
            if (ngOptions.trackBy) {
              scope.$watchCollection(function() {
                if (isArray(ngModelCtrl.$viewValue)) {
                  return ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                  });
                }
              }, function() {
                ngModelCtrl.$render();
              });
            }
          }
          if (providedEmptyOption) {
            emptyOption.remove();
            $compile(emptyOption)(scope);
            emptyOption.removeClass('ng-scope');
          } else {
            emptyOption = jqLite(optionTemplate.cloneNode(false));
          }
          updateOptions();
          scope.$watchCollection(ngOptions.getWatchables, updateOptions);
          function updateOptionElement(option, element) {
            option.element = element;
            element.disabled = option.disabled;
            if (option.value !== element.value)
              element.value = option.selectValue;
            if (option.label !== element.label) {
              element.label = option.label;
              element.textContent = option.label;
            }
          }
          function addOrReuseElement(parent, current, type, templateElement) {
            var element;
            if (current && lowercase(current.nodeName) === type) {
              element = current;
            } else {
              element = templateElement.cloneNode(false);
              if (!current) {
                parent.appendChild(element);
              } else {
                parent.insertBefore(element, current);
              }
            }
            return element;
          }
          function removeExcessElements(current) {
            var next;
            while (current) {
              next = current.nextSibling;
              jqLiteRemove(current);
              current = next;
            }
          }
          function skipEmptyAndUnknownOptions(current) {
            var emptyOption_ = emptyOption && emptyOption[0];
            var unknownOption_ = unknownOption && unknownOption[0];
            if (emptyOption_ || unknownOption_) {
              while (current && (current === emptyOption_ || current === unknownOption_)) {
                current = current.nextSibling;
              }
            }
            return current;
          }
          function updateOptions() {
            var previousValue = options && selectCtrl.readValue();
            options = ngOptions.getOptions();
            var groupMap = {};
            var currentElement = selectElement[0].firstChild;
            if (providedEmptyOption) {
              selectElement.prepend(emptyOption);
            }
            currentElement = skipEmptyAndUnknownOptions(currentElement);
            options.items.forEach(function updateOption(option) {
              var group;
              var groupElement;
              var optionElement;
              if (option.group) {
                group = groupMap[option.group];
                if (!group) {
                  groupElement = addOrReuseElement(selectElement[0], currentElement, 'optgroup', optGroupTemplate);
                  currentElement = groupElement.nextSibling;
                  groupElement.label = option.group;
                  group = groupMap[option.group] = {
                    groupElement: groupElement,
                    currentOptionElement: groupElement.firstChild
                  };
                }
                optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                group.currentOptionElement = optionElement.nextSibling;
              } else {
                optionElement = addOrReuseElement(selectElement[0], currentElement, 'option', optionTemplate);
                updateOptionElement(option, optionElement);
                currentElement = optionElement.nextSibling;
              }
            });
            Object.keys(groupMap).forEach(function(key) {
              removeExcessElements(groupMap[key].currentOptionElement);
            });
            removeExcessElements(currentElement);
            ngModelCtrl.$render();
            if (!ngModelCtrl.$isEmpty(previousValue)) {
              var nextValue = selectCtrl.readValue();
              if (ngOptions.trackBy ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                ngModelCtrl.$setViewValue(nextValue);
                ngModelCtrl.$render();
              }
            }
          }
        }
      };
    }];
    var ngPluralizeDirective = ['$locale', '$interpolate', '$log', function($locale, $interpolate, $log) {
      var BRACE = /{}/g,
          IS_WHEN = /^when(Minus)?(.+)$/;
      return {link: function(scope, element, attr) {
          var numberExp = attr.count,
              whenExp = attr.$attr.when && element.attr(attr.$attr.when),
              offset = attr.offset || 0,
              whens = scope.$eval(whenExp) || {},
              whensExpFns = {},
              startSymbol = $interpolate.startSymbol(),
              endSymbol = $interpolate.endSymbol(),
              braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol,
              watchRemover = angular.noop,
              lastCount;
          forEach(attr, function(expression, attributeName) {
            var tmpMatch = IS_WHEN.exec(attributeName);
            if (tmpMatch) {
              var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
              whens[whenKey] = element.attr(attr.$attr[attributeName]);
            }
          });
          forEach(whens, function(expression, key) {
            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
          });
          scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
            var count = parseFloat(newVal);
            var countIsNaN = isNaN(count);
            if (!countIsNaN && !(count in whens)) {
              count = $locale.pluralCat(count - offset);
            }
            if ((count !== lastCount) && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
              watchRemover();
              var whenExpFn = whensExpFns[count];
              if (isUndefined(whenExpFn)) {
                if (newVal != null) {
                  $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp);
                }
                watchRemover = noop;
                updateElementText();
              } else {
                watchRemover = scope.$watch(whenExpFn, updateElementText);
              }
              lastCount = count;
            }
          });
          function updateElementText(newText) {
            element.text(newText || '');
          }
        }};
    }];
    var ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {
      var NG_REMOVED = '$$NG_REMOVED';
      var ngRepeatMinErr = minErr('ngRepeat');
      var updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
        scope[valueIdentifier] = value;
        if (keyIdentifier)
          scope[keyIdentifier] = key;
        scope.$index = index;
        scope.$first = (index === 0);
        scope.$last = (index === (arrayLength - 1));
        scope.$middle = !(scope.$first || scope.$last);
        scope.$odd = !(scope.$even = (index & 1) === 0);
      };
      var getBlockStart = function(block) {
        return block.clone[0];
      };
      var getBlockEnd = function(block) {
        return block.clone[block.clone.length - 1];
      };
      return {
        restrict: 'A',
        multiElement: true,
        transclude: 'element',
        priority: 1000,
        terminal: true,
        $$tlb: true,
        compile: function ngRepeatCompile($element, $attr) {
          var expression = $attr.ngRepeat;
          var ngRepeatEndComment = document.createComment(' end ngRepeat: ' + expression + ' ');
          var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
          if (!match) {
            throw ngRepeatMinErr('iexp', "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
          }
          var lhs = match[1];
          var rhs = match[2];
          var aliasAs = match[3];
          var trackByExp = match[4];
          match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
          if (!match) {
            throw ngRepeatMinErr('iidexp', "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
          }
          var valueIdentifier = match[3] || match[1];
          var keyIdentifier = match[2];
          if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
            throw ngRepeatMinErr('badident', "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
          }
          var trackByExpGetter,
              trackByIdExpFn,
              trackByIdArrayFn,
              trackByIdObjFn;
          var hashFnLocals = {$id: hashKey};
          if (trackByExp) {
            trackByExpGetter = $parse(trackByExp);
          } else {
            trackByIdArrayFn = function(key, value) {
              return hashKey(value);
            };
            trackByIdObjFn = function(key) {
              return key;
            };
          }
          return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
            if (trackByExpGetter) {
              trackByIdExpFn = function(key, value, index) {
                if (keyIdentifier)
                  hashFnLocals[keyIdentifier] = key;
                hashFnLocals[valueIdentifier] = value;
                hashFnLocals.$index = index;
                return trackByExpGetter($scope, hashFnLocals);
              };
            }
            var lastBlockMap = createMap();
            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
              var index,
                  length,
                  previousNode = $element[0],
                  nextNode,
                  nextBlockMap = createMap(),
                  collectionLength,
                  key,
                  value,
                  trackById,
                  trackByIdFn,
                  collectionKeys,
                  block,
                  nextBlockOrder,
                  elementsToRemove;
              if (aliasAs) {
                $scope[aliasAs] = collection;
              }
              if (isArrayLike(collection)) {
                collectionKeys = collection;
                trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
              } else {
                trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                collectionKeys = [];
                for (var itemKey in collection) {
                  if (collection.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                    collectionKeys.push(itemKey);
                  }
                }
              }
              collectionLength = collectionKeys.length;
              nextBlockOrder = new Array(collectionLength);
              for (index = 0; index < collectionLength; index++) {
                key = (collection === collectionKeys) ? index : collectionKeys[index];
                value = collection[key];
                trackById = trackByIdFn(key, value, index);
                if (lastBlockMap[trackById]) {
                  block = lastBlockMap[trackById];
                  delete lastBlockMap[trackById];
                  nextBlockMap[trackById] = block;
                  nextBlockOrder[index] = block;
                } else if (nextBlockMap[trackById]) {
                  forEach(nextBlockOrder, function(block) {
                    if (block && block.scope)
                      lastBlockMap[block.id] = block;
                  });
                  throw ngRepeatMinErr('dupes', "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                } else {
                  nextBlockOrder[index] = {
                    id: trackById,
                    scope: undefined,
                    clone: undefined
                  };
                  nextBlockMap[trackById] = true;
                }
              }
              for (var blockKey in lastBlockMap) {
                block = lastBlockMap[blockKey];
                elementsToRemove = getBlockNodes(block.clone);
                $animate.leave(elementsToRemove);
                if (elementsToRemove[0].parentNode) {
                  for (index = 0, length = elementsToRemove.length; index < length; index++) {
                    elementsToRemove[index][NG_REMOVED] = true;
                  }
                }
                block.scope.$destroy();
              }
              for (index = 0; index < collectionLength; index++) {
                key = (collection === collectionKeys) ? index : collectionKeys[index];
                value = collection[key];
                block = nextBlockOrder[index];
                if (block.scope) {
                  nextNode = previousNode;
                  do {
                    nextNode = nextNode.nextSibling;
                  } while (nextNode && nextNode[NG_REMOVED]);
                  if (getBlockStart(block) != nextNode) {
                    $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode));
                  }
                  previousNode = getBlockEnd(block);
                  updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                } else {
                  $transclude(function ngRepeatTransclude(clone, scope) {
                    block.scope = scope;
                    var endNode = ngRepeatEndComment.cloneNode(false);
                    clone[clone.length++] = endNode;
                    $animate.enter(clone, null, jqLite(previousNode));
                    previousNode = endNode;
                    block.clone = clone;
                    nextBlockMap[block.id] = block;
                    updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                  });
                }
              }
              lastBlockMap = nextBlockMap;
            });
          };
        }
      };
    }];
    var NG_HIDE_CLASS = 'ng-hide';
    var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
    var ngShowDirective = ['$animate', function($animate) {
      return {
        restrict: 'A',
        multiElement: true,
        link: function(scope, element, attr) {
          scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
            $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
          });
        }
      };
    }];
    var ngHideDirective = ['$animate', function($animate) {
      return {
        restrict: 'A',
        multiElement: true,
        link: function(scope, element, attr) {
          scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
            $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS});
          });
        }
      };
    }];
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
      scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
        if (oldStyles && (newStyles !== oldStyles)) {
          forEach(oldStyles, function(val, style) {
            element.css(style, '');
          });
        }
        if (newStyles)
          element.css(newStyles);
      }, true);
    });
    var ngSwitchDirective = ['$animate', function($animate) {
      return {
        require: 'ngSwitch',
        controller: ['$scope', function ngSwitchController() {
          this.cases = {};
        }],
        link: function(scope, element, attr, ngSwitchController) {
          var watchExpr = attr.ngSwitch || attr.on,
              selectedTranscludes = [],
              selectedElements = [],
              previousLeaveAnimations = [],
              selectedScopes = [];
          var spliceFactory = function(array, index) {
            return function() {
              array.splice(index, 1);
            };
          };
          scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
            var i,
                ii;
            for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
              $animate.cancel(previousLeaveAnimations[i]);
            }
            previousLeaveAnimations.length = 0;
            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
              var selected = getBlockNodes(selectedElements[i].clone);
              selectedScopes[i].$destroy();
              var promise = previousLeaveAnimations[i] = $animate.leave(selected);
              promise.then(spliceFactory(previousLeaveAnimations, i));
            }
            selectedElements.length = 0;
            selectedScopes.length = 0;
            if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {
              forEach(selectedTranscludes, function(selectedTransclude) {
                selectedTransclude.transclude(function(caseElement, selectedScope) {
                  selectedScopes.push(selectedScope);
                  var anchor = selectedTransclude.element;
                  caseElement[caseElement.length++] = document.createComment(' end ngSwitchWhen: ');
                  var block = {clone: caseElement};
                  selectedElements.push(block);
                  $animate.enter(caseElement, anchor.parent(), anchor);
                });
              });
            }
          });
        }
      };
    }];
    var ngSwitchWhenDirective = ngDirective({
      transclude: 'element',
      priority: 1200,
      require: '^ngSwitch',
      multiElement: true,
      link: function(scope, element, attrs, ctrl, $transclude) {
        ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);
        ctrl.cases['!' + attrs.ngSwitchWhen].push({
          transclude: $transclude,
          element: element
        });
      }
    });
    var ngSwitchDefaultDirective = ngDirective({
      transclude: 'element',
      priority: 1200,
      require: '^ngSwitch',
      multiElement: true,
      link: function(scope, element, attr, ctrl, $transclude) {
        ctrl.cases['?'] = (ctrl.cases['?'] || []);
        ctrl.cases['?'].push({
          transclude: $transclude,
          element: element
        });
      }
    });
    var ngTranscludeDirective = ngDirective({
      restrict: 'EAC',
      link: function($scope, $element, $attrs, controller, $transclude) {
        if (!$transclude) {
          throw minErr('ngTransclude')('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
        }
        $transclude(function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    });
    var scriptDirective = ['$templateCache', function($templateCache) {
      return {
        restrict: 'E',
        terminal: true,
        compile: function(element, attr) {
          if (attr.type == 'text/ng-template') {
            var templateUrl = attr.id,
                text = element[0].text;
            $templateCache.put(templateUrl, text);
          }
        }
      };
    }];
    var noopNgModelController = {
      $setViewValue: noop,
      $render: noop
    };
    var SelectController = ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
      var self = this,
          optionsMap = new HashMap();
      self.ngModelCtrl = noopNgModelController;
      self.unknownOption = jqLite(document.createElement('option'));
      self.renderUnknownOption = function(val) {
        var unknownVal = '? ' + hashKey(val) + ' ?';
        self.unknownOption.val(unknownVal);
        $element.prepend(self.unknownOption);
        $element.val(unknownVal);
      };
      $scope.$on('$destroy', function() {
        self.renderUnknownOption = noop;
      });
      self.removeUnknownOption = function() {
        if (self.unknownOption.parent())
          self.unknownOption.remove();
      };
      self.readValue = function readSingleValue() {
        self.removeUnknownOption();
        return $element.val();
      };
      self.writeValue = function writeSingleValue(value) {
        if (self.hasOption(value)) {
          self.removeUnknownOption();
          $element.val(value);
          if (value === '')
            self.emptyOption.prop('selected', true);
        } else {
          if (value == null && self.emptyOption) {
            self.removeUnknownOption();
            $element.val('');
          } else {
            self.renderUnknownOption(value);
          }
        }
      };
      self.addOption = function(value, element) {
        assertNotHasOwnProperty(value, '"option value"');
        if (value === '') {
          self.emptyOption = element;
        }
        var count = optionsMap.get(value) || 0;
        optionsMap.put(value, count + 1);
      };
      self.removeOption = function(value) {
        var count = optionsMap.get(value);
        if (count) {
          if (count === 1) {
            optionsMap.remove(value);
            if (value === '') {
              self.emptyOption = undefined;
            }
          } else {
            optionsMap.put(value, count - 1);
          }
        }
      };
      self.hasOption = function(value) {
        return !!optionsMap.get(value);
      };
    }];
    var selectDirective = function() {
      return {
        restrict: 'E',
        require: ['select', '?ngModel'],
        controller: SelectController,
        link: function(scope, element, attr, ctrls) {
          var ngModelCtrl = ctrls[1];
          if (!ngModelCtrl)
            return;
          var selectCtrl = ctrls[0];
          selectCtrl.ngModelCtrl = ngModelCtrl;
          ngModelCtrl.$render = function() {
            selectCtrl.writeValue(ngModelCtrl.$viewValue);
          };
          element.on('change', function() {
            scope.$apply(function() {
              ngModelCtrl.$setViewValue(selectCtrl.readValue());
            });
          });
          if (attr.multiple) {
            selectCtrl.readValue = function readMultipleValue() {
              var array = [];
              forEach(element.find('option'), function(option) {
                if (option.selected) {
                  array.push(option.value);
                }
              });
              return array;
            };
            selectCtrl.writeValue = function writeMultipleValue(value) {
              var items = new HashMap(value);
              forEach(element.find('option'), function(option) {
                option.selected = isDefined(items.get(option.value));
              });
            };
            var lastView,
                lastViewRef = NaN;
            scope.$watch(function selectMultipleWatch() {
              if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                lastView = shallowCopy(ngModelCtrl.$viewValue);
                ngModelCtrl.$render();
              }
              lastViewRef = ngModelCtrl.$viewValue;
            });
            ngModelCtrl.$isEmpty = function(value) {
              return !value || value.length === 0;
            };
          }
        }
      };
    };
    var optionDirective = ['$interpolate', function($interpolate) {
      function chromeHack(optionElement) {
        if (optionElement[0].hasAttribute('selected')) {
          optionElement[0].selected = true;
        }
      }
      return {
        restrict: 'E',
        priority: 100,
        compile: function(element, attr) {
          if (isUndefined(attr.value)) {
            var interpolateFn = $interpolate(element.text(), true);
            if (!interpolateFn) {
              attr.$set('value', element.text());
            }
          }
          return function(scope, element, attr) {
            var selectCtrlName = '$selectController',
                parent = element.parent(),
                selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
            if (selectCtrl && selectCtrl.ngModelCtrl) {
              if (interpolateFn) {
                scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
                  attr.$set('value', newVal);
                  if (oldVal !== newVal) {
                    selectCtrl.removeOption(oldVal);
                  }
                  selectCtrl.addOption(newVal, element);
                  selectCtrl.ngModelCtrl.$render();
                  chromeHack(element);
                });
              } else {
                selectCtrl.addOption(attr.value, element);
                selectCtrl.ngModelCtrl.$render();
                chromeHack(element);
              }
              element.on('$destroy', function() {
                selectCtrl.removeOption(attr.value);
                selectCtrl.ngModelCtrl.$render();
              });
            }
          };
        }
      };
    }];
    var styleDirective = valueFn({
      restrict: 'E',
      terminal: false
    });
    var requiredDirective = function() {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, elm, attr, ctrl) {
          if (!ctrl)
            return;
          attr.required = true;
          ctrl.$validators.required = function(modelValue, viewValue) {
            return !attr.required || !ctrl.$isEmpty(viewValue);
          };
          attr.$observe('required', function() {
            ctrl.$validate();
          });
        }
      };
    };
    var patternDirective = function() {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, elm, attr, ctrl) {
          if (!ctrl)
            return;
          var regexp,
              patternExp = attr.ngPattern || attr.pattern;
          attr.$observe('pattern', function(regex) {
            if (isString(regex) && regex.length > 0) {
              regex = new RegExp('^' + regex + '$');
            }
            if (regex && !regex.test) {
              throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
            }
            regexp = regex || undefined;
            ctrl.$validate();
          });
          ctrl.$validators.pattern = function(value) {
            return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value);
          };
        }
      };
    };
    var maxlengthDirective = function() {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, elm, attr, ctrl) {
          if (!ctrl)
            return;
          var maxlength = -1;
          attr.$observe('maxlength', function(value) {
            var intVal = toInt(value);
            maxlength = isNaN(intVal) ? -1 : intVal;
            ctrl.$validate();
          });
          ctrl.$validators.maxlength = function(modelValue, viewValue) {
            return (maxlength < 0) || ctrl.$isEmpty(viewValue) || (viewValue.length <= maxlength);
          };
        }
      };
    };
    var minlengthDirective = function() {
      return {
        restrict: 'A',
        require: '?ngModel',
        link: function(scope, elm, attr, ctrl) {
          if (!ctrl)
            return;
          var minlength = 0;
          attr.$observe('minlength', function(value) {
            minlength = toInt(value) || 0;
            ctrl.$validate();
          });
          ctrl.$validators.minlength = function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
          };
        }
      };
    };
    if (window.angular.bootstrap) {
      console.log('WARNING: Tried to load angular more than once.');
      return;
    }
    bindJQuery();
    publishExternalAPI(angular);
    jqLite(document).ready(function() {
      angularInit(document, bootstrap);
    });
  })(window, document);
  !window.angular.$$csp() && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
  (function(window, angular, undefined) {
    'use strict';
    var noop = angular.noop;
    var extend = angular.extend;
    var jqLite = angular.element;
    var forEach = angular.forEach;
    var isArray = angular.isArray;
    var isString = angular.isString;
    var isObject = angular.isObject;
    var isUndefined = angular.isUndefined;
    var isDefined = angular.isDefined;
    var isFunction = angular.isFunction;
    var isElement = angular.isElement;
    var ELEMENT_NODE = 1;
    var COMMENT_NODE = 8;
    var NG_ANIMATE_CLASSNAME = 'ng-animate';
    var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
    var isPromiseLike = function(p) {
      return p && p.then ? true : false;
    };
    function assertArg(arg, name, reason) {
      if (!arg) {
        throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
      }
      return arg;
    }
    function mergeClasses(a, b) {
      if (!a && !b)
        return '';
      if (!a)
        return b;
      if (!b)
        return a;
      if (isArray(a))
        a = a.join(' ');
      if (isArray(b))
        b = b.join(' ');
      return a + ' ' + b;
    }
    function packageStyles(options) {
      var styles = {};
      if (options && (options.to || options.from)) {
        styles.to = options.to;
        styles.from = options.from;
      }
      return styles;
    }
    function pendClasses(classes, fix, isPrefix) {
      var className = '';
      classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
      forEach(classes, function(klass, i) {
        if (klass && klass.length > 0) {
          className += (i > 0) ? ' ' : '';
          className += isPrefix ? fix + klass : klass + fix;
        }
      });
      return className;
    }
    function removeFromArray(arr, val) {
      var index = arr.indexOf(val);
      if (val >= 0) {
        arr.splice(index, 1);
      }
    }
    function stripCommentsFromElement(element) {
      if (element instanceof jqLite) {
        switch (element.length) {
          case 0:
            return [];
            break;
          case 1:
            if (element[0].nodeType === ELEMENT_NODE) {
              return element;
            }
            break;
          default:
            return jqLite(extractElementNode(element));
            break;
        }
      }
      if (element.nodeType === ELEMENT_NODE) {
        return jqLite(element);
      }
    }
    function extractElementNode(element) {
      if (!element[0])
        return element;
      for (var i = 0; i < element.length; i++) {
        var elm = element[i];
        if (elm.nodeType == ELEMENT_NODE) {
          return elm;
        }
      }
    }
    function $$addClass($$jqLite, element, className) {
      forEach(element, function(elm) {
        $$jqLite.addClass(elm, className);
      });
    }
    function $$removeClass($$jqLite, element, className) {
      forEach(element, function(elm) {
        $$jqLite.removeClass(elm, className);
      });
    }
    function applyAnimationClassesFactory($$jqLite) {
      return function(element, options) {
        if (options.addClass) {
          $$addClass($$jqLite, element, options.addClass);
          options.addClass = null;
        }
        if (options.removeClass) {
          $$removeClass($$jqLite, element, options.removeClass);
          options.removeClass = null;
        }
      };
    }
    function prepareAnimationOptions(options) {
      options = options || {};
      if (!options.$$prepared) {
        var domOperation = options.domOperation || noop;
        options.domOperation = function() {
          options.$$domOperationFired = true;
          domOperation();
          domOperation = noop;
        };
        options.$$prepared = true;
      }
      return options;
    }
    function applyAnimationStyles(element, options) {
      applyAnimationFromStyles(element, options);
      applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
      if (options.from) {
        element.css(options.from);
        options.from = null;
      }
    }
    function applyAnimationToStyles(element, options) {
      if (options.to) {
        element.css(options.to);
        options.to = null;
      }
    }
    function mergeAnimationOptions(element, target, newOptions) {
      var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
      var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
      var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
      extend(target, newOptions);
      if (classes.addClass) {
        target.addClass = classes.addClass;
      } else {
        target.addClass = null;
      }
      if (classes.removeClass) {
        target.removeClass = classes.removeClass;
      } else {
        target.removeClass = null;
      }
      return target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
      var ADD_CLASS = 1;
      var REMOVE_CLASS = -1;
      var flags = {};
      existing = splitClassesToLookup(existing);
      toAdd = splitClassesToLookup(toAdd);
      forEach(toAdd, function(value, key) {
        flags[key] = ADD_CLASS;
      });
      toRemove = splitClassesToLookup(toRemove);
      forEach(toRemove, function(value, key) {
        flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
      });
      var classes = {
        addClass: '',
        removeClass: ''
      };
      forEach(flags, function(val, klass) {
        var prop,
            allow;
        if (val === ADD_CLASS) {
          prop = 'addClass';
          allow = !existing[klass];
        } else if (val === REMOVE_CLASS) {
          prop = 'removeClass';
          allow = existing[klass];
        }
        if (allow) {
          if (classes[prop].length) {
            classes[prop] += ' ';
          }
          classes[prop] += klass;
        }
      });
      function splitClassesToLookup(classes) {
        if (isString(classes)) {
          classes = classes.split(' ');
        }
        var obj = {};
        forEach(classes, function(klass) {
          if (klass.length) {
            obj[klass] = true;
          }
        });
        return obj;
      }
      return classes;
    }
    function getDomNode(element) {
      return (element instanceof angular.element) ? element[0] : element;
    }
    var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
      var tickQueue = [];
      var cancelFn;
      function scheduler(tasks) {
        tickQueue.push([].concat(tasks));
        nextTick();
      }
      scheduler.waitUntilQuiet = function(fn) {
        if (cancelFn)
          cancelFn();
        cancelFn = $$rAF(function() {
          cancelFn = null;
          fn();
          nextTick();
        });
      };
      return scheduler;
      function nextTick() {
        if (!tickQueue.length)
          return;
        var updatedQueue = [];
        for (var i = 0; i < tickQueue.length; i++) {
          var innerQueue = tickQueue[i];
          runNextTask(innerQueue);
          if (innerQueue.length) {
            updatedQueue.push(innerQueue);
          }
        }
        tickQueue = updatedQueue;
        if (!cancelFn) {
          $$rAF(function() {
            if (!cancelFn)
              nextTick();
          });
        }
      }
      function runNextTask(tasks) {
        var nextTask = tasks.shift();
        nextTask();
      }
    }];
    var $$AnimateChildrenDirective = [function() {
      return function(scope, element, attrs) {
        var val = attrs.ngAnimateChildren;
        if (angular.isString(val) && val.length === 0) {
          element.data(NG_ANIMATE_CHILDREN_DATA, true);
        } else {
          attrs.$observe('ngAnimateChildren', function(value) {
            value = value === 'on' || value === 'true';
            element.data(NG_ANIMATE_CHILDREN_DATA, value);
          });
        }
      };
    }];
    var CSS_PREFIX = '',
        TRANSITION_PROP,
        TRANSITIONEND_EVENT,
        ANIMATION_PROP,
        ANIMATIONEND_EVENT;
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      CSS_PREFIX = '-webkit-';
      TRANSITION_PROP = 'WebkitTransition';
      TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
    } else {
      TRANSITION_PROP = 'transition';
      TRANSITIONEND_EVENT = 'transitionend';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      CSS_PREFIX = '-webkit-';
      ANIMATION_PROP = 'WebkitAnimation';
      ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
    } else {
      ANIMATION_PROP = 'animation';
      ANIMATIONEND_EVENT = 'animationend';
    }
    var DURATION_KEY = 'Duration';
    var PROPERTY_KEY = 'Property';
    var DELAY_KEY = 'Delay';
    var TIMING_KEY = 'TimingFunction';
    var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
    var ANIMATION_PLAYSTATE_KEY = 'PlayState';
    var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
    var CLOSING_TIME_BUFFER = 1.5;
    var ONE_SECOND = 1000;
    var BASE_TEN = 10;
    var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
    var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
    var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
    var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
    var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
    var DETECT_CSS_PROPERTIES = {
      transitionDuration: TRANSITION_DURATION_PROP,
      transitionDelay: TRANSITION_DELAY_PROP,
      transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
      animationDuration: ANIMATION_DURATION_PROP,
      animationDelay: ANIMATION_DELAY_PROP,
      animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    };
    var DETECT_STAGGER_CSS_PROPERTIES = {
      transitionDuration: TRANSITION_DURATION_PROP,
      transitionDelay: TRANSITION_DELAY_PROP,
      animationDuration: ANIMATION_DURATION_PROP,
      animationDelay: ANIMATION_DELAY_PROP
    };
    function computeCssStyles($window, element, properties) {
      var styles = Object.create(null);
      var detectedStyles = $window.getComputedStyle(element) || {};
      forEach(properties, function(formalStyleName, actualStyleName) {
        var val = detectedStyles[formalStyleName];
        if (val) {
          var c = val.charAt(0);
          if (c === '-' || c === '+' || c >= 0) {
            val = parseMaxTime(val);
          }
          if (val === 0) {
            val = null;
          }
          styles[actualStyleName] = val;
        }
      });
      return styles;
    }
    function parseMaxTime(str) {
      var maxValue = 0;
      var values = str.split(/\s*,\s*/);
      forEach(values, function(value) {
        if (value.charAt(value.length - 1) == 's') {
          value = value.substring(0, value.length - 1);
        }
        value = parseFloat(value) || 0;
        maxValue = maxValue ? Math.max(value, maxValue) : value;
      });
      return maxValue;
    }
    function truthyTimingValue(val) {
      return val === 0 || val != null;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
      var style = TRANSITION_PROP;
      var value = duration + 's';
      if (applyOnlyDuration) {
        style += DURATION_KEY;
      } else {
        value += ' linear all';
      }
      return [style, value];
    }
    function getCssKeyframeDurationStyle(duration) {
      return [ANIMATION_DURATION_PROP, duration + 's'];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
      var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
      return [prop, delay + 's'];
    }
    function blockTransitions(node, duration) {
      var value = duration ? '-' + duration + 's' : '';
      applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
      return [TRANSITION_DELAY_PROP, value];
    }
    function blockKeyframeAnimations(node, applyBlock) {
      var value = applyBlock ? 'paused' : '';
      var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
      applyInlineStyle(node, [key, value]);
      return [key, value];
    }
    function applyInlineStyle(node, styleTuple) {
      var prop = styleTuple[0];
      var value = styleTuple[1];
      node.style[prop] = value;
    }
    function createLocalCacheLookup() {
      var cache = Object.create(null);
      return {
        flush: function() {
          cache = Object.create(null);
        },
        count: function(key) {
          var entry = cache[key];
          return entry ? entry.total : 0;
        },
        get: function(key) {
          var entry = cache[key];
          return entry && entry.value;
        },
        put: function(key, value) {
          if (!cache[key]) {
            cache[key] = {
              total: 1,
              value: value
            };
          } else {
            cache[key].total++;
          }
        }
      };
    }
    var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
      var gcsLookup = createLocalCacheLookup();
      var gcsStaggerLookup = createLocalCacheLookup();
      this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout', '$document', '$sniffer', '$$rAFScheduler', function($window, $$jqLite, $$AnimateRunner, $timeout, $document, $sniffer, $$rAFScheduler) {
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        var parentCounter = 0;
        function gcsHashFn(node, extraClasses) {
          var KEY = "$$ngAnimateParentKey";
          var parentNode = node.parentNode;
          var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
          return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
        }
        function computeCachedCssStyles(node, className, cacheKey, properties) {
          var timings = gcsLookup.get(cacheKey);
          if (!timings) {
            timings = computeCssStyles($window, node, properties);
            if (timings.animationIterationCount === 'infinite') {
              timings.animationIterationCount = 1;
            }
          }
          gcsLookup.put(cacheKey, timings);
          return timings;
        }
        function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
          var stagger;
          if (gcsLookup.count(cacheKey) > 0) {
            stagger = gcsStaggerLookup.get(cacheKey);
            if (!stagger) {
              var staggerClassName = pendClasses(className, '-stagger');
              $$jqLite.addClass(node, staggerClassName);
              stagger = computeCssStyles($window, node, properties);
              stagger.animationDuration = Math.max(stagger.animationDuration, 0);
              stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
              $$jqLite.removeClass(node, staggerClassName);
              gcsStaggerLookup.put(cacheKey, stagger);
            }
          }
          return stagger || {};
        }
        var bod = getDomNode($document).body;
        var rafWaitQueue = [];
        function waitUntilQuiet(callback) {
          rafWaitQueue.push(callback);
          $$rAFScheduler.waitUntilQuiet(function() {
            gcsLookup.flush();
            gcsStaggerLookup.flush();
            var width = bod.offsetWidth + 1;
            for (var i = 0; i < rafWaitQueue.length; i++) {
              rafWaitQueue[i](width);
            }
            rafWaitQueue.length = 0;
          });
        }
        return init;
        function computeTimings(node, className, cacheKey) {
          var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
          var aD = timings.animationDelay;
          var tD = timings.transitionDelay;
          timings.maxDelay = aD && tD ? Math.max(aD, tD) : (aD || tD);
          timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
          return timings;
        }
        function init(element, options) {
          var node = getDomNode(element);
          if (!node || !node.parentNode) {
            return closeAndReturnNoopAnimator();
          }
          options = prepareAnimationOptions(options);
          var temporaryStyles = [];
          var classes = element.attr('class');
          var styles = packageStyles(options);
          var animationClosed;
          var animationPaused;
          var animationCompleted;
          var runner;
          var runnerHost;
          var maxDelay;
          var maxDelayTime;
          var maxDuration;
          var maxDurationTime;
          if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
            return closeAndReturnNoopAnimator();
          }
          var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
          var isStructural = method && options.structural;
          var structuralClassName = '';
          var addRemoveClassName = '';
          if (isStructural) {
            structuralClassName = pendClasses(method, 'ng-', true);
          } else if (method) {
            structuralClassName = method;
          }
          if (options.addClass) {
            addRemoveClassName += pendClasses(options.addClass, '-add');
          }
          if (options.removeClass) {
            if (addRemoveClassName.length) {
              addRemoveClassName += ' ';
            }
            addRemoveClassName += pendClasses(options.removeClass, '-remove');
          }
          if (options.applyClassesEarly && addRemoveClassName.length) {
            applyAnimationClasses(element, options);
            addRemoveClassName = '';
          }
          var setupClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
          var fullClassName = classes + ' ' + setupClasses;
          var activeClasses = pendClasses(setupClasses, '-active');
          var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
          var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
          if (!containsKeyframeAnimation && !hasToStyles && !setupClasses) {
            return closeAndReturnNoopAnimator();
          }
          var cacheKey,
              stagger;
          if (options.stagger > 0) {
            var staggerVal = parseFloat(options.stagger);
            stagger = {
              transitionDelay: staggerVal,
              animationDelay: staggerVal,
              transitionDuration: 0,
              animationDuration: 0
            };
          } else {
            cacheKey = gcsHashFn(node, fullClassName);
            stagger = computeCachedCssStaggerStyles(node, setupClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
          }
          $$jqLite.addClass(element, setupClasses);
          var applyOnlyDuration;
          if (options.transitionStyle) {
            var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
            applyInlineStyle(node, transitionStyle);
            temporaryStyles.push(transitionStyle);
          }
          if (options.duration >= 0) {
            applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
            var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
            applyInlineStyle(node, durationStyle);
            temporaryStyles.push(durationStyle);
          }
          if (options.keyframeStyle) {
            var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
            applyInlineStyle(node, keyframeStyle);
            temporaryStyles.push(keyframeStyle);
          }
          var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
          var isFirst = itemIndex === 0;
          if (isFirst) {
            blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
          }
          var timings = computeTimings(node, fullClassName, cacheKey);
          var relativeDelay = timings.maxDelay;
          maxDelay = Math.max(relativeDelay, 0);
          maxDuration = timings.maxDuration;
          var flags = {};
          flags.hasTransitions = timings.transitionDuration > 0;
          flags.hasAnimations = timings.animationDuration > 0;
          flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
          flags.applyTransitionDuration = hasToStyles && ((flags.hasTransitions && !flags.hasTransitionAll) || (flags.hasAnimations && !flags.hasTransitions));
          flags.applyAnimationDuration = options.duration && flags.hasAnimations;
          flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
          flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
          flags.recalculateTimingStyles = addRemoveClassName.length > 0;
          if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
            maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
            if (flags.applyTransitionDuration) {
              flags.hasTransitions = true;
              timings.transitionDuration = maxDuration;
              applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
              temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
            }
            if (flags.applyAnimationDuration) {
              flags.hasAnimations = true;
              timings.animationDuration = maxDuration;
              temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
            }
          }
          if (maxDuration === 0 && !flags.recalculateTimingStyles) {
            return closeAndReturnNoopAnimator();
          }
          if (options.duration == null && timings.transitionDuration > 0) {
            flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
          }
          maxDelayTime = maxDelay * ONE_SECOND;
          maxDurationTime = maxDuration * ONE_SECOND;
          if (!options.skipBlocking) {
            flags.blockTransition = timings.transitionDuration > 0;
            flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
          }
          applyAnimationFromStyles(element, options);
          if (!flags.blockTransition) {
            blockTransitions(node, false);
          }
          applyBlocking(maxDuration);
          return {
            $$willAnimate: true,
            end: endFn,
            start: function() {
              if (animationClosed)
                return;
              runnerHost = {
                end: endFn,
                cancel: cancelFn,
                resume: null,
                pause: null
              };
              runner = new $$AnimateRunner(runnerHost);
              waitUntilQuiet(start);
              return runner;
            }
          };
          function endFn() {
            close();
          }
          function cancelFn() {
            close(true);
          }
          function close(rejected) {
            if (animationClosed || (animationCompleted && animationPaused))
              return;
            animationClosed = true;
            animationPaused = false;
            $$jqLite.removeClass(element, setupClasses);
            $$jqLite.removeClass(element, activeClasses);
            blockKeyframeAnimations(node, false);
            blockTransitions(node, false);
            forEach(temporaryStyles, function(entry) {
              node.style[entry[0]] = '';
            });
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            if (options.onDone) {
              options.onDone();
            }
            if (runner) {
              runner.complete(!rejected);
            }
          }
          function applyBlocking(duration) {
            if (flags.blockTransition) {
              blockTransitions(node, duration);
            }
            if (flags.blockKeyframeAnimation) {
              blockKeyframeAnimations(node, !!duration);
            }
          }
          function closeAndReturnNoopAnimator() {
            runner = new $$AnimateRunner({
              end: endFn,
              cancel: cancelFn
            });
            close();
            return {
              $$willAnimate: false,
              start: function() {
                return runner;
              },
              end: endFn
            };
          }
          function start() {
            if (animationClosed)
              return;
            if (!node.parentNode) {
              close();
              return;
            }
            var startTime,
                events = [];
            var playPause = function(playAnimation) {
              if (!animationCompleted) {
                animationPaused = !playAnimation;
                if (timings.animationDuration) {
                  var value = blockKeyframeAnimations(node, animationPaused);
                  animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                }
              } else if (animationPaused && playAnimation) {
                animationPaused = false;
                close();
              }
            };
            var maxStagger = itemIndex > 0 && ((timings.transitionDuration && stagger.transitionDuration === 0) || (timings.animationDuration && stagger.animationDuration === 0)) && Math.max(stagger.animationDelay, stagger.transitionDelay);
            if (maxStagger) {
              $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
            } else {
              triggerAnimationStart();
            }
            runnerHost.resume = function() {
              playPause(true);
            };
            runnerHost.pause = function() {
              playPause(false);
            };
            function triggerAnimationStart() {
              if (animationClosed)
                return;
              applyBlocking(false);
              forEach(temporaryStyles, function(entry) {
                var key = entry[0];
                var value = entry[1];
                node.style[key] = value;
              });
              applyAnimationClasses(element, options);
              $$jqLite.addClass(element, activeClasses);
              if (flags.recalculateTimingStyles) {
                fullClassName = node.className + ' ' + setupClasses;
                cacheKey = gcsHashFn(node, fullClassName);
                timings = computeTimings(node, fullClassName, cacheKey);
                relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0);
                maxDuration = timings.maxDuration;
                if (maxDuration === 0) {
                  close();
                  return;
                }
                flags.hasTransitions = timings.transitionDuration > 0;
                flags.hasAnimations = timings.animationDuration > 0;
              }
              if (flags.applyTransitionDelay || flags.applyAnimationDelay) {
                relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                maxDelay = Math.max(relativeDelay, 0);
                var delayStyle;
                if (flags.applyTransitionDelay) {
                  timings.transitionDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
                if (flags.applyAnimationDelay) {
                  timings.animationDelay = relativeDelay;
                  delayStyle = getCssDelayStyle(relativeDelay, true);
                  temporaryStyles.push(delayStyle);
                  node.style[delayStyle[0]] = delayStyle[1];
                }
              }
              maxDelayTime = maxDelay * ONE_SECOND;
              maxDurationTime = maxDuration * ONE_SECOND;
              if (options.easing) {
                var easeProp,
                    easeVal = options.easing;
                if (flags.hasTransitions) {
                  easeProp = TRANSITION_PROP + TIMING_KEY;
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
                if (flags.hasAnimations) {
                  easeProp = ANIMATION_PROP + TIMING_KEY;
                  temporaryStyles.push([easeProp, easeVal]);
                  node.style[easeProp] = easeVal;
                }
              }
              if (timings.transitionDuration) {
                events.push(TRANSITIONEND_EVENT);
              }
              if (timings.animationDuration) {
                events.push(ANIMATIONEND_EVENT);
              }
              startTime = Date.now();
              element.on(events.join(' '), onAnimationProgress);
              $timeout(onAnimationExpired, maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime);
              applyAnimationToStyles(element, options);
            }
            function onAnimationExpired() {
              close();
            }
            function onAnimationProgress(event) {
              event.stopPropagation();
              var ev = event.originalEvent || event;
              var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
              var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
              if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                animationCompleted = true;
                close();
              }
            }
          }
        }
      }];
    }];
    var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
      $$animationProvider.drivers.push('$$animateCssDriver');
      var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
      var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
      var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
      var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
      this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$document', '$sniffer', function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $document, $sniffer) {
        if (!$sniffer.animations && !$sniffer.transitions)
          return noop;
        var bodyNode = getDomNode($document).body;
        var rootNode = getDomNode($rootElement);
        var rootBodyElement = jqLite(bodyNode.parentNode === rootNode ? bodyNode : rootNode);
        return function initDriverFn(animationDetails) {
          return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
        };
        function filterCssClasses(classes) {
          return classes.replace(/\bng-\S+\b/g, '');
        }
        function getUniqueValues(a, b) {
          if (isString(a))
            a = a.split(' ');
          if (isString(b))
            b = b.split(' ');
          return a.filter(function(val) {
            return b.indexOf(val) === -1;
          }).join(' ');
        }
        function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
          var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
          var startingClasses = filterCssClasses(getClassVal(clone));
          outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
          inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
          clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
          rootBodyElement.append(clone);
          var animatorIn,
              animatorOut = prepareOutAnimation();
          if (!animatorOut) {
            animatorIn = prepareInAnimation();
            if (!animatorIn) {
              return end();
            }
          }
          var startingAnimator = animatorOut || animatorIn;
          return {start: function() {
              var runner;
              var currentAnimation = startingAnimator.start();
              currentAnimation.done(function() {
                currentAnimation = null;
                if (!animatorIn) {
                  animatorIn = prepareInAnimation();
                  if (animatorIn) {
                    currentAnimation = animatorIn.start();
                    currentAnimation.done(function() {
                      currentAnimation = null;
                      end();
                      runner.complete();
                    });
                    return currentAnimation;
                  }
                }
                end();
                runner.complete();
              });
              runner = new $$AnimateRunner({
                end: endFn,
                cancel: endFn
              });
              return runner;
              function endFn() {
                if (currentAnimation) {
                  currentAnimation.end();
                }
              }
            }};
          function calculateAnchorStyles(anchor) {
            var styles = {};
            var coords = getDomNode(anchor).getBoundingClientRect();
            forEach(['width', 'height', 'top', 'left'], function(key) {
              var value = coords[key];
              switch (key) {
                case 'top':
                  value += bodyNode.scrollTop;
                  break;
                case 'left':
                  value += bodyNode.scrollLeft;
                  break;
              }
              styles[key] = Math.floor(value) + 'px';
            });
            return styles;
          }
          function prepareOutAnimation() {
            var animator = $animateCss(clone, {
              addClass: NG_OUT_ANCHOR_CLASS_NAME,
              delay: true,
              from: calculateAnchorStyles(outAnchor)
            });
            return animator.$$willAnimate ? animator : null;
          }
          function getClassVal(element) {
            return element.attr('class') || '';
          }
          function prepareInAnimation() {
            var endingClasses = filterCssClasses(getClassVal(inAnchor));
            var toAdd = getUniqueValues(endingClasses, startingClasses);
            var toRemove = getUniqueValues(startingClasses, endingClasses);
            var animator = $animateCss(clone, {
              to: calculateAnchorStyles(inAnchor),
              addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
              removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
              delay: true
            });
            return animator.$$willAnimate ? animator : null;
          }
          function end() {
            clone.remove();
            outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
            inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
          }
        }
        function prepareFromToAnchorAnimation(from, to, classes, anchors) {
          var fromAnimation = prepareRegularAnimation(from);
          var toAnimation = prepareRegularAnimation(to);
          var anchorAnimations = [];
          forEach(anchors, function(anchor) {
            var outElement = anchor['out'];
            var inElement = anchor['in'];
            var animator = prepareAnchoredAnimation(classes, outElement, inElement);
            if (animator) {
              anchorAnimations.push(animator);
            }
          });
          if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
            return;
          return {start: function() {
              var animationRunners = [];
              if (fromAnimation) {
                animationRunners.push(fromAnimation.start());
              }
              if (toAnimation) {
                animationRunners.push(toAnimation.start());
              }
              forEach(anchorAnimations, function(animation) {
                animationRunners.push(animation.start());
              });
              var runner = new $$AnimateRunner({
                end: endFn,
                cancel: endFn
              });
              $$AnimateRunner.all(animationRunners, function(status) {
                runner.complete(status);
              });
              return runner;
              function endFn() {
                forEach(animationRunners, function(runner) {
                  runner.end();
                });
              }
            }};
        }
        function prepareRegularAnimation(animationDetails) {
          var element = animationDetails.element;
          var options = animationDetails.options || {};
          if (animationDetails.structural) {
            options.structural = options.applyClassesEarly = true;
            options.event = animationDetails.event;
            if (options.event === 'leave') {
              options.onDone = options.domOperation;
            }
          } else {
            options.event = null;
          }
          var animator = $animateCss(element, options);
          return animator.$$willAnimate ? animator : null;
        }
      }];
    }];
    var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
      this.$get = ['$injector', '$$AnimateRunner', '$$rAFMutex', '$$jqLite', function($injector, $$AnimateRunner, $$rAFMutex, $$jqLite) {
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        return function(element, event, classes, options) {
          if (arguments.length === 3 && isObject(classes)) {
            options = classes;
            classes = null;
          }
          options = prepareAnimationOptions(options);
          if (!classes) {
            classes = element.attr('class') || '';
            if (options.addClass) {
              classes += ' ' + options.addClass;
            }
            if (options.removeClass) {
              classes += ' ' + options.removeClass;
            }
          }
          var classesToAdd = options.addClass;
          var classesToRemove = options.removeClass;
          var animations = lookupAnimations(classes);
          var before,
              after;
          if (animations.length) {
            var afterFn,
                beforeFn;
            if (event == 'leave') {
              beforeFn = 'leave';
              afterFn = 'afterLeave';
            } else {
              beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
              afterFn = event;
            }
            if (event !== 'enter' && event !== 'move') {
              before = packageAnimations(element, event, options, animations, beforeFn);
            }
            after = packageAnimations(element, event, options, animations, afterFn);
          }
          if (!before && !after)
            return;
          function applyOptions() {
            options.domOperation();
            applyAnimationClasses(element, options);
          }
          return {start: function() {
              var closeActiveAnimations;
              var chain = [];
              if (before) {
                chain.push(function(fn) {
                  closeActiveAnimations = before(fn);
                });
              }
              if (chain.length) {
                chain.push(function(fn) {
                  applyOptions();
                  fn(true);
                });
              } else {
                applyOptions();
              }
              if (after) {
                chain.push(function(fn) {
                  closeActiveAnimations = after(fn);
                });
              }
              var animationClosed = false;
              var runner = new $$AnimateRunner({
                end: function() {
                  endAnimations();
                },
                cancel: function() {
                  endAnimations(true);
                }
              });
              $$AnimateRunner.chain(chain, onComplete);
              return runner;
              function onComplete(success) {
                animationClosed = true;
                applyOptions();
                applyAnimationStyles(element, options);
                runner.complete(success);
              }
              function endAnimations(cancelled) {
                if (!animationClosed) {
                  (closeActiveAnimations || noop)(cancelled);
                  onComplete(cancelled);
                }
              }
            }};
          function executeAnimationFn(fn, element, event, options, onDone) {
            var args;
            switch (event) {
              case 'animate':
                args = [element, options.from, options.to, onDone];
                break;
              case 'setClass':
                args = [element, classesToAdd, classesToRemove, onDone];
                break;
              case 'addClass':
                args = [element, classesToAdd, onDone];
                break;
              case 'removeClass':
                args = [element, classesToRemove, onDone];
                break;
              default:
                args = [element, onDone];
                break;
            }
            args.push(options);
            var value = fn.apply(fn, args);
            if (value) {
              if (isFunction(value.start)) {
                value = value.start();
              }
              if (value instanceof $$AnimateRunner) {
                value.done(onDone);
              } else if (isFunction(value)) {
                return value;
              }
            }
            return noop;
          }
          function groupEventedAnimations(element, event, options, animations, fnName) {
            var operations = [];
            forEach(animations, function(ani) {
              var animation = ani[fnName];
              if (!animation)
                return;
              operations.push(function() {
                var runner;
                var endProgressCb;
                var resolved = false;
                var onAnimationComplete = function(rejected) {
                  if (!resolved) {
                    resolved = true;
                    (endProgressCb || noop)(rejected);
                    runner.complete(!rejected);
                  }
                };
                runner = new $$AnimateRunner({
                  end: function() {
                    onAnimationComplete();
                  },
                  cancel: function() {
                    onAnimationComplete(true);
                  }
                });
                endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                  var cancelled = result === false;
                  onAnimationComplete(cancelled);
                });
                return runner;
              });
            });
            return operations;
          }
          function packageAnimations(element, event, options, animations, fnName) {
            var operations = groupEventedAnimations(element, event, options, animations, fnName);
            if (operations.length === 0) {
              var a,
                  b;
              if (fnName === 'beforeSetClass') {
                a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
              } else if (fnName === 'setClass') {
                a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
              }
              if (a) {
                operations = operations.concat(a);
              }
              if (b) {
                operations = operations.concat(b);
              }
            }
            if (operations.length === 0)
              return;
            return function startAnimation(callback) {
              var runners = [];
              if (operations.length) {
                forEach(operations, function(animateFn) {
                  runners.push(animateFn());
                });
              }
              runners.length ? $$AnimateRunner.all(runners, callback) : callback();
              return function endFn(reject) {
                forEach(runners, function(runner) {
                  reject ? runner.cancel() : runner.end();
                });
              };
            };
          }
        };
        function lookupAnimations(classes) {
          classes = isArray(classes) ? classes : classes.split(' ');
          var matches = [],
              flagMap = {};
          for (var i = 0; i < classes.length; i++) {
            var klass = classes[i],
                animationFactory = $animateProvider.$$registeredAnimations[klass];
            if (animationFactory && !flagMap[klass]) {
              matches.push($injector.get(animationFactory));
              flagMap[klass] = true;
            }
          }
          return matches;
        }
      }];
    }];
    var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
      $$animationProvider.drivers.push('$$animateJsDriver');
      this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
        return function initDriverFn(animationDetails) {
          if (animationDetails.from && animationDetails.to) {
            var fromAnimation = prepareAnimation(animationDetails.from);
            var toAnimation = prepareAnimation(animationDetails.to);
            if (!fromAnimation && !toAnimation)
              return;
            return {start: function() {
                var animationRunners = [];
                if (fromAnimation) {
                  animationRunners.push(fromAnimation.start());
                }
                if (toAnimation) {
                  animationRunners.push(toAnimation.start());
                }
                $$AnimateRunner.all(animationRunners, done);
                var runner = new $$AnimateRunner({
                  end: endFnFactory(),
                  cancel: endFnFactory()
                });
                return runner;
                function endFnFactory() {
                  return function() {
                    forEach(animationRunners, function(runner) {
                      runner.end();
                    });
                  };
                }
                function done(status) {
                  runner.complete(status);
                }
              }};
          } else {
            return prepareAnimation(animationDetails);
          }
        };
        function prepareAnimation(animationDetails) {
          var element = animationDetails.element;
          var event = animationDetails.event;
          var options = animationDetails.options;
          var classes = animationDetails.classes;
          return $$animateJs(element, event, classes, options);
        }
      }];
    }];
    var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
    var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
    var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
      var PRE_DIGEST_STATE = 1;
      var RUNNING_STATE = 2;
      var rules = this.rules = {
        skip: [],
        cancel: [],
        join: []
      };
      function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
        return rules[ruleType].some(function(fn) {
          return fn(element, currentAnimation, previousAnimation);
        });
      }
      function hasAnimationClasses(options, and) {
        options = options || {};
        var a = (options.addClass || '').length > 0;
        var b = (options.removeClass || '').length > 0;
        return and ? a && b : a || b;
      }
      rules.join.push(function(element, newAnimation, currentAnimation) {
        return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
      });
      rules.skip.push(function(element, newAnimation, currentAnimation) {
        return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
      });
      rules.skip.push(function(element, newAnimation, currentAnimation) {
        return currentAnimation.event == 'leave' && newAnimation.structural;
      });
      rules.skip.push(function(element, newAnimation, currentAnimation) {
        return currentAnimation.structural && !newAnimation.structural;
      });
      rules.cancel.push(function(element, newAnimation, currentAnimation) {
        return currentAnimation.structural && newAnimation.structural;
      });
      rules.cancel.push(function(element, newAnimation, currentAnimation) {
        return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
      });
      rules.cancel.push(function(element, newAnimation, currentAnimation) {
        var nO = newAnimation.options;
        var cO = currentAnimation.options;
        return (nO.addClass && nO.addClass === cO.removeClass) || (nO.removeClass && nO.removeClass === cO.addClass);
      });
      this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap', '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite) {
        var activeAnimationsLookup = new $$HashMap();
        var disabledElementsLookup = new $$HashMap();
        var animationsEnabled = null;
        var deregisterWatch = $rootScope.$watch(function() {
          return $templateRequest.totalPendingRequests === 0;
        }, function(isEmpty) {
          if (!isEmpty)
            return;
          deregisterWatch();
          $rootScope.$$postDigest(function() {
            $rootScope.$$postDigest(function() {
              if (animationsEnabled === null) {
                animationsEnabled = true;
              }
            });
          });
        });
        var bodyElement = jqLite($document[0].body);
        var callbackRegistry = {};
        var classNameFilter = $animateProvider.classNameFilter();
        var isAnimatableClassName = !classNameFilter ? function() {
          return true;
        } : function(className) {
          return classNameFilter.test(className);
        };
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        function normalizeAnimationOptions(element, options) {
          return mergeAnimationOptions(element, options, {});
        }
        function findCallbacks(element, event) {
          var targetNode = getDomNode(element);
          var matches = [];
          var entries = callbackRegistry[event];
          if (entries) {
            forEach(entries, function(entry) {
              if (entry.node.contains(targetNode)) {
                matches.push(entry.callback);
              }
            });
          }
          return matches;
        }
        function triggerCallback(event, element, phase, data) {
          $$rAF(function() {
            forEach(findCallbacks(element, event), function(callback) {
              callback(element, phase, data);
            });
          });
        }
        return {
          on: function(event, container, callback) {
            var node = extractElementNode(container);
            callbackRegistry[event] = callbackRegistry[event] || [];
            callbackRegistry[event].push({
              node: node,
              callback: callback
            });
          },
          off: function(event, container, callback) {
            var entries = callbackRegistry[event];
            if (!entries)
              return;
            callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
            function filterFromRegistry(list, matchContainer, matchCallback) {
              var containerNode = extractElementNode(matchContainer);
              return list.filter(function(entry) {
                var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                return !isMatch;
              });
            }
          },
          pin: function(element, parentElement) {
            assertArg(isElement(element), 'element', 'not an element');
            assertArg(isElement(parentElement), 'parentElement', 'not an element');
            element.data(NG_ANIMATE_PIN_DATA, parentElement);
          },
          push: function(element, event, options, domOperation) {
            options = options || {};
            options.domOperation = domOperation;
            return queueAnimation(element, event, options);
          },
          enabled: function(element, bool) {
            var argCount = arguments.length;
            if (argCount === 0) {
              bool = !!animationsEnabled;
            } else {
              var hasElement = isElement(element);
              if (!hasElement) {
                bool = animationsEnabled = !!element;
              } else {
                var node = getDomNode(element);
                var recordExists = disabledElementsLookup.get(node);
                if (argCount === 1) {
                  bool = !recordExists;
                } else {
                  bool = !!bool;
                  if (!bool) {
                    disabledElementsLookup.put(node, true);
                  } else if (recordExists) {
                    disabledElementsLookup.remove(node);
                  }
                }
              }
            }
            return bool;
          }
        };
        function queueAnimation(element, event, options) {
          var node,
              parent;
          element = stripCommentsFromElement(element);
          if (element) {
            node = getDomNode(element);
            parent = element.parent();
          }
          options = prepareAnimationOptions(options);
          var runner = new $$AnimateRunner();
          if (!node) {
            close();
            return runner;
          }
          if (isArray(options.addClass)) {
            options.addClass = options.addClass.join(' ');
          }
          if (isArray(options.removeClass)) {
            options.removeClass = options.removeClass.join(' ');
          }
          if (options.from && !isObject(options.from)) {
            options.from = null;
          }
          if (options.to && !isObject(options.to)) {
            options.to = null;
          }
          var className = [node.className, options.addClass, options.removeClass].join(' ');
          if (!isAnimatableClassName(className)) {
            close();
            return runner;
          }
          var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
          var skipAnimations = !animationsEnabled || disabledElementsLookup.get(node);
          var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
          var hasExistingAnimation = !!existingAnimation.state;
          if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
            skipAnimations = !areAnimationsAllowed(element, parent, event);
          }
          if (skipAnimations) {
            close();
            return runner;
          }
          if (isStructural) {
            closeChildAnimations(element);
          }
          var newAnimation = {
            structural: isStructural,
            element: element,
            event: event,
            close: close,
            options: options,
            runner: runner
          };
          if (hasExistingAnimation) {
            var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
            if (skipAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                close();
                return runner;
              } else {
                mergeAnimationOptions(element, existingAnimation.options, options);
                return existingAnimation.runner;
              }
            }
            var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
            if (cancelAnimationFlag) {
              if (existingAnimation.state === RUNNING_STATE) {
                existingAnimation.runner.end();
              } else if (existingAnimation.structural) {
                existingAnimation.close();
              } else {
                mergeAnimationOptions(element, newAnimation.options, existingAnimation.options);
              }
            } else {
              var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
              if (joinAnimationFlag) {
                if (existingAnimation.state === RUNNING_STATE) {
                  normalizeAnimationOptions(element, options);
                } else {
                  event = newAnimation.event = existingAnimation.event;
                  options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options);
                  return runner;
                }
              }
            }
          } else {
            normalizeAnimationOptions(element, options);
          }
          var isValidAnimation = newAnimation.structural;
          if (!isValidAnimation) {
            isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0) || hasAnimationClasses(newAnimation.options);
          }
          if (!isValidAnimation) {
            close();
            clearElementAnimationState(element);
            return runner;
          }
          if (isStructural) {
            closeParentClassBasedAnimations(parent);
          }
          var counter = (existingAnimation.counter || 0) + 1;
          newAnimation.counter = counter;
          markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
          $rootScope.$$postDigest(function() {
            var animationDetails = activeAnimationsLookup.get(node);
            var animationCancelled = !animationDetails;
            animationDetails = animationDetails || {};
            var parentElement = element.parent() || [];
            var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails.options));
            if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
              if (animationCancelled) {
                applyAnimationClasses(element, options);
                applyAnimationStyles(element, options);
              }
              if (animationCancelled || (isStructural && animationDetails.event !== event)) {
                options.domOperation();
                runner.end();
              }
              if (!isValidAnimation) {
                clearElementAnimationState(element);
              }
              return;
            }
            event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, true) ? 'setClass' : animationDetails.event;
            if (animationDetails.structural) {
              closeParentClassBasedAnimations(parentElement);
            }
            markElementAnimationState(element, RUNNING_STATE);
            var realRunner = $$animation(element, event, animationDetails.options);
            realRunner.done(function(status) {
              close(!status);
              var animationDetails = activeAnimationsLookup.get(node);
              if (animationDetails && animationDetails.counter === counter) {
                clearElementAnimationState(getDomNode(element));
              }
              notifyProgress(runner, event, 'close', {});
            });
            runner.setHost(realRunner);
            notifyProgress(runner, event, 'start', {});
          });
          return runner;
          function notifyProgress(runner, event, phase, data) {
            triggerCallback(event, element, phase, data);
            runner.progress(event, phase, data);
          }
          function close(reject) {
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            runner.complete(!reject);
          }
        }
        function closeChildAnimations(element) {
          var node = getDomNode(element);
          var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
          forEach(children, function(child) {
            var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
            var animationDetails = activeAnimationsLookup.get(child);
            switch (state) {
              case RUNNING_STATE:
                animationDetails.runner.end();
              case PRE_DIGEST_STATE:
                if (animationDetails) {
                  activeAnimationsLookup.remove(child);
                }
                break;
            }
          });
        }
        function clearElementAnimationState(element) {
          var node = getDomNode(element);
          node.removeAttribute(NG_ANIMATE_ATTR_NAME);
          activeAnimationsLookup.remove(node);
        }
        function isMatchingElement(nodeOrElmA, nodeOrElmB) {
          return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
        }
        function closeParentClassBasedAnimations(startingElement) {
          var parentNode = getDomNode(startingElement);
          do {
            if (!parentNode || parentNode.nodeType !== ELEMENT_NODE)
              break;
            var animationDetails = activeAnimationsLookup.get(parentNode);
            if (animationDetails) {
              examineParentAnimation(parentNode, animationDetails);
            }
            parentNode = parentNode.parentNode;
          } while (true);
          function examineParentAnimation(node, animationDetails) {
            if (animationDetails.structural || !hasAnimationClasses(animationDetails.options))
              return;
            if (animationDetails.state === RUNNING_STATE) {
              animationDetails.runner.end();
            }
            clearElementAnimationState(node);
          }
        }
        function areAnimationsAllowed(element, parentElement, event) {
          var bodyElementDetected = false;
          var rootElementDetected = false;
          var parentAnimationDetected = false;
          var animateChildren;
          var parentHost = element.data(NG_ANIMATE_PIN_DATA);
          if (parentHost) {
            parentElement = parentHost;
          }
          while (parentElement && parentElement.length) {
            if (!rootElementDetected) {
              rootElementDetected = isMatchingElement(parentElement, $rootElement);
            }
            var parentNode = parentElement[0];
            if (parentNode.nodeType !== ELEMENT_NODE) {
              break;
            }
            var details = activeAnimationsLookup.get(parentNode) || {};
            if (!parentAnimationDetected) {
              parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode);
            }
            if (isUndefined(animateChildren) || animateChildren === true) {
              var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
              if (isDefined(value)) {
                animateChildren = value;
              }
            }
            if (parentAnimationDetected && animateChildren === false)
              break;
            if (!rootElementDetected) {
              rootElementDetected = isMatchingElement(parentElement, $rootElement);
              if (!rootElementDetected) {
                parentHost = parentElement.data(NG_ANIMATE_PIN_DATA);
                if (parentHost) {
                  parentElement = parentHost;
                }
              }
            }
            if (!bodyElementDetected) {
              bodyElementDetected = isMatchingElement(parentElement, bodyElement);
            }
            parentElement = parentElement.parent();
          }
          var allowAnimation = !parentAnimationDetected || animateChildren;
          return allowAnimation && rootElementDetected && bodyElementDetected;
        }
        function markElementAnimationState(element, state, details) {
          details = details || {};
          details.state = state;
          var node = getDomNode(element);
          node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
          var oldValue = activeAnimationsLookup.get(node);
          var newValue = oldValue ? extend(oldValue, details) : details;
          activeAnimationsLookup.put(node, newValue);
        }
      }];
    }];
    var $$rAFMutexFactory = ['$$rAF', function($$rAF) {
      return function() {
        var passed = false;
        $$rAF(function() {
          passed = true;
        });
        return function(fn) {
          passed ? fn() : $$rAF(fn);
        };
      };
    }];
    var $$AnimateRunnerFactory = ['$q', '$$rAFMutex', function($q, $$rAFMutex) {
      var INITIAL_STATE = 0;
      var DONE_PENDING_STATE = 1;
      var DONE_COMPLETE_STATE = 2;
      AnimateRunner.chain = function(chain, callback) {
        var index = 0;
        next();
        function next() {
          if (index === chain.length) {
            callback(true);
            return;
          }
          chain[index](function(response) {
            if (response === false) {
              callback(false);
              return;
            }
            index++;
            next();
          });
        }
      };
      AnimateRunner.all = function(runners, callback) {
        var count = 0;
        var status = true;
        forEach(runners, function(runner) {
          runner.done(onProgress);
        });
        function onProgress(response) {
          status = status && response;
          if (++count === runners.length) {
            callback(status);
          }
        }
      };
      function AnimateRunner(host) {
        this.setHost(host);
        this._doneCallbacks = [];
        this._runInAnimationFrame = $$rAFMutex();
        this._state = 0;
      }
      AnimateRunner.prototype = {
        setHost: function(host) {
          this.host = host || {};
        },
        done: function(fn) {
          if (this._state === DONE_COMPLETE_STATE) {
            fn();
          } else {
            this._doneCallbacks.push(fn);
          }
        },
        progress: noop,
        getPromise: function() {
          if (!this.promise) {
            var self = this;
            this.promise = $q(function(resolve, reject) {
              self.done(function(status) {
                status === false ? reject() : resolve();
              });
            });
          }
          return this.promise;
        },
        then: function(resolveHandler, rejectHandler) {
          return this.getPromise().then(resolveHandler, rejectHandler);
        },
        'catch': function(handler) {
          return this.getPromise()['catch'](handler);
        },
        'finally': function(handler) {
          return this.getPromise()['finally'](handler);
        },
        pause: function() {
          if (this.host.pause) {
            this.host.pause();
          }
        },
        resume: function() {
          if (this.host.resume) {
            this.host.resume();
          }
        },
        end: function() {
          if (this.host.end) {
            this.host.end();
          }
          this._resolve(true);
        },
        cancel: function() {
          if (this.host.cancel) {
            this.host.cancel();
          }
          this._resolve(false);
        },
        complete: function(response) {
          var self = this;
          if (self._state === INITIAL_STATE) {
            self._state = DONE_PENDING_STATE;
            self._runInAnimationFrame(function() {
              self._resolve(response);
            });
          }
        },
        _resolve: function(response) {
          if (this._state !== DONE_COMPLETE_STATE) {
            forEach(this._doneCallbacks, function(fn) {
              fn(response);
            });
            this._doneCallbacks.length = 0;
            this._state = DONE_COMPLETE_STATE;
          }
        }
      };
      return AnimateRunner;
    }];
    var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
      var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
      var drivers = this.drivers = [];
      var RUNNER_STORAGE_KEY = '$$animationRunner';
      function setRunner(element, runner) {
        element.data(RUNNER_STORAGE_KEY, runner);
      }
      function removeRunner(element) {
        element.removeData(RUNNER_STORAGE_KEY);
      }
      function getRunner(element) {
        return element.data(RUNNER_STORAGE_KEY);
      }
      this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$rAFScheduler', function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$rAFScheduler) {
        var animationQueue = [];
        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
        var totalPendingClassBasedAnimations = 0;
        var totalActiveClassBasedAnimations = 0;
        var classBasedAnimationsQueue = [];
        return function(element, event, options) {
          options = prepareAnimationOptions(options);
          var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;
          var runner = new $$AnimateRunner({
            end: function() {
              close();
            },
            cancel: function() {
              close(true);
            }
          });
          if (!drivers.length) {
            close();
            return runner;
          }
          setRunner(element, runner);
          var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
          var tempClasses = options.tempClasses;
          if (tempClasses) {
            classes += ' ' + tempClasses;
            options.tempClasses = null;
          }
          var classBasedIndex;
          if (!isStructural) {
            classBasedIndex = totalPendingClassBasedAnimations;
            totalPendingClassBasedAnimations += 1;
          }
          animationQueue.push({
            element: element,
            classes: classes,
            event: event,
            classBasedIndex: classBasedIndex,
            structural: isStructural,
            options: options,
            beforeStart: beforeStart,
            close: close
          });
          element.on('$destroy', handleDestroyedElement);
          if (animationQueue.length > 1)
            return runner;
          $rootScope.$$postDigest(function() {
            totalActiveClassBasedAnimations = totalPendingClassBasedAnimations;
            totalPendingClassBasedAnimations = 0;
            classBasedAnimationsQueue.length = 0;
            var animations = [];
            forEach(animationQueue, function(entry) {
              if (getRunner(entry.element)) {
                animations.push(entry);
              }
            });
            animationQueue.length = 0;
            forEach(groupAnimations(animations), function(animationEntry) {
              if (animationEntry.structural) {
                triggerAnimationStart();
              } else {
                classBasedAnimationsQueue.push({
                  node: getDomNode(animationEntry.element),
                  fn: triggerAnimationStart
                });
                if (animationEntry.classBasedIndex === totalActiveClassBasedAnimations - 1) {
                  classBasedAnimationsQueue = classBasedAnimationsQueue.sort(function(a, b) {
                    return b.node.contains(a.node);
                  }).map(function(entry) {
                    return entry.fn;
                  });
                  $$rAFScheduler(classBasedAnimationsQueue);
                }
              }
              function triggerAnimationStart() {
                animationEntry.beforeStart();
                var startAnimationFn,
                    closeFn = animationEntry.close;
                var targetElement = animationEntry.anchors ? (animationEntry.from.element || animationEntry.to.element) : animationEntry.element;
                if (getRunner(targetElement) && getDomNode(targetElement).parentNode) {
                  var operation = invokeFirstDriver(animationEntry);
                  if (operation) {
                    startAnimationFn = operation.start;
                  }
                }
                if (!startAnimationFn) {
                  closeFn();
                } else {
                  var animationRunner = startAnimationFn();
                  animationRunner.done(function(status) {
                    closeFn(!status);
                  });
                  updateAnimationRunners(animationEntry, animationRunner);
                }
              }
            });
          });
          return runner;
          function getAnchorNodes(node) {
            var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
            var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
            var anchors = [];
            forEach(items, function(node) {
              var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
              if (attr && attr.length) {
                anchors.push(node);
              }
            });
            return anchors;
          }
          function groupAnimations(animations) {
            var preparedAnimations = [];
            var refLookup = {};
            forEach(animations, function(animation, index) {
              var element = animation.element;
              var node = getDomNode(element);
              var event = animation.event;
              var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
              var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
              if (anchorNodes.length) {
                var direction = enterOrMove ? 'to' : 'from';
                forEach(anchorNodes, function(anchor) {
                  var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                  refLookup[key] = refLookup[key] || {};
                  refLookup[key][direction] = {
                    animationID: index,
                    element: jqLite(anchor)
                  };
                });
              } else {
                preparedAnimations.push(animation);
              }
            });
            var usedIndicesLookup = {};
            var anchorGroups = {};
            forEach(refLookup, function(operations, key) {
              var from = operations.from;
              var to = operations.to;
              if (!from || !to) {
                var index = from ? from.animationID : to.animationID;
                var indexKey = index.toString();
                if (!usedIndicesLookup[indexKey]) {
                  usedIndicesLookup[indexKey] = true;
                  preparedAnimations.push(animations[index]);
                }
                return;
              }
              var fromAnimation = animations[from.animationID];
              var toAnimation = animations[to.animationID];
              var lookupKey = from.animationID.toString();
              if (!anchorGroups[lookupKey]) {
                var group = anchorGroups[lookupKey] = {
                  structural: true,
                  beforeStart: function() {
                    fromAnimation.beforeStart();
                    toAnimation.beforeStart();
                  },
                  close: function() {
                    fromAnimation.close();
                    toAnimation.close();
                  },
                  classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                  from: fromAnimation,
                  to: toAnimation,
                  anchors: []
                };
                if (group.classes.length) {
                  preparedAnimations.push(group);
                } else {
                  preparedAnimations.push(fromAnimation);
                  preparedAnimations.push(toAnimation);
                }
              }
              anchorGroups[lookupKey].anchors.push({
                'out': from.element,
                'in': to.element
              });
            });
            return preparedAnimations;
          }
          function cssClassesIntersection(a, b) {
            a = a.split(' ');
            b = b.split(' ');
            var matches = [];
            for (var i = 0; i < a.length; i++) {
              var aa = a[i];
              if (aa.substring(0, 3) === 'ng-')
                continue;
              for (var j = 0; j < b.length; j++) {
                if (aa === b[j]) {
                  matches.push(aa);
                  break;
                }
              }
            }
            return matches.join(' ');
          }
          function invokeFirstDriver(animationDetails) {
            for (var i = drivers.length - 1; i >= 0; i--) {
              var driverName = drivers[i];
              if (!$injector.has(driverName))
                continue;
              var factory = $injector.get(driverName);
              var driver = factory(animationDetails);
              if (driver) {
                return driver;
              }
            }
          }
          function beforeStart() {
            element.addClass(NG_ANIMATE_CLASSNAME);
            if (tempClasses) {
              $$jqLite.addClass(element, tempClasses);
            }
          }
          function updateAnimationRunners(animation, newRunner) {
            if (animation.from && animation.to) {
              update(animation.from.element);
              update(animation.to.element);
            } else {
              update(animation.element);
            }
            function update(element) {
              getRunner(element).setHost(newRunner);
            }
          }
          function handleDestroyedElement() {
            var runner = getRunner(element);
            if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
              runner.end();
            }
          }
          function close(rejected) {
            element.off('$destroy', handleDestroyedElement);
            removeRunner(element);
            applyAnimationClasses(element, options);
            applyAnimationStyles(element, options);
            options.domOperation();
            if (tempClasses) {
              $$jqLite.removeClass(element, tempClasses);
            }
            element.removeClass(NG_ANIMATE_CLASSNAME);
            runner.complete(!rejected);
          }
        };
      }];
    }];
    angular.module('ngAnimate', []).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFMutex', $$rAFMutexFactory).factory('$$rAFScheduler', $$rAFSchedulerFactory).factory('$$AnimateRunner', $$AnimateRunnerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
  })(window, window.angular);
  (function(window, angular, undefined) {
    'use strict';
    var $sanitizeMinErr = angular.$$minErr('$sanitize');
    function $SanitizeProvider() {
      this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
        return function(html) {
          var buf = [];
          htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
            return !/^unsafe/.test($$sanitizeUri(uri, isImage));
          }));
          return buf.join('');
        };
      }];
    }
    function sanitizeText(chars) {
      var buf = [];
      var writer = htmlSanitizeWriter(buf, angular.noop);
      writer.chars(chars);
      return buf.join('');
    }
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
        END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
        ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
        BEGIN_TAG_REGEXP = /^</,
        BEGING_END_TAGE_REGEXP = /^<\//,
        COMMENT_REGEXP = /<!--(.*?)-->/g,
        DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
        CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
        SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    var voidElements = makeMap("area,br,col,hr,img,wbr");
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
        optionalEndTagInlineElements = makeMap("rp,rt"),
        optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);
    var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));
    var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
    var svgElements = makeMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph," + "hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline," + "radialGradient,rect,stop,svg,switch,text,title,tspan,use");
    var specialElements = makeMap("script,style");
    var validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements);
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");
    var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,' + 'valign,value,vspace,width');
    var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,' + 'cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,' + 'font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,' + 'height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,' + 'marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,' + 'max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,' + 'path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,' + 'requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,' + 'stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,' + 'stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,' + 'stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,' + 'underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,' + 'width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,' + 'xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan', true);
    var validAttrs = angular.extend({}, uriAttrs, svgAttrs, htmlAttrs);
    function makeMap(str, lowercaseKeys) {
      var obj = {},
          items = str.split(','),
          i;
      for (i = 0; i < items.length; i++) {
        obj[lowercaseKeys ? angular.lowercase(items[i]) : items[i]] = true;
      }
      return obj;
    }
    function htmlParser(html, handler) {
      if (typeof html !== 'string') {
        if (html === null || typeof html === 'undefined') {
          html = '';
        } else {
          html = '' + html;
        }
      }
      var index,
          chars,
          match,
          stack = [],
          last = html,
          text;
      stack.last = function() {
        return stack[stack.length - 1];
      };
      while (html) {
        text = '';
        chars = true;
        if (!stack.last() || !specialElements[stack.last()]) {
          if (html.indexOf("<!--") === 0) {
            index = html.indexOf("--", 4);
            if (index >= 0 && html.lastIndexOf("-->", index) === index) {
              if (handler.comment)
                handler.comment(html.substring(4, index));
              html = html.substring(index + 3);
              chars = false;
            }
          } else if (DOCTYPE_REGEXP.test(html)) {
            match = html.match(DOCTYPE_REGEXP);
            if (match) {
              html = html.replace(match[0], '');
              chars = false;
            }
          } else if (BEGING_END_TAGE_REGEXP.test(html)) {
            match = html.match(END_TAG_REGEXP);
            if (match) {
              html = html.substring(match[0].length);
              match[0].replace(END_TAG_REGEXP, parseEndTag);
              chars = false;
            }
          } else if (BEGIN_TAG_REGEXP.test(html)) {
            match = html.match(START_TAG_REGEXP);
            if (match) {
              if (match[4]) {
                html = html.substring(match[0].length);
                match[0].replace(START_TAG_REGEXP, parseStartTag);
              }
              chars = false;
            } else {
              text += '<';
              html = html.substring(1);
            }
          }
          if (chars) {
            index = html.indexOf("<");
            text += index < 0 ? html : html.substring(0, index);
            html = index < 0 ? "" : html.substring(index);
            if (handler.chars)
              handler.chars(decodeEntities(text));
          }
        } else {
          html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text) {
            text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");
            if (handler.chars)
              handler.chars(decodeEntities(text));
            return "";
          });
          parseEndTag("", stack.last());
        }
        if (html == last) {
          throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html);
        }
        last = html;
      }
      parseEndTag();
      function parseStartTag(tag, tagName, rest, unary) {
        tagName = angular.lowercase(tagName);
        if (blockElements[tagName]) {
          while (stack.last() && inlineElements[stack.last()]) {
            parseEndTag("", stack.last());
          }
        }
        if (optionalEndTagElements[tagName] && stack.last() == tagName) {
          parseEndTag("", tagName);
        }
        unary = voidElements[tagName] || !!unary;
        if (!unary) {
          stack.push(tagName);
        }
        var attrs = {};
        rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
          var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
          attrs[name] = decodeEntities(value);
        });
        if (handler.start)
          handler.start(tagName, attrs, unary);
      }
      function parseEndTag(tag, tagName) {
        var pos = 0,
            i;
        tagName = angular.lowercase(tagName);
        if (tagName) {
          for (pos = stack.length - 1; pos >= 0; pos--) {
            if (stack[pos] == tagName)
              break;
          }
        }
        if (pos >= 0) {
          for (i = stack.length - 1; i >= pos; i--)
            if (handler.end)
              handler.end(stack[i]);
          stack.length = pos;
        }
      }
    }
    var hiddenPre = document.createElement("pre");
    function decodeEntities(value) {
      if (!value) {
        return '';
      }
      hiddenPre.innerHTML = value.replace(/</g, "&lt;");
      return hiddenPre.textContent;
    }
    function encodeEntities(value) {
      return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP, function(value) {
        var hi = value.charCodeAt(0);
        var low = value.charCodeAt(1);
        return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
      }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
        return '&#' + value.charCodeAt(0) + ';';
      }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    function htmlSanitizeWriter(buf, uriValidator) {
      var ignore = false;
      var out = angular.bind(buf, buf.push);
      return {
        start: function(tag, attrs, unary) {
          tag = angular.lowercase(tag);
          if (!ignore && specialElements[tag]) {
            ignore = tag;
          }
          if (!ignore && validElements[tag] === true) {
            out('<');
            out(tag);
            angular.forEach(attrs, function(value, key) {
              var lkey = angular.lowercase(key);
              var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
              if (validAttrs[lkey] === true && (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
                out(' ');
                out(key);
                out('="');
                out(encodeEntities(value));
                out('"');
              }
            });
            out(unary ? '/>' : '>');
          }
        },
        end: function(tag) {
          tag = angular.lowercase(tag);
          if (!ignore && validElements[tag] === true) {
            out('</');
            out(tag);
            out('>');
          }
          if (tag == ignore) {
            ignore = false;
          }
        },
        chars: function(chars) {
          if (!ignore) {
            out(encodeEntities(chars));
          }
        }
      };
    }
    angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);
    angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
      var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/i,
          MAILTO_REGEXP = /^mailto:/i;
      return function(text, target) {
        if (!text)
          return text;
        var match;
        var raw = text;
        var html = [];
        var url;
        var i;
        while ((match = raw.match(LINKY_URL_REGEXP))) {
          url = match[0];
          if (!match[2] && !match[4]) {
            url = (match[3] ? 'http://' : 'mailto:') + url;
          }
          i = match.index;
          addText(raw.substr(0, i));
          addLink(url, match[0].replace(MAILTO_REGEXP, ''));
          raw = raw.substring(i + match[0].length);
        }
        addText(raw);
        return $sanitize(html.join(''));
        function addText(text) {
          if (!text) {
            return;
          }
          html.push(sanitizeText(text));
        }
        function addLink(url, text) {
          html.push('<a ');
          if (angular.isDefined(target)) {
            html.push('target="', target, '" ');
          }
          html.push('href="', url.replace(/"/g, '&quot;'), '">');
          addText(text);
          html.push('</a>');
        }
      };
    }]);
  })(window, window.angular);
  if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports) {
    module.exports = 'ui.router';
  }
  (function(window, angular, undefined) {
    'use strict';
    var isDefined = angular.isDefined,
        isFunction = angular.isFunction,
        isString = angular.isString,
        isObject = angular.isObject,
        isArray = angular.isArray,
        forEach = angular.forEach,
        extend = angular.extend,
        copy = angular.copy;
    function inherit(parent, extra) {
      return extend(new (extend(function() {}, {prototype: parent}))(), extra);
    }
    function merge(dst) {
      forEach(arguments, function(obj) {
        if (obj !== dst) {
          forEach(obj, function(value, key) {
            if (!dst.hasOwnProperty(key))
              dst[key] = value;
          });
        }
      });
      return dst;
    }
    function ancestors(first, second) {
      var path = [];
      for (var n in first.path) {
        if (first.path[n] !== second.path[n])
          break;
        path.push(first.path[n]);
      }
      return path;
    }
    function objectKeys(object) {
      if (Object.keys) {
        return Object.keys(object);
      }
      var result = [];
      angular.forEach(object, function(val, key) {
        result.push(key);
      });
      return result;
    }
    function indexOf(array, value) {
      if (Array.prototype.indexOf) {
        return array.indexOf(value, Number(arguments[2]) || 0);
      }
      var len = array.length >>> 0,
          from = Number(arguments[2]) || 0;
      from = (from < 0) ? Math.ceil(from) : Math.floor(from);
      if (from < 0)
        from += len;
      for (; from < len; from++) {
        if (from in array && array[from] === value)
          return from;
      }
      return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
      var parents = ancestors($current, $to),
          parentParams,
          inherited = {},
          inheritList = [];
      for (var i in parents) {
        if (!parents[i].params)
          continue;
        parentParams = objectKeys(parents[i].params);
        if (!parentParams.length)
          continue;
        for (var j in parentParams) {
          if (indexOf(inheritList, parentParams[j]) >= 0)
            continue;
          inheritList.push(parentParams[j]);
          inherited[parentParams[j]] = currentParams[parentParams[j]];
        }
      }
      return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
      if (!keys) {
        keys = [];
        for (var n in a)
          keys.push(n);
      }
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (a[k] != b[k])
          return false;
      }
      return true;
    }
    function filterByKeys(keys, values) {
      var filtered = {};
      forEach(keys, function(name) {
        filtered[name] = values[name];
      });
      return filtered;
    }
    function indexBy(array, propName) {
      var result = {};
      forEach(array, function(item) {
        result[item[propName]] = item;
      });
      return result;
    }
    function pick(obj) {
      var copy = {};
      var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      forEach(keys, function(key) {
        if (key in obj)
          copy[key] = obj[key];
      });
      return copy;
    }
    function omit(obj) {
      var copy = {};
      var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
      for (var key in obj) {
        if (indexOf(keys, key) == -1)
          copy[key] = obj[key];
      }
      return copy;
    }
    function pluck(collection, key) {
      var result = isArray(collection) ? [] : {};
      forEach(collection, function(val, i) {
        result[i] = isFunction(key) ? key(val) : val[key];
      });
      return result;
    }
    function filter(collection, callback) {
      var array = isArray(collection);
      var result = array ? [] : {};
      forEach(collection, function(val, i) {
        if (callback(val, i)) {
          result[array ? result.length : i] = val;
        }
      });
      return result;
    }
    function map(collection, callback) {
      var result = isArray(collection) ? [] : {};
      forEach(collection, function(val, i) {
        result[i] = callback(val, i);
      });
      return result;
    }
    angular.module('ui.router.util', ['ng']);
    angular.module('ui.router.router', ['ui.router.util']);
    angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);
    angular.module('ui.router', ['ui.router.state']);
    angular.module('ui.router.compat', ['ui.router']);
    $Resolve.$inject = ['$q', '$injector'];
    function $Resolve($q, $injector) {
      var VISIT_IN_PROGRESS = 1,
          VISIT_DONE = 2,
          NOTHING = {},
          NO_DEPENDENCIES = [],
          NO_LOCALS = NOTHING,
          NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
          });
      this.study = function(invocables) {
        if (!isObject(invocables))
          throw new Error("'invocables' must be an object");
        var invocableKeys = objectKeys(invocables || {});
        var plan = [],
            cycle = [],
            visited = {};
        function visit(value, key) {
          if (visited[key] === VISIT_DONE)
            return;
          cycle.push(key);
          if (visited[key] === VISIT_IN_PROGRESS) {
            cycle.splice(0, indexOf(cycle, key));
            throw new Error("Cyclic dependency: " + cycle.join(" -> "));
          }
          visited[key] = VISIT_IN_PROGRESS;
          if (isString(value)) {
            plan.push(key, [function() {
              return $injector.get(value);
            }], NO_DEPENDENCIES);
          } else {
            var params = $injector.annotate(value);
            forEach(params, function(param) {
              if (param !== key && invocables.hasOwnProperty(param))
                visit(invocables[param], param);
            });
            plan.push(key, value, params);
          }
          cycle.pop();
          visited[key] = VISIT_DONE;
        }
        forEach(invocables, visit);
        invocables = cycle = visited = null;
        function isResolve(value) {
          return isObject(value) && value.then && value.$$promises;
        }
        return function(locals, parent, self) {
          if (isResolve(locals) && self === undefined) {
            self = parent;
            parent = locals;
            locals = null;
          }
          if (!locals)
            locals = NO_LOCALS;
          else if (!isObject(locals)) {
            throw new Error("'locals' must be an object");
          }
          if (!parent)
            parent = NO_PARENT;
          else if (!isResolve(parent)) {
            throw new Error("'parent' must be a promise returned by $resolve.resolve()");
          }
          var resolution = $q.defer(),
              result = resolution.promise,
              promises = result.$$promises = {},
              values = extend({}, locals),
              wait = 1 + plan.length / 3,
              merged = false;
          function done() {
            if (!--wait) {
              if (!merged)
                merge(values, parent.$$values);
              result.$$values = values;
              result.$$promises = result.$$promises || true;
              delete result.$$inheritedValues;
              resolution.resolve(values);
            }
          }
          function fail(reason) {
            result.$$failure = reason;
            resolution.reject(reason);
          }
          if (isDefined(parent.$$failure)) {
            fail(parent.$$failure);
            return result;
          }
          if (parent.$$inheritedValues) {
            merge(values, omit(parent.$$inheritedValues, invocableKeys));
          }
          extend(promises, parent.$$promises);
          if (parent.$$values) {
            merged = merge(values, omit(parent.$$values, invocableKeys));
            result.$$inheritedValues = omit(parent.$$values, invocableKeys);
            done();
          } else {
            if (parent.$$inheritedValues) {
              result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
            }
            parent.then(done, fail);
          }
          for (var i = 0,
              ii = plan.length; i < ii; i += 3) {
            if (locals.hasOwnProperty(plan[i]))
              done();
            else
              invoke(plan[i], plan[i + 1], plan[i + 2]);
          }
          function invoke(key, invocable, params) {
            var invocation = $q.defer(),
                waitParams = 0;
            function onfailure(reason) {
              invocation.reject(reason);
              fail(reason);
            }
            forEach(params, function(dep) {
              if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                waitParams++;
                promises[dep].then(function(result) {
                  values[dep] = result;
                  if (!(--waitParams))
                    proceed();
                }, onfailure);
              }
            });
            if (!waitParams)
              proceed();
            function proceed() {
              if (isDefined(result.$$failure))
                return;
              try {
                invocation.resolve($injector.invoke(invocable, self, values));
                invocation.promise.then(function(result) {
                  values[key] = result;
                  done();
                }, onfailure);
              } catch (e) {
                onfailure(e);
              }
            }
            promises[key] = invocation.promise;
          }
          return result;
        };
      };
      this.resolve = function(invocables, locals, parent, self) {
        return this.study(invocables)(locals, parent, self);
      };
    }
    angular.module('ui.router.util').service('$resolve', $Resolve);
    $TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
    function $TemplateFactory($http, $templateCache, $injector) {
      this.fromConfig = function(config, params, locals) {
        return (isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null);
      };
      this.fromString = function(template, params) {
        return isFunction(template) ? template(params) : template;
      };
      this.fromUrl = function(url, params) {
        if (isFunction(url))
          url = url(params);
        if (url == null)
          return null;
        else
          return $http.get(url, {
            cache: $templateCache,
            headers: {Accept: 'text/html'}
          }).then(function(response) {
            return response.data;
          });
      };
      this.fromProvider = function(provider, params, locals) {
        return $injector.invoke(provider, null, locals || {params: params});
      };
    }
    angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
    var $$UMFP;
    function UrlMatcher(pattern, config, parentMatcher) {
      config = extend({params: {}}, isObject(config) ? config : {});
      var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
          searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
          compiled = '^',
          last = 0,
          m,
          segments = this.segments = [],
          parentParams = parentMatcher ? parentMatcher.params : {},
          params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
          paramNames = [];
      function addParameter(id, type, config, location) {
        paramNames.push(id);
        if (parentParams[id])
          return parentParams[id];
        if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id))
          throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
        if (params[id])
          throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
        params[id] = new $$UMFP.Param(id, type, config, location);
        return params[id];
      }
      function quoteRegExp(string, pattern, squash) {
        var surroundPattern = ['', ''],
            result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
        if (!pattern)
          return result;
        switch (squash) {
          case false:
            surroundPattern = ['(', ')'];
            break;
          case true:
            surroundPattern = ['?(', ')?'];
            break;
          default:
            surroundPattern = ['(' + squash + "|", ')?'];
            break;
        }
        return result + surroundPattern[0] + pattern + surroundPattern[1];
      }
      this.source = pattern;
      function matchDetails(m, isSearch) {
        var id,
            regexp,
            segment,
            type,
            cfg,
            arrayMode;
        id = m[2] || m[3];
        cfg = config.params[id];
        segment = pattern.substring(last, m.index);
        regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
        type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {pattern: new RegExp(regexp)});
        return {
          id: id,
          regexp: regexp,
          segment: segment,
          type: type,
          cfg: cfg
        };
      }
      var p,
          param,
          segment;
      while ((m = placeholder.exec(pattern))) {
        p = matchDetails(m, false);
        if (p.segment.indexOf('?') >= 0)
          break;
        param = addParameter(p.id, p.type, p.cfg, "path");
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);
        segments.push(p.segment);
        last = placeholder.lastIndex;
      }
      segment = pattern.substring(last);
      var i = segment.indexOf('?');
      if (i >= 0) {
        var search = this.sourceSearch = segment.substring(i);
        segment = segment.substring(0, i);
        this.sourcePath = pattern.substring(0, last + i);
        if (search.length > 0) {
          last = 0;
          while ((m = searchPlaceholder.exec(search))) {
            p = matchDetails(m, true);
            param = addParameter(p.id, p.type, p.cfg, "search");
            last = placeholder.lastIndex;
          }
        }
      } else {
        this.sourcePath = pattern;
        this.sourceSearch = '';
      }
      compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
      segments.push(segment);
      this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
      this.prefix = segments[0];
      this.$$paramNames = paramNames;
    }
    UrlMatcher.prototype.concat = function(pattern, config) {
      var defaultConfig = {
        caseInsensitive: $$UMFP.caseInsensitive(),
        strict: $$UMFP.strictMode(),
        squash: $$UMFP.defaultSquashPolicy()
      };
      return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    };
    UrlMatcher.prototype.toString = function() {
      return this.source;
    };
    UrlMatcher.prototype.exec = function(path, searchParams) {
      var m = this.regexp.exec(path);
      if (!m)
        return null;
      searchParams = searchParams || {};
      var paramNames = this.parameters(),
          nTotal = paramNames.length,
          nPath = this.segments.length - 1,
          values = {},
          i,
          j,
          cfg,
          paramName;
      if (nPath !== m.length - 1)
        throw new Error("Unbalanced capture group in route '" + this.source + "'");
      function decodePathArray(string) {
        function reverseString(str) {
          return str.split("").reverse().join("");
        }
        function unquoteDashes(str) {
          return str.replace(/\\-/, "-");
        }
        var split = reverseString(string).split(/-(?!\\)/);
        var allReversed = map(split, reverseString);
        return map(allReversed, unquoteDashes).reverse();
      }
      for (i = 0; i < nPath; i++) {
        paramName = paramNames[i];
        var param = this.params[paramName];
        var paramVal = m[i + 1];
        for (j = 0; j < param.replace; j++) {
          if (param.replace[j].from === paramVal)
            paramVal = param.replace[j].to;
        }
        if (paramVal && param.array === true)
          paramVal = decodePathArray(paramVal);
        values[paramName] = param.value(paramVal);
      }
      for (; i < nTotal; i++) {
        paramName = paramNames[i];
        values[paramName] = this.params[paramName].value(searchParams[paramName]);
      }
      return values;
    };
    UrlMatcher.prototype.parameters = function(param) {
      if (!isDefined(param))
        return this.$$paramNames;
      return this.params[param] || null;
    };
    UrlMatcher.prototype.validates = function(params) {
      return this.params.$$validates(params);
    };
    UrlMatcher.prototype.format = function(values) {
      values = values || {};
      var segments = this.segments,
          params = this.parameters(),
          paramset = this.params;
      if (!this.validates(values))
        return null;
      var i,
          search = false,
          nPath = segments.length - 1,
          nTotal = params.length,
          result = segments[0];
      function encodeDashes(str) {
        return encodeURIComponent(str).replace(/-/g, function(c) {
          return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
        });
      }
      for (i = 0; i < nTotal; i++) {
        var isPathParam = i < nPath;
        var name = params[i],
            param = paramset[name],
            value = param.value(values[name]);
        var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
        var squash = isDefaultValue ? param.squash : false;
        var encoded = param.type.encode(value);
        if (isPathParam) {
          var nextSegment = segments[i + 1];
          if (squash === false) {
            if (encoded != null) {
              if (isArray(encoded)) {
                result += map(encoded, encodeDashes).join("-");
              } else {
                result += encodeURIComponent(encoded);
              }
            }
            result += nextSegment;
          } else if (squash === true) {
            var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
            result += nextSegment.match(capture)[1];
          } else if (isString(squash)) {
            result += squash + nextSegment;
          }
        } else {
          if (encoded == null || (isDefaultValue && squash !== false))
            continue;
          if (!isArray(encoded))
            encoded = [encoded];
          encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
          result += (search ? '&' : '?') + (name + '=' + encoded);
          search = true;
        }
      }
      return result;
    };
    function Type(config) {
      extend(this, config);
    }
    Type.prototype.is = function(val, key) {
      return true;
    };
    Type.prototype.encode = function(val, key) {
      return val;
    };
    Type.prototype.decode = function(val, key) {
      return val;
    };
    Type.prototype.equals = function(a, b) {
      return a == b;
    };
    Type.prototype.$subPattern = function() {
      var sub = this.pattern.toString();
      return sub.substr(1, sub.length - 2);
    };
    Type.prototype.pattern = /.*/;
    Type.prototype.toString = function() {
      return "{Type:" + this.name + "}";
    };
    Type.prototype.$asArray = function(mode, isSearch) {
      if (!mode)
        return this;
      if (mode === "auto" && !isSearch)
        throw new Error("'auto' array mode is for query parameters only");
      return new ArrayType(this, mode);
      function ArrayType(type, mode) {
        function bindTo(type, callbackName) {
          return function() {
            return type[callbackName].apply(type, arguments);
          };
        }
        function arrayWrap(val) {
          return isArray(val) ? val : (isDefined(val) ? [val] : []);
        }
        function arrayUnwrap(val) {
          switch (val.length) {
            case 0:
              return undefined;
            case 1:
              return mode === "auto" ? val[0] : val;
            default:
              return val;
          }
        }
        function falsey(val) {
          return !val;
        }
        function arrayHandler(callback, allTruthyMode) {
          return function handleArray(val) {
            val = arrayWrap(val);
            var result = map(val, callback);
            if (allTruthyMode === true)
              return filter(result, falsey).length === 0;
            return arrayUnwrap(result);
          };
        }
        function arrayEqualsHandler(callback) {
          return function handleArray(val1, val2) {
            var left = arrayWrap(val1),
                right = arrayWrap(val2);
            if (left.length !== right.length)
              return false;
            for (var i = 0; i < left.length; i++) {
              if (!callback(left[i], right[i]))
                return false;
            }
            return true;
          };
        }
        this.encode = arrayHandler(bindTo(type, 'encode'));
        this.decode = arrayHandler(bindTo(type, 'decode'));
        this.is = arrayHandler(bindTo(type, 'is'), true);
        this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
        this.pattern = type.pattern;
        this.$arrayMode = mode;
      }
    };
    function $UrlMatcherFactory() {
      $$UMFP = this;
      var isCaseInsensitive = false,
          isStrictMode = true,
          defaultSquashPolicy = false;
      function valToString(val) {
        return val != null ? val.toString().replace(/\//g, "%2F") : val;
      }
      function valFromString(val) {
        return val != null ? val.toString().replace(/%2F/g, "/") : val;
      }
      function regexpMatches(val) {
        return this.pattern.test(val);
      }
      var $types = {},
          enqueue = true,
          typeQueue = [],
          injector,
          defaultTypes = {
            string: {
              encode: valToString,
              decode: valFromString,
              is: regexpMatches,
              pattern: /[^/]*/
            },
            int: {
              encode: valToString,
              decode: function(val) {
                return parseInt(val, 10);
              },
              is: function(val) {
                return isDefined(val) && this.decode(val.toString()) === val;
              },
              pattern: /\d+/
            },
            bool: {
              encode: function(val) {
                return val ? 1 : 0;
              },
              decode: function(val) {
                return parseInt(val, 10) !== 0;
              },
              is: function(val) {
                return val === true || val === false;
              },
              pattern: /0|1/
            },
            date: {
              encode: function(val) {
                if (!this.is(val))
                  return undefined;
                return [val.getFullYear(), ('0' + (val.getMonth() + 1)).slice(-2), ('0' + val.getDate()).slice(-2)].join("-");
              },
              decode: function(val) {
                if (this.is(val))
                  return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
              },
              is: function(val) {
                return val instanceof Date && !isNaN(val.valueOf());
              },
              equals: function(a, b) {
                return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
              },
              pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
              capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
              encode: angular.toJson,
              decode: angular.fromJson,
              is: angular.isObject,
              equals: angular.equals,
              pattern: /[^/]*/
            },
            any: {
              encode: angular.identity,
              decode: angular.identity,
              is: angular.identity,
              equals: angular.equals,
              pattern: /.*/
            }
          };
      function getDefaultConfig() {
        return {
          strict: isStrictMode,
          caseInsensitive: isCaseInsensitive
        };
      }
      function isInjectable(value) {
        return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
      }
      $UrlMatcherFactory.$$getDefaultValue = function(config) {
        if (!isInjectable(config.value))
          return config.value;
        if (!injector)
          throw new Error("Injectable functions cannot be called at configuration time");
        return injector.invoke(config.value);
      };
      this.caseInsensitive = function(value) {
        if (isDefined(value))
          isCaseInsensitive = value;
        return isCaseInsensitive;
      };
      this.strictMode = function(value) {
        if (isDefined(value))
          isStrictMode = value;
        return isStrictMode;
      };
      this.defaultSquashPolicy = function(value) {
        if (!isDefined(value))
          return defaultSquashPolicy;
        if (value !== true && value !== false && !isString(value))
          throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
        defaultSquashPolicy = value;
        return value;
      };
      this.compile = function(pattern, config) {
        return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
      };
      this.isMatcher = function(o) {
        if (!isObject(o))
          return false;
        var result = true;
        forEach(UrlMatcher.prototype, function(val, name) {
          if (isFunction(val)) {
            result = result && (isDefined(o[name]) && isFunction(o[name]));
          }
        });
        return result;
      };
      this.type = function(name, definition, definitionFn) {
        if (!isDefined(definition))
          return $types[name];
        if ($types.hasOwnProperty(name))
          throw new Error("A type named '" + name + "' has already been defined.");
        $types[name] = new Type(extend({name: name}, definition));
        if (definitionFn) {
          typeQueue.push({
            name: name,
            def: definitionFn
          });
          if (!enqueue)
            flushTypeQueue();
        }
        return this;
      };
      function flushTypeQueue() {
        while (typeQueue.length) {
          var type = typeQueue.shift();
          if (type.pattern)
            throw new Error("You cannot override a type's .pattern at runtime.");
          angular.extend($types[type.name], injector.invoke(type.def));
        }
      }
      forEach(defaultTypes, function(type, name) {
        $types[name] = new Type(extend({name: name}, type));
      });
      $types = inherit($types, {});
      this.$get = ['$injector', function($injector) {
        injector = $injector;
        enqueue = false;
        flushTypeQueue();
        forEach(defaultTypes, function(type, name) {
          if (!$types[name])
            $types[name] = new Type(type);
        });
        return this;
      }];
      this.Param = function Param(id, type, config, location) {
        var self = this;
        config = unwrapShorthand(config);
        type = getType(config, type, location);
        var arrayMode = getArrayMode();
        type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
        if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
          config.value = "";
        var isOptional = config.value !== undefined;
        var squash = getSquashPolicy(config, isOptional);
        var replace = getReplace(config, arrayMode, isOptional, squash);
        function unwrapShorthand(config) {
          var keys = isObject(config) ? objectKeys(config) : [];
          var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
          if (isShorthand)
            config = {value: config};
          config.$$fn = isInjectable(config.value) ? config.value : function() {
            return config.value;
          };
          return config;
        }
        function getType(config, urlType, location) {
          if (config.type && urlType)
            throw new Error("Param '" + id + "' has two type configurations.");
          if (urlType)
            return urlType;
          if (!config.type)
            return (location === "config" ? $types.any : $types.string);
          return config.type instanceof Type ? config.type : new Type(config.type);
        }
        function getArrayMode() {
          var arrayDefaults = {array: (location === "search" ? "auto" : false)};
          var arrayParamNomenclature = id.match(/\[\]$/) ? {array: true} : {};
          return extend(arrayDefaults, arrayParamNomenclature, config).array;
        }
        function getSquashPolicy(config, isOptional) {
          var squash = config.squash;
          if (!isOptional || squash === false)
            return false;
          if (!isDefined(squash) || squash == null)
            return defaultSquashPolicy;
          if (squash === true || isString(squash))
            return squash;
          throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
        }
        function getReplace(config, arrayMode, isOptional, squash) {
          var replace,
              configuredKeys,
              defaultPolicy = [{
                from: "",
                to: (isOptional || arrayMode ? undefined : "")
              }, {
                from: null,
                to: (isOptional || arrayMode ? undefined : "")
              }];
          replace = isArray(config.replace) ? config.replace : [];
          if (isString(squash))
            replace.push({
              from: squash,
              to: undefined
            });
          configuredKeys = map(replace, function(item) {
            return item.from;
          });
          return filter(defaultPolicy, function(item) {
            return indexOf(configuredKeys, item.from) === -1;
          }).concat(replace);
        }
        function $$getDefaultValue() {
          if (!injector)
            throw new Error("Injectable functions cannot be called at configuration time");
          return injector.invoke(config.$$fn);
        }
        function $value(value) {
          function hasReplaceVal(val) {
            return function(obj) {
              return obj.from === val;
            };
          }
          function $replace(value) {
            var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
              return obj.to;
            });
            return replacement.length ? replacement[0] : value;
          }
          value = $replace(value);
          return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
        }
        function toString() {
          return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
        }
        extend(this, {
          id: id,
          type: type,
          location: location,
          array: arrayMode,
          squash: squash,
          replace: replace,
          isOptional: isOptional,
          value: $value,
          dynamic: undefined,
          config: config,
          toString: toString
        });
      };
      function ParamSet(params) {
        extend(this, params || {});
      }
      ParamSet.prototype = {
        $$new: function() {
          return inherit(this, extend(new ParamSet(), {$$parent: this}));
        },
        $$keys: function() {
          var keys = [],
              chain = [],
              parent = this,
              ignore = objectKeys(ParamSet.prototype);
          while (parent) {
            chain.push(parent);
            parent = parent.$$parent;
          }
          chain.reverse();
          forEach(chain, function(paramset) {
            forEach(objectKeys(paramset), function(key) {
              if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                keys.push(key);
            });
          });
          return keys;
        },
        $$values: function(paramValues) {
          var values = {},
              self = this;
          forEach(self.$$keys(), function(key) {
            values[key] = self[key].value(paramValues && paramValues[key]);
          });
          return values;
        },
        $$equals: function(paramValues1, paramValues2) {
          var equal = true,
              self = this;
          forEach(self.$$keys(), function(key) {
            var left = paramValues1 && paramValues1[key],
                right = paramValues2 && paramValues2[key];
            if (!self[key].type.equals(left, right))
              equal = false;
          });
          return equal;
        },
        $$validates: function $$validate(paramValues) {
          var result = true,
              isOptional,
              val,
              param,
              self = this;
          forEach(this.$$keys(), function(key) {
            param = self[key];
            val = paramValues[key];
            isOptional = !val && param.isOptional;
            result = result && (isOptional || !!param.type.is(val));
          });
          return result;
        },
        $$parent: undefined
      };
      this.ParamSet = ParamSet;
    }
    angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
    angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) {}]);
    $UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
      var rules = [],
          otherwise = null,
          interceptDeferred = false,
          listener;
      function regExpPrefix(re) {
        var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
        return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
      }
      function interpolate(pattern, match) {
        return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
          return match[what === '$' ? 0 : Number(what)];
        });
      }
      this.rule = function(rule) {
        if (!isFunction(rule))
          throw new Error("'rule' must be a function");
        rules.push(rule);
        return this;
      };
      this.otherwise = function(rule) {
        if (isString(rule)) {
          var redirect = rule;
          rule = function() {
            return redirect;
          };
        } else if (!isFunction(rule))
          throw new Error("'rule' must be a function");
        otherwise = rule;
        return this;
      };
      function handleIfMatch($injector, handler, match) {
        if (!match)
          return false;
        var result = $injector.invoke(handler, handler, {$match: match});
        return isDefined(result) ? result : true;
      }
      this.when = function(what, handler) {
        var redirect,
            handlerIsString = isString(handler);
        if (isString(what))
          what = $urlMatcherFactory.compile(what);
        if (!handlerIsString && !isFunction(handler) && !isArray(handler))
          throw new Error("invalid 'handler' in when()");
        var strategies = {
          matcher: function(what, handler) {
            if (handlerIsString) {
              redirect = $urlMatcherFactory.compile(handler);
              handler = ['$match', function($match) {
                return redirect.format($match);
              }];
            }
            return extend(function($injector, $location) {
              return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
            }, {prefix: isString(what.prefix) ? what.prefix : ''});
          },
          regex: function(what, handler) {
            if (what.global || what.sticky)
              throw new Error("when() RegExp must not be global or sticky");
            if (handlerIsString) {
              redirect = handler;
              handler = ['$match', function($match) {
                return interpolate(redirect, $match);
              }];
            }
            return extend(function($injector, $location) {
              return handleIfMatch($injector, handler, what.exec($location.path()));
            }, {prefix: regExpPrefix(what)});
          }
        };
        var check = {
          matcher: $urlMatcherFactory.isMatcher(what),
          regex: what instanceof RegExp
        };
        for (var n in check) {
          if (check[n])
            return this.rule(strategies[n](what, handler));
        }
        throw new Error("invalid 'what' in when()");
      };
      this.deferIntercept = function(defer) {
        if (defer === undefined)
          defer = true;
        interceptDeferred = defer;
      };
      this.$get = $get;
      $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
      function $get($location, $rootScope, $injector, $browser) {
        var baseHref = $browser.baseHref(),
            location = $location.url(),
            lastPushedUrl;
        function appendBasePath(url, isHtml5, absolute) {
          if (baseHref === '/')
            return url;
          if (isHtml5)
            return baseHref.slice(0, -1) + url;
          if (absolute)
            return baseHref.slice(1) + url;
          return url;
        }
        function update(evt) {
          if (evt && evt.defaultPrevented)
            return;
          var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
          lastPushedUrl = undefined;
          if (ignoreUpdate)
            return true;
          function check(rule) {
            var handled = rule($injector, $location);
            if (!handled)
              return false;
            if (isString(handled))
              $location.replace().url(handled);
            return true;
          }
          var n = rules.length,
              i;
          for (i = 0; i < n; i++) {
            if (check(rules[i]))
              return;
          }
          if (otherwise)
            check(otherwise);
        }
        function listen() {
          listener = listener || $rootScope.$on('$locationChangeSuccess', update);
          return listener;
        }
        if (!interceptDeferred)
          listen();
        return {
          sync: function() {
            update();
          },
          listen: function() {
            return listen();
          },
          update: function(read) {
            if (read) {
              location = $location.url();
              return;
            }
            if ($location.url() === location)
              return;
            $location.url(location);
            $location.replace();
          },
          push: function(urlMatcher, params, options) {
            $location.url(urlMatcher.format(params || {}));
            lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
            if (options && options.replace)
              $location.replace();
          },
          href: function(urlMatcher, params, options) {
            if (!urlMatcher.validates(params))
              return null;
            var isHtml5 = $locationProvider.html5Mode();
            if (angular.isObject(isHtml5)) {
              isHtml5 = isHtml5.enabled;
            }
            var url = urlMatcher.format(params);
            options = options || {};
            if (!isHtml5 && url !== null) {
              url = "#" + $locationProvider.hashPrefix() + url;
            }
            url = appendBasePath(url, isHtml5, options.absolute);
            if (!options.absolute || !url) {
              return url;
            }
            var slash = (!isHtml5 && url ? '/' : ''),
                port = $location.port();
            port = (port === 80 || port === 443 ? '' : ':' + port);
            return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
          }
        };
      }
    }
    angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
    $StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
      var root,
          states = {},
          $state,
          queue = {},
          abstractKey = 'abstract';
      var stateBuilder = {
        parent: function(state) {
          if (isDefined(state.parent) && state.parent)
            return findState(state.parent);
          var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
          return compositeName ? findState(compositeName[1]) : root;
        },
        data: function(state) {
          if (state.parent && state.parent.data) {
            state.data = state.self.data = extend({}, state.parent.data, state.data);
          }
          return state.data;
        },
        url: function(state) {
          var url = state.url,
              config = {params: state.params || {}};
          if (isString(url)) {
            if (url.charAt(0) == '^')
              return $urlMatcherFactory.compile(url.substring(1), config);
            return (state.parent.navigable || root).url.concat(url, config);
          }
          if (!url || $urlMatcherFactory.isMatcher(url))
            return url;
          throw new Error("Invalid url '" + url + "' in state '" + state + "'");
        },
        navigable: function(state) {
          return state.url ? state : (state.parent ? state.parent.navigable : null);
        },
        ownParams: function(state) {
          var params = state.url && state.url.params || new $$UMFP.ParamSet();
          forEach(state.params || {}, function(config, id) {
            if (!params[id])
              params[id] = new $$UMFP.Param(id, null, config, "config");
          });
          return params;
        },
        params: function(state) {
          return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
        },
        views: function(state) {
          var views = {};
          forEach(isDefined(state.views) ? state.views : {'': state}, function(view, name) {
            if (name.indexOf('@') < 0)
              name += '@' + state.parent.name;
            views[name] = view;
          });
          return views;
        },
        path: function(state) {
          return state.parent ? state.parent.path.concat(state) : [];
        },
        includes: function(state) {
          var includes = state.parent ? extend({}, state.parent.includes) : {};
          includes[state.name] = true;
          return includes;
        },
        $delegates: {}
      };
      function isRelative(stateName) {
        return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
      }
      function findState(stateOrName, base) {
        if (!stateOrName)
          return undefined;
        var isStr = isString(stateOrName),
            name = isStr ? stateOrName : stateOrName.name,
            path = isRelative(name);
        if (path) {
          if (!base)
            throw new Error("No reference point given for path '" + name + "'");
          base = findState(base);
          var rel = name.split("."),
              i = 0,
              pathLength = rel.length,
              current = base;
          for (; i < pathLength; i++) {
            if (rel[i] === "" && i === 0) {
              current = base;
              continue;
            }
            if (rel[i] === "^") {
              if (!current.parent)
                throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
              current = current.parent;
              continue;
            }
            break;
          }
          rel = rel.slice(i).join(".");
          name = current.name + (current.name && rel ? "." : "") + rel;
        }
        var state = states[name];
        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
          return state;
        }
        return undefined;
      }
      function queueState(parentName, state) {
        if (!queue[parentName]) {
          queue[parentName] = [];
        }
        queue[parentName].push(state);
      }
      function flushQueuedChildren(parentName) {
        var queued = queue[parentName] || [];
        while (queued.length) {
          registerState(queued.shift());
        }
      }
      function registerState(state) {
        state = inherit(state, {
          self: state,
          resolve: state.resolve || {},
          toString: function() {
            return this.name;
          }
        });
        var name = state.name;
        if (!isString(name) || name.indexOf('@') >= 0)
          throw new Error("State must have a valid name");
        if (states.hasOwnProperty(name))
          throw new Error("State '" + name + "'' is already defined");
        var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.')) : (isString(state.parent)) ? state.parent : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name : '';
        if (parentName && !states[parentName]) {
          return queueState(parentName, state.self);
        }
        for (var key in stateBuilder) {
          if (isFunction(stateBuilder[key]))
            state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
        }
        states[name] = state;
        if (!state[abstractKey] && state.url) {
          $urlRouterProvider.when(state.url, ['$match', '$stateParams', function($match, $stateParams) {
            if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
              $state.transitionTo(state, $match, {
                inherit: true,
                location: false
              });
            }
          }]);
        }
        flushQueuedChildren(name);
        return state;
      }
      function isGlob(text) {
        return text.indexOf('*') > -1;
      }
      function doesStateMatchGlob(glob) {
        var globSegments = glob.split('.'),
            segments = $state.$current.name.split('.');
        if (globSegments[0] === '**') {
          segments = segments.slice(indexOf(segments, globSegments[1]));
          segments.unshift('**');
        }
        if (globSegments[globSegments.length - 1] === '**') {
          segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
          segments.push('**');
        }
        if (globSegments.length != segments.length) {
          return false;
        }
        for (var i = 0,
            l = globSegments.length; i < l; i++) {
          if (globSegments[i] === '*') {
            segments[i] = '*';
          }
        }
        return segments.join('') === globSegments.join('');
      }
      root = registerState({
        name: '',
        url: '^',
        views: null,
        'abstract': true
      });
      root.navigable = null;
      this.decorator = decorator;
      function decorator(name, func) {
        if (isString(name) && !isDefined(func)) {
          return stateBuilder[name];
        }
        if (!isFunction(func) || !isString(name)) {
          return this;
        }
        if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
          stateBuilder.$delegates[name] = stateBuilder[name];
        }
        stateBuilder[name] = func;
        return this;
      }
      this.state = state;
      function state(name, definition) {
        if (isObject(name))
          definition = name;
        else
          definition.name = name;
        registerState(definition);
        return this;
      }
      this.$get = $get;
      $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
      function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
        var TransitionSuperseded = $q.reject(new Error('transition superseded'));
        var TransitionPrevented = $q.reject(new Error('transition prevented'));
        var TransitionAborted = $q.reject(new Error('transition aborted'));
        var TransitionFailed = $q.reject(new Error('transition failed'));
        function handleRedirect(redirect, state, params, options) {
          var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
          if (evt.defaultPrevented) {
            $urlRouter.update();
            return TransitionAborted;
          }
          if (!evt.retry) {
            return null;
          }
          if (options.$retry) {
            $urlRouter.update();
            return TransitionFailed;
          }
          var retryTransition = $state.transition = $q.when(evt.retry);
          retryTransition.then(function() {
            if (retryTransition !== $state.transition)
              return TransitionSuperseded;
            redirect.options.$retry = true;
            return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
          }, function() {
            return TransitionAborted;
          });
          $urlRouter.update();
          return retryTransition;
        }
        root.locals = {
          resolve: null,
          globals: {$stateParams: {}}
        };
        $state = {
          params: {},
          current: root.self,
          $current: root,
          transition: null
        };
        $state.reload = function reload() {
          return $state.transitionTo($state.current, $stateParams, {
            reload: true,
            inherit: false,
            notify: true
          });
        };
        $state.go = function go(to, params, options) {
          return $state.transitionTo(to, params, extend({
            inherit: true,
            relative: $state.$current
          }, options));
        };
        $state.transitionTo = function transitionTo(to, toParams, options) {
          toParams = toParams || {};
          options = extend({
            location: true,
            inherit: false,
            relative: null,
            notify: true,
            reload: false,
            $retry: false
          }, options || {});
          var from = $state.$current,
              fromParams = $state.params,
              fromPath = from.path;
          var evt,
              toState = findState(to, options.relative);
          if (!isDefined(toState)) {
            var redirect = {
              to: to,
              toParams: toParams,
              options: options
            };
            var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
            if (redirectResult) {
              return redirectResult;
            }
            to = redirect.to;
            toParams = redirect.toParams;
            options = redirect.options;
            toState = findState(to, options.relative);
            if (!isDefined(toState)) {
              if (!options.relative)
                throw new Error("No such state '" + to + "'");
              throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
            }
          }
          if (toState[abstractKey])
            throw new Error("Cannot transition to abstract state '" + to + "'");
          if (options.inherit)
            toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
          if (!toState.params.$$validates(toParams))
            return TransitionFailed;
          toParams = toState.params.$$values(toParams);
          to = toState;
          var toPath = to.path;
          var keep = 0,
              state = toPath[keep],
              locals = root.locals,
              toLocals = [];
          if (!options.reload) {
            while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
              locals = toLocals[keep] = state.locals;
              keep++;
              state = toPath[keep];
            }
          }
          if (shouldTriggerReload(to, from, locals, options)) {
            if (to.self.reloadOnSearch !== false)
              $urlRouter.update();
            $state.transition = null;
            return $q.when($state.current);
          }
          toParams = filterByKeys(to.params.$$keys(), toParams || {});
          if (options.notify) {
            if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
              $urlRouter.update();
              return TransitionPrevented;
            }
          }
          var resolved = $q.when(locals);
          for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
            locals = toLocals[l] = inherit(locals);
            resolved = resolveState(state, toParams, state === to, resolved, locals, options);
          }
          var transition = $state.transition = resolved.then(function() {
            var l,
                entering,
                exiting;
            if ($state.transition !== transition)
              return TransitionSuperseded;
            for (l = fromPath.length - 1; l >= keep; l--) {
              exiting = fromPath[l];
              if (exiting.self.onExit) {
                $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
              }
              exiting.locals = null;
            }
            for (l = keep; l < toPath.length; l++) {
              entering = toPath[l];
              entering.locals = toLocals[l];
              if (entering.self.onEnter) {
                $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
              }
            }
            if ($state.transition !== transition)
              return TransitionSuperseded;
            $state.$current = to;
            $state.current = to.self;
            $state.params = toParams;
            copy($state.params, $stateParams);
            $state.transition = null;
            if (options.location && to.navigable) {
              $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                $$avoidResync: true,
                replace: options.location === 'replace'
              });
            }
            if (options.notify) {
              $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
            }
            $urlRouter.update(true);
            return $state.current;
          }, function(error) {
            if ($state.transition !== transition)
              return TransitionSuperseded;
            $state.transition = null;
            evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
            if (!evt.defaultPrevented) {
              $urlRouter.update();
            }
            return $q.reject(error);
          });
          return transition;
        };
        $state.is = function is(stateOrName, params, options) {
          options = extend({relative: $state.$current}, options || {});
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state)) {
            return undefined;
          }
          if ($state.$current !== state) {
            return false;
          }
          return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
        };
        $state.includes = function includes(stateOrName, params, options) {
          options = extend({relative: $state.$current}, options || {});
          if (isString(stateOrName) && isGlob(stateOrName)) {
            if (!doesStateMatchGlob(stateOrName)) {
              return false;
            }
            stateOrName = $state.$current.name;
          }
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state)) {
            return undefined;
          }
          if (!isDefined($state.$current.includes[state.name])) {
            return false;
          }
          return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
        };
        $state.href = function href(stateOrName, params, options) {
          options = extend({
            lossy: true,
            inherit: true,
            absolute: false,
            relative: $state.$current
          }, options || {});
          var state = findState(stateOrName, options.relative);
          if (!isDefined(state))
            return null;
          if (options.inherit)
            params = inheritParams($stateParams, params || {}, $state.$current, state);
          var nav = (state && options.lossy) ? state.navigable : state;
          if (!nav || nav.url === undefined || nav.url === null) {
            return null;
          }
          return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {absolute: options.absolute});
        };
        $state.get = function(stateOrName, context) {
          if (arguments.length === 0)
            return map(objectKeys(states), function(name) {
              return states[name].self;
            });
          var state = findState(stateOrName, context || $state.$current);
          return (state && state.self) ? state.self : null;
        };
        function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
          var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
          var locals = {$stateParams: $stateParams};
          dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
          var promises = [dst.resolve.then(function(globals) {
            dst.globals = globals;
          })];
          if (inherited)
            promises.push(inherited);
          forEach(state.views, function(view, name) {
            var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
            injectables.$template = [function() {
              return $view.load(name, {
                view: view,
                locals: locals,
                params: $stateParams,
                notify: options.notify
              }) || '';
            }];
            promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function(result) {
              if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                var injectLocals = angular.extend({}, injectables, locals);
                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
              } else {
                result.$$controller = view.controller;
              }
              result.$$state = state;
              result.$$controllerAs = view.controllerAs;
              dst[name] = result;
            }));
          });
          return $q.all(promises).then(function(values) {
            return dst;
          });
        }
        return $state;
      }
      function shouldTriggerReload(to, from, locals, options) {
        if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {
          return true;
        }
      }
    }
    angular.module('ui.router.state').value('$stateParams', {}).provider('$state', $StateProvider);
    $ViewProvider.$inject = [];
    function $ViewProvider() {
      this.$get = $get;
      $get.$inject = ['$rootScope', '$templateFactory'];
      function $get($rootScope, $templateFactory) {
        return {load: function load(name, options) {
            var result,
                defaults = {
                  template: null,
                  controller: null,
                  view: null,
                  locals: null,
                  notify: true,
                  async: true,
                  params: {}
                };
            options = extend(defaults, options);
            if (options.view) {
              result = $templateFactory.fromConfig(options.view, options.params, options.locals);
            }
            if (result && options.notify) {
              $rootScope.$broadcast('$viewContentLoading', options);
            }
            return result;
          }};
      }
    }
    angular.module('ui.router.state').provider('$view', $ViewProvider);
    function $ViewScrollProvider() {
      var useAnchorScroll = false;
      this.useAnchorScroll = function() {
        useAnchorScroll = true;
      };
      this.$get = ['$anchorScroll', '$timeout', function($anchorScroll, $timeout) {
        if (useAnchorScroll) {
          return $anchorScroll;
        }
        return function($element) {
          $timeout(function() {
            $element[0].scrollIntoView();
          }, 0, false);
        };
      }];
    }
    angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
    $ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
      function getService() {
        return ($injector.has) ? function(service) {
          return $injector.has(service) ? $injector.get(service) : null;
        } : function(service) {
          try {
            return $injector.get(service);
          } catch (e) {
            return null;
          }
        };
      }
      var service = getService(),
          $animator = service('$animator'),
          $animate = service('$animate');
      function getRenderer(attrs, scope) {
        var statics = function() {
          return {
            enter: function(element, target, cb) {
              target.after(element);
              cb();
            },
            leave: function(element, cb) {
              element.remove();
              cb();
            }
          };
        };
        if ($animate) {
          return {
            enter: function(element, target, cb) {
              var promise = $animate.enter(element, null, target, cb);
              if (promise && promise.then)
                promise.then(cb);
            },
            leave: function(element, cb) {
              var promise = $animate.leave(element, cb);
              if (promise && promise.then)
                promise.then(cb);
            }
          };
        }
        if ($animator) {
          var animate = $animator && $animator(scope, attrs);
          return {
            enter: function(element, target, cb) {
              animate.enter(element, null, target);
              cb();
            },
            leave: function(element, cb) {
              animate.leave(element);
              cb();
            }
          };
        }
        return statics();
      }
      var directive = {
        restrict: 'ECA',
        terminal: true,
        priority: 400,
        transclude: 'element',
        compile: function(tElement, tAttrs, $transclude) {
          return function(scope, $element, attrs) {
            var previousEl,
                currentEl,
                currentScope,
                latestLocals,
                onloadExp = attrs.onload || '',
                autoScrollExp = attrs.autoscroll,
                renderer = getRenderer(attrs, scope);
            scope.$on('$stateChangeSuccess', function() {
              updateView(false);
            });
            scope.$on('$viewContentLoading', function() {
              updateView(false);
            });
            updateView(true);
            function cleanupLastView() {
              if (previousEl) {
                previousEl.remove();
                previousEl = null;
              }
              if (currentScope) {
                currentScope.$destroy();
                currentScope = null;
              }
              if (currentEl) {
                renderer.leave(currentEl, function() {
                  previousEl = null;
                });
                previousEl = currentEl;
                currentEl = null;
              }
            }
            function updateView(firstTime) {
              var newScope,
                  name = getUiViewName(scope, attrs, $element, $interpolate),
                  previousLocals = name && $state.$current && $state.$current.locals[name];
              if (!firstTime && previousLocals === latestLocals)
                return;
              newScope = scope.$new();
              latestLocals = $state.$current.locals[name];
              var clone = $transclude(newScope, function(clone) {
                renderer.enter(clone, $element, function onUiViewEnter() {
                  if (currentScope) {
                    currentScope.$emit('$viewContentAnimationEnded');
                  }
                  if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                    $uiViewScroll(clone);
                  }
                });
                cleanupLastView();
              });
              currentEl = clone;
              currentScope = newScope;
              currentScope.$emit('$viewContentLoaded');
              currentScope.$eval(onloadExp);
            }
          };
        }
      };
      return directive;
    }
    $ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
      return {
        restrict: 'ECA',
        priority: -400,
        compile: function(tElement) {
          var initial = tElement.html();
          return function(scope, $element, attrs) {
            var current = $state.$current,
                name = getUiViewName(scope, attrs, $element, $interpolate),
                locals = current && current.locals[name];
            if (!locals) {
              return;
            }
            $element.data('$uiView', {
              name: name,
              state: locals.$$state
            });
            $element.html(locals.$template ? locals.$template : initial);
            var link = $compile($element.contents());
            if (locals.$$controller) {
              locals.$scope = scope;
              var controller = $controller(locals.$$controller, locals);
              if (locals.$$controllerAs) {
                scope[locals.$$controllerAs] = controller;
              }
              $element.data('$ngControllerController', controller);
              $element.children().data('$ngControllerController', controller);
            }
            link(scope);
          };
        }
      };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
      var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
      var inherited = element.inheritedData('$uiView');
      return name.indexOf('@') >= 0 ? name : (name + '@' + (inherited ? inherited.state.name : ''));
    }
    angular.module('ui.router.state').directive('uiView', $ViewDirective);
    angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
    function parseStateRef(ref, current) {
      var preparsed = ref.match(/^\s*({[^}]*})\s*$/),
          parsed;
      if (preparsed)
        ref = current + '(' + preparsed[1] + ')';
      parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
      if (!parsed || parsed.length !== 4)
        throw new Error("Invalid state ref '" + ref + "'");
      return {
        state: parsed[1],
        paramExpr: parsed[3] || null
      };
    }
    function stateContext(el) {
      var stateData = el.parent().inheritedData('$uiView');
      if (stateData && stateData.state && stateData.state.name) {
        return stateData.state;
      }
    }
    $StateRefDirective.$inject = ['$state', '$timeout'];
    function $StateRefDirective($state, $timeout) {
      var allowedOptions = ['location', 'inherit', 'reload'];
      return {
        restrict: 'A',
        require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
        link: function(scope, element, attrs, uiSrefActive) {
          var ref = parseStateRef(attrs.uiSref, $state.current.name);
          var params = null,
              url = null,
              base = stateContext(element) || $state.$current;
          var newHref = null,
              isAnchor = element.prop("tagName") === "A";
          var isForm = element[0].nodeName === "FORM";
          var attr = isForm ? "action" : "href",
              nav = true;
          var options = {
            relative: base,
            inherit: true
          };
          var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
          angular.forEach(allowedOptions, function(option) {
            if (option in optionsOverride) {
              options[option] = optionsOverride[option];
            }
          });
          var update = function(newVal) {
            if (newVal)
              params = angular.copy(newVal);
            if (!nav)
              return;
            newHref = $state.href(ref.state, params, options);
            var activeDirective = uiSrefActive[1] || uiSrefActive[0];
            if (activeDirective) {
              activeDirective.$$setStateInfo(ref.state, params);
            }
            if (newHref === null) {
              nav = false;
              return false;
            }
            attrs.$set(attr, newHref);
          };
          if (ref.paramExpr) {
            scope.$watch(ref.paramExpr, function(newVal, oldVal) {
              if (newVal !== params)
                update(newVal);
            }, true);
            params = angular.copy(scope.$eval(ref.paramExpr));
          }
          update();
          if (isForm)
            return;
          element.bind("click", function(e) {
            var button = e.which || e.button;
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target'))) {
              var transition = $timeout(function() {
                $state.go(ref.state, params, options);
              });
              e.preventDefault();
              var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
              e.preventDefault = function() {
                if (ignorePreventDefaultCount-- <= 0)
                  $timeout.cancel(transition);
              };
            }
          });
        }
      };
    }
    $StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
      return {
        restrict: "A",
        controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
          var state,
              params,
              activeClass;
          activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);
          this.$$setStateInfo = function(newState, newParams) {
            state = $state.get(newState, stateContext($element));
            params = newParams;
            update();
          };
          $scope.$on('$stateChangeSuccess', update);
          function update() {
            if (isMatch()) {
              $element.addClass(activeClass);
            } else {
              $element.removeClass(activeClass);
            }
          }
          function isMatch() {
            if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
              return state && $state.is(state.name, params);
            } else {
              return state && $state.includes(state.name, params);
            }
          }
        }]
      };
    }
    angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective);
    $IsStateFilter.$inject = ['$state'];
    function $IsStateFilter($state) {
      var isFilter = function(state) {
        return $state.is(state);
      };
      isFilter.$stateful = true;
      return isFilter;
    }
    $IncludedByStateFilter.$inject = ['$state'];
    function $IncludedByStateFilter($state) {
      var includesFilter = function(state) {
        return $state.includes(state);
      };
      includesFilter.$stateful = true;
      return includesFilter;
    }
    angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
  })(window, window.angular);
  (function() {
    var IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router', 'ngIOS9UIWebViewPatch']),
        extend = angular.extend,
        forEach = angular.forEach,
        isDefined = angular.isDefined,
        isNumber = angular.isNumber,
        isString = angular.isString,
        jqLite = angular.element,
        noop = angular.noop;
    IonicModule.factory('$ionicActionSheet', ['$rootScope', '$compile', '$animate', '$timeout', '$ionicTemplateLoader', '$ionicPlatform', '$ionicBody', 'IONIC_BACK_PRIORITY', function($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {
      return {show: actionSheet};
      function actionSheet(opts) {
        var scope = $rootScope.$new(true);
        extend(scope, {
          cancel: noop,
          destructiveButtonClicked: noop,
          buttonClicked: noop,
          $deregisterBackButton: noop,
          buttons: [],
          cancelOnStateChange: true
        }, opts || {});
        function textForIcon(text) {
          if (text && /icon/.test(text)) {
            scope.$actionSheetHasIcon = true;
          }
        }
        for (var x = 0; x < scope.buttons.length; x++) {
          textForIcon(scope.buttons[x].text);
        }
        textForIcon(scope.cancelText);
        textForIcon(scope.destructiveText);
        var element = scope.element = $compile('<ion-action-sheet ng-class="cssClass" buttons="buttons"></ion-action-sheet>')(scope);
        var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));
        var stateChangeListenDone = scope.cancelOnStateChange ? $rootScope.$on('$stateChangeSuccess', function() {
          scope.cancel();
        }) : noop;
        scope.removeSheet = function(done) {
          if (scope.removed)
            return;
          scope.removed = true;
          sheetEl.removeClass('action-sheet-up');
          $timeout(function() {
            $ionicBody.removeClass('action-sheet-open');
          }, 400);
          scope.$deregisterBackButton();
          stateChangeListenDone();
          $animate.removeClass(element, 'active').then(function() {
            scope.$destroy();
            element.remove();
            scope.cancel.$scope = sheetEl = null;
            (done || noop)(opts.buttons);
          });
        };
        scope.showSheet = function(done) {
          if (scope.removed)
            return;
          $ionicBody.append(element).addClass('action-sheet-open');
          $animate.addClass(element, 'active').then(function() {
            if (scope.removed)
              return;
            (done || noop)();
          });
          $timeout(function() {
            if (scope.removed)
              return;
            sheetEl.addClass('action-sheet-up');
          }, 20, false);
        };
        scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(function() {
          $timeout(scope.cancel);
        }, IONIC_BACK_PRIORITY.actionSheet);
        scope.cancel = function() {
          scope.removeSheet(opts.cancel);
        };
        scope.buttonClicked = function(index) {
          if (opts.buttonClicked(index, opts.buttons[index]) === true) {
            scope.removeSheet();
          }
        };
        scope.destructiveButtonClicked = function() {
          if (opts.destructiveButtonClicked() === true) {
            scope.removeSheet();
          }
        };
        scope.showSheet();
        scope.cancel.$scope = scope;
        return scope.cancel;
      }
    }]);
    jqLite.prototype.addClass = function(cssClasses) {
      var x,
          y,
          cssClass,
          el,
          splitClasses,
          existingClasses;
      if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {
        for (x = 0; x < this.length; x++) {
          el = this[x];
          if (el.setAttribute) {
            if (cssClasses.indexOf(' ') < 0 && el.classList.add) {
              el.classList.add(cssClasses);
            } else {
              existingClasses = (' ' + (el.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, " ");
              splitClasses = cssClasses.split(' ');
              for (y = 0; y < splitClasses.length; y++) {
                cssClass = splitClasses[y].trim();
                if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                  existingClasses += cssClass + ' ';
                }
              }
              el.setAttribute('class', existingClasses.trim());
            }
          }
        }
      }
      return this;
    };
    jqLite.prototype.removeClass = function(cssClasses) {
      var x,
          y,
          splitClasses,
          cssClass,
          el;
      if (cssClasses) {
        for (x = 0; x < this.length; x++) {
          el = this[x];
          if (el.getAttribute) {
            if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {
              el.classList.remove(cssClasses);
            } else {
              splitClasses = cssClasses.split(' ');
              for (y = 0; y < splitClasses.length; y++) {
                cssClass = splitClasses[y];
                el.setAttribute('class', ((" " + (el.getAttribute('class') || '') + " ").replace(/[\n\t]/g, " ").replace(" " + cssClass.trim() + " ", " ")).trim());
              }
            }
          }
        }
      }
      return this;
    };
    IonicModule.factory('$ionicBackdrop', ['$document', '$timeout', '$$rAF', '$rootScope', function($document, $timeout, $$rAF, $rootScope) {
      var el = jqLite('<div class="backdrop">');
      var backdropHolds = 0;
      $document[0].body.appendChild(el[0]);
      return {
        retain: retain,
        release: release,
        getElement: getElement,
        _element: el
      };
      function retain() {
        backdropHolds++;
        if (backdropHolds === 1) {
          el.addClass('visible');
          $rootScope.$broadcast('backdrop.shown');
          $$rAF(function() {
            if (backdropHolds >= 1)
              el.addClass('active');
          });
        }
      }
      function release() {
        if (backdropHolds === 1) {
          el.removeClass('active');
          $rootScope.$broadcast('backdrop.hidden');
          $timeout(function() {
            if (backdropHolds === 0)
              el.removeClass('visible');
          }, 400, false);
        }
        backdropHolds = Math.max(0, backdropHolds - 1);
      }
      function getElement() {
        return el;
      }
    }]);
    IonicModule.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {
      var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/;
      return function(scope, attrs, bindDefinition) {
        forEach(bindDefinition || {}, function(definition, scopeName) {
          var match = definition.match(LOCAL_REGEXP) || [],
              attrName = match[3] || scopeName,
              mode = match[1],
              parentGet,
              unwatch;
          switch (mode) {
            case '@':
              if (!attrs[attrName]) {
                return;
              }
              attrs.$observe(attrName, function(value) {
                scope[scopeName] = value;
              });
              if (attrs[attrName]) {
                scope[scopeName] = $interpolate(attrs[attrName])(scope);
              }
              break;
            case '=':
              if (!attrs[attrName]) {
                return;
              }
              unwatch = scope.$watch(attrs[attrName], function(value) {
                scope[scopeName] = value;
              });
              scope.$on('$destroy', unwatch);
              break;
            case '&':
              if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\(.*?\)'))) {
                throw new Error('& expression binding "' + scopeName + '" looks like it will recursively call "' + attrs[attrName] + '" and cause a stack overflow! Please choose a different scopeName.');
              }
              parentGet = $parse(attrs[attrName]);
              scope[scopeName] = function(locals) {
                return parentGet(scope, locals);
              };
              break;
          }
        });
      };
    }]);
    IonicModule.factory('$ionicBody', ['$document', function($document) {
      return {
        addClass: function() {
          for (var x = 0; x < arguments.length; x++) {
            $document[0].body.classList.add(arguments[x]);
          }
          return this;
        },
        removeClass: function() {
          for (var x = 0; x < arguments.length; x++) {
            $document[0].body.classList.remove(arguments[x]);
          }
          return this;
        },
        enableClass: function(shouldEnableClass) {
          var args = Array.prototype.slice.call(arguments).slice(1);
          if (shouldEnableClass) {
            this.addClass.apply(this, args);
          } else {
            this.removeClass.apply(this, args);
          }
          return this;
        },
        append: function(ele) {
          $document[0].body.appendChild(ele.length ? ele[0] : ele);
          return this;
        },
        get: function() {
          return $document[0].body;
        }
      };
    }]);
    IonicModule.factory('$ionicClickBlock', ['$document', '$ionicBody', '$timeout', function($document, $ionicBody, $timeout) {
      var CSS_HIDE = 'click-block-hide';
      var cbEle,
          fallbackTimer,
          pendingShow;
      function preventClick(ev) {
        ev.preventDefault();
        ev.stopPropagation();
      }
      function addClickBlock() {
        if (pendingShow) {
          if (cbEle) {
            cbEle.classList.remove(CSS_HIDE);
          } else {
            cbEle = $document[0].createElement('div');
            cbEle.className = 'click-block';
            $ionicBody.append(cbEle);
            cbEle.addEventListener('touchstart', preventClick);
            cbEle.addEventListener('mousedown', preventClick);
          }
          pendingShow = false;
        }
      }
      function removeClickBlock() {
        cbEle && cbEle.classList.add(CSS_HIDE);
      }
      return {
        show: function(autoExpire) {
          pendingShow = true;
          $timeout.cancel(fallbackTimer);
          fallbackTimer = $timeout(this.hide, autoExpire || 310, false);
          addClickBlock();
        },
        hide: function() {
          pendingShow = false;
          $timeout.cancel(fallbackTimer);
          removeClickBlock();
        }
      };
    }]);
    IonicModule.factory('$ionicGesture', [function() {
      return {
        on: function(eventType, cb, $element, options) {
          return window.ionic.onGesture(eventType, cb, $element[0], options);
        },
        off: function(gesture, eventType, cb) {
          return window.ionic.offGesture(gesture, eventType, cb);
        }
      };
    }]);
    IonicModule.factory('$ionicHistory', ['$rootScope', '$state', '$location', '$window', '$timeout', '$ionicViewSwitcher', '$ionicNavViewDelegate', function($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {
      var ACTION_INITIAL_VIEW = 'initialView';
      var ACTION_NEW_VIEW = 'newView';
      var ACTION_MOVE_BACK = 'moveBack';
      var ACTION_MOVE_FORWARD = 'moveForward';
      var DIRECTION_BACK = 'back';
      var DIRECTION_FORWARD = 'forward';
      var DIRECTION_ENTER = 'enter';
      var DIRECTION_EXIT = 'exit';
      var DIRECTION_SWAP = 'swap';
      var DIRECTION_NONE = 'none';
      var stateChangeCounter = 0;
      var lastStateId,
          nextViewOptions,
          deregisterStateChangeListener,
          nextViewExpireTimer,
          forcedNav;
      var viewHistory = {
        histories: {root: {
            historyId: 'root',
            parentHistoryId: null,
            stack: [],
            cursor: -1
          }},
        views: {},
        backView: null,
        forwardView: null,
        currentView: null
      };
      var View = function() {};
      View.prototype.initialize = function(data) {
        if (data) {
          for (var name in data)
            this[name] = data[name];
          return this;
        }
        return null;
      };
      View.prototype.go = function() {
        if (this.stateName) {
          return $state.go(this.stateName, this.stateParams);
        }
        if (this.url && this.url !== $location.url()) {
          if (viewHistory.backView === this) {
            return $window.history.go(-1);
          } else if (viewHistory.forwardView === this) {
            return $window.history.go(1);
          }
          $location.url(this.url);
        }
        return null;
      };
      View.prototype.destroy = function() {
        if (this.scope) {
          this.scope.$destroy && this.scope.$destroy();
          this.scope = null;
        }
      };
      function getViewById(viewId) {
        return (viewId ? viewHistory.views[viewId] : null);
      }
      function getBackView(view) {
        return (view ? getViewById(view.backViewId) : null);
      }
      function getForwardView(view) {
        return (view ? getViewById(view.forwardViewId) : null);
      }
      function getHistoryById(historyId) {
        return (historyId ? viewHistory.histories[historyId] : null);
      }
      function getHistory(scope) {
        var histObj = getParentHistoryObj(scope);
        if (!viewHistory.histories[histObj.historyId]) {
          viewHistory.histories[histObj.historyId] = {
            historyId: histObj.historyId,
            parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,
            stack: [],
            cursor: -1
          };
        }
        return getHistoryById(histObj.historyId);
      }
      function getParentHistoryObj(scope) {
        var parentScope = scope;
        while (parentScope) {
          if (parentScope.hasOwnProperty('$historyId')) {
            return {
              historyId: parentScope.$historyId,
              scope: parentScope
            };
          }
          parentScope = parentScope.$parent;
        }
        return {
          historyId: 'root',
          scope: $rootScope
        };
      }
      function setNavViews(viewId) {
        viewHistory.currentView = getViewById(viewId);
        viewHistory.backView = getBackView(viewHistory.currentView);
        viewHistory.forwardView = getForwardView(viewHistory.currentView);
      }
      function getCurrentStateId() {
        var id;
        if ($state && $state.current && $state.current.name) {
          id = $state.current.name;
          if ($state.params) {
            for (var key in $state.params) {
              if ($state.params.hasOwnProperty(key) && $state.params[key]) {
                id += "_" + key + "=" + $state.params[key];
              }
            }
          }
          return id;
        }
        return ionic.Utils.nextUid();
      }
      function getCurrentStateParams() {
        var rtn;
        if ($state && $state.params) {
          for (var key in $state.params) {
            if ($state.params.hasOwnProperty(key)) {
              rtn = rtn || {};
              rtn[key] = $state.params[key];
            }
          }
        }
        return rtn;
      }
      return {
        register: function(parentScope, viewLocals) {
          var currentStateId = getCurrentStateId(),
              hist = getHistory(parentScope),
              currentView = viewHistory.currentView,
              backView = viewHistory.backView,
              forwardView = viewHistory.forwardView,
              viewId = null,
              action = null,
              direction = DIRECTION_NONE,
              historyId = hist.historyId,
              url = $location.url(),
              tmp,
              x,
              ele;
          if (lastStateId !== currentStateId) {
            lastStateId = currentStateId;
            stateChangeCounter++;
          }
          if (forcedNav) {
            viewId = forcedNav.viewId;
            action = forcedNav.action;
            direction = forcedNav.direction;
            forcedNav = null;
          } else if (backView && backView.stateId === currentStateId) {
            viewId = backView.viewId;
            historyId = backView.historyId;
            action = ACTION_MOVE_BACK;
            if (backView.historyId === currentView.historyId) {
              direction = DIRECTION_BACK;
            } else if (currentView) {
              direction = DIRECTION_EXIT;
              tmp = getHistoryById(backView.historyId);
              if (tmp && tmp.parentHistoryId === currentView.historyId) {
                direction = DIRECTION_ENTER;
              } else {
                tmp = getHistoryById(currentView.historyId);
                if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                  direction = DIRECTION_SWAP;
                }
              }
            }
          } else if (forwardView && forwardView.stateId === currentStateId) {
            viewId = forwardView.viewId;
            historyId = forwardView.historyId;
            action = ACTION_MOVE_FORWARD;
            if (forwardView.historyId === currentView.historyId) {
              direction = DIRECTION_FORWARD;
            } else if (currentView) {
              direction = DIRECTION_EXIT;
              if (currentView.historyId === hist.parentHistoryId) {
                direction = DIRECTION_ENTER;
              } else {
                tmp = getHistoryById(currentView.historyId);
                if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                  direction = DIRECTION_SWAP;
                }
              }
            }
            tmp = getParentHistoryObj(parentScope);
            if (forwardView.historyId && tmp.scope) {
              tmp.scope.$historyId = forwardView.historyId;
              historyId = forwardView.historyId;
            }
          } else if (currentView && currentView.historyId !== historyId && hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length && hist.stack[hist.cursor].stateId === currentStateId) {
            var switchToView = hist.stack[hist.cursor];
            viewId = switchToView.viewId;
            historyId = switchToView.historyId;
            action = ACTION_MOVE_BACK;
            direction = DIRECTION_SWAP;
            tmp = getHistoryById(currentView.historyId);
            if (tmp && tmp.parentHistoryId === historyId) {
              direction = DIRECTION_EXIT;
            } else {
              tmp = getHistoryById(historyId);
              if (tmp && tmp.parentHistoryId === currentView.historyId) {
                direction = DIRECTION_ENTER;
              }
            }
            tmp = getViewById(switchToView.backViewId);
            if (tmp && switchToView.historyId !== tmp.historyId) {
              hist.stack[hist.cursor].backViewId = currentView.viewId;
            }
          } else {
            ele = $ionicViewSwitcher.createViewEle(viewLocals);
            if (this.isAbstractEle(ele, viewLocals)) {
              void 0;
              return {
                action: 'abstractView',
                direction: DIRECTION_NONE,
                ele: ele
              };
            }
            viewId = ionic.Utils.nextUid();
            if (currentView) {
              currentView.forwardViewId = viewId;
              action = ACTION_NEW_VIEW;
              if (forwardView && currentView.stateId !== forwardView.stateId && currentView.historyId === forwardView.historyId) {
                tmp = getHistoryById(forwardView.historyId);
                if (tmp) {
                  for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {
                    var stackItem = tmp.stack[x];
                    stackItem && stackItem.destroy && stackItem.destroy();
                    tmp.stack.splice(x);
                  }
                  historyId = forwardView.historyId;
                }
              }
              if (hist.historyId === currentView.historyId) {
                direction = DIRECTION_FORWARD;
              } else if (currentView.historyId !== hist.historyId) {
                direction = DIRECTION_ENTER;
                tmp = getHistoryById(currentView.historyId);
                if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {
                  direction = DIRECTION_SWAP;
                } else {
                  tmp = getHistoryById(tmp.parentHistoryId);
                  if (tmp && tmp.historyId === hist.historyId) {
                    direction = DIRECTION_EXIT;
                  }
                }
              }
            } else {
              action = ACTION_INITIAL_VIEW;
            }
            if (stateChangeCounter < 2) {
              direction = DIRECTION_NONE;
            }
            viewHistory.views[viewId] = this.createView({
              viewId: viewId,
              index: hist.stack.length,
              historyId: hist.historyId,
              backViewId: (currentView && currentView.viewId ? currentView.viewId : null),
              forwardViewId: null,
              stateId: currentStateId,
              stateName: this.currentStateName(),
              stateParams: getCurrentStateParams(),
              url: url,
              canSwipeBack: canSwipeBack(ele, viewLocals)
            });
            hist.stack.push(viewHistory.views[viewId]);
          }
          deregisterStateChangeListener && deregisterStateChangeListener();
          $timeout.cancel(nextViewExpireTimer);
          if (nextViewOptions) {
            if (nextViewOptions.disableAnimate)
              direction = DIRECTION_NONE;
            if (nextViewOptions.disableBack)
              viewHistory.views[viewId].backViewId = null;
            if (nextViewOptions.historyRoot) {
              for (x = 0; x < hist.stack.length; x++) {
                if (hist.stack[x].viewId === viewId) {
                  hist.stack[x].index = 0;
                  hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;
                } else {
                  delete viewHistory.views[hist.stack[x].viewId];
                }
              }
              hist.stack = [viewHistory.views[viewId]];
            }
            nextViewOptions = null;
          }
          setNavViews(viewId);
          if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {
            for (x = 0; x < hist.stack.length; x++) {
              if (hist.stack[x].viewId == viewId) {
                action = 'dupNav';
                direction = DIRECTION_NONE;
                if (x > 0) {
                  hist.stack[x - 1].forwardViewId = null;
                }
                viewHistory.forwardView = null;
                viewHistory.currentView.index = viewHistory.backView.index;
                viewHistory.currentView.backViewId = viewHistory.backView.backViewId;
                viewHistory.backView = getBackView(viewHistory.backView);
                hist.stack.splice(x, 1);
                break;
              }
            }
          }
          void 0;
          hist.cursor = viewHistory.currentView.index;
          return {
            viewId: viewId,
            action: action,
            direction: direction,
            historyId: historyId,
            enableBack: this.enabledBack(viewHistory.currentView),
            isHistoryRoot: (viewHistory.currentView.index === 0),
            ele: ele
          };
        },
        registerHistory: function(scope) {
          scope.$historyId = ionic.Utils.nextUid();
        },
        createView: function(data) {
          var newView = new View();
          return newView.initialize(data);
        },
        getViewById: getViewById,
        viewHistory: function() {
          return viewHistory;
        },
        currentView: function(view) {
          if (arguments.length) {
            viewHistory.currentView = view;
          }
          return viewHistory.currentView;
        },
        currentHistoryId: function() {
          return viewHistory.currentView ? viewHistory.currentView.historyId : null;
        },
        currentTitle: function(val) {
          if (viewHistory.currentView) {
            if (arguments.length) {
              viewHistory.currentView.title = val;
            }
            return viewHistory.currentView.title;
          }
        },
        backView: function(view) {
          if (arguments.length) {
            viewHistory.backView = view;
          }
          return viewHistory.backView;
        },
        backTitle: function(view) {
          var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;
          return backView && backView.title;
        },
        forwardView: function(view) {
          if (arguments.length) {
            viewHistory.forwardView = view;
          }
          return viewHistory.forwardView;
        },
        currentStateName: function() {
          return ($state && $state.current ? $state.current.name : null);
        },
        isCurrentStateNavView: function(navView) {
          return !!($state && $state.current && $state.current.views && $state.current.views[navView]);
        },
        goToHistoryRoot: function(historyId) {
          if (historyId) {
            var hist = getHistoryById(historyId);
            if (hist && hist.stack.length) {
              if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {
                return;
              }
              forcedNav = {
                viewId: hist.stack[0].viewId,
                action: ACTION_MOVE_BACK,
                direction: DIRECTION_BACK
              };
              hist.stack[0].go();
            }
          }
        },
        goBack: function(backCount) {
          if (isDefined(backCount) && backCount !== -1) {
            if (backCount > -1)
              return;
            var currentHistory = viewHistory.histories[this.currentHistoryId()];
            var newCursor = currentHistory.cursor + backCount + 1;
            if (newCursor < 1) {
              newCursor = 1;
            }
            currentHistory.cursor = newCursor;
            setNavViews(currentHistory.stack[newCursor].viewId);
            var cursor = newCursor - 1;
            var clearStateIds = [];
            var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
            while (fwdView) {
              clearStateIds.push(fwdView.stateId || fwdView.viewId);
              cursor++;
              if (cursor >= currentHistory.stack.length)
                break;
              fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);
            }
            var self = this;
            if (clearStateIds.length) {
              $timeout(function() {
                self.clearCache(clearStateIds);
              }, 600);
            }
          }
          viewHistory.backView && viewHistory.backView.go();
        },
        enabledBack: function(view) {
          var backView = getBackView(view);
          return !!(backView && backView.historyId === view.historyId);
        },
        clearHistory: function() {
          var histories = viewHistory.histories,
              currentView = viewHistory.currentView;
          if (histories) {
            for (var historyId in histories) {
              if (histories[historyId].stack) {
                histories[historyId].stack = [];
                histories[historyId].cursor = -1;
              }
              if (currentView && currentView.historyId === historyId) {
                currentView.backViewId = currentView.forwardViewId = null;
                histories[historyId].stack.push(currentView);
              } else if (histories[historyId].destroy) {
                histories[historyId].destroy();
              }
            }
          }
          for (var viewId in viewHistory.views) {
            if (viewId !== currentView.viewId) {
              delete viewHistory.views[viewId];
            }
          }
          if (currentView) {
            setNavViews(currentView.viewId);
          }
        },
        clearCache: function(stateIds) {
          return $timeout(function() {
            $ionicNavViewDelegate._instances.forEach(function(instance) {
              instance.clearCache(stateIds);
            });
          });
        },
        nextViewOptions: function(opts) {
          deregisterStateChangeListener && deregisterStateChangeListener();
          if (arguments.length) {
            $timeout.cancel(nextViewExpireTimer);
            if (opts === null) {
              nextViewOptions = opts;
            } else {
              nextViewOptions = nextViewOptions || {};
              extend(nextViewOptions, opts);
              if (nextViewOptions.expire) {
                deregisterStateChangeListener = $rootScope.$on('$stateChangeSuccess', function() {
                  nextViewExpireTimer = $timeout(function() {
                    nextViewOptions = null;
                  }, nextViewOptions.expire);
                });
              }
            }
          }
          return nextViewOptions;
        },
        isAbstractEle: function(ele, viewLocals) {
          if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {
            return true;
          }
          return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));
        },
        isActiveScope: function(scope) {
          if (!scope)
            return false;
          var climbScope = scope;
          var currentHistoryId = this.currentHistoryId();
          var foundHistoryId;
          while (climbScope) {
            if (climbScope.$$disconnected) {
              return false;
            }
            if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {
              foundHistoryId = true;
            }
            if (currentHistoryId) {
              if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {
                return true;
              }
              if (climbScope.hasOwnProperty('$activeHistoryId')) {
                if (currentHistoryId == climbScope.$activeHistoryId) {
                  if (climbScope.hasOwnProperty('$historyId')) {
                    return true;
                  }
                  if (!foundHistoryId) {
                    return true;
                  }
                }
              }
            }
            if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {
              foundHistoryId = false;
            }
            climbScope = climbScope.$parent;
          }
          return currentHistoryId ? currentHistoryId == 'root' : true;
        }
      };
      function isAbstractTag(ele) {
        return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);
      }
      function canSwipeBack(ele, viewLocals) {
        if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {
          return false;
        }
        if (ele && ele.attr('can-swipe-back') === 'false') {
          return false;
        }
        return true;
      }
    }]).run(['$rootScope', '$state', '$location', '$document', '$ionicPlatform', '$ionicHistory', 'IONIC_BACK_PRIORITY', function($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {
      $rootScope.$on('$ionicView.beforeEnter', function() {
        ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();
      });
      $rootScope.$on('$ionicHistory.change', function(e, data) {
        if (!data)
          return null;
        var viewHistory = $ionicHistory.viewHistory();
        var hist = (data.historyId ? viewHistory.histories[data.historyId] : null);
        if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {
          var view = hist.stack[hist.cursor];
          return view.go(data);
        }
        if (!data.url && data.uiSref) {
          data.url = $state.href(data.uiSref);
        }
        if (data.url) {
          if (data.url.indexOf('#') === 0) {
            data.url = data.url.replace('#', '');
          }
          if (data.url !== $location.url()) {
            $location.url(data.url);
          }
        }
      });
      $rootScope.$ionicGoBack = function(backCount) {
        $ionicHistory.goBack(backCount);
      };
      $rootScope.$on('$ionicView.afterEnter', function(ev, data) {
        if (data && data.title) {
          $document[0].title = data.title;
        }
      });
      function onHardwareBackButton(e) {
        var backView = $ionicHistory.backView();
        if (backView) {
          backView.go();
        } else {
          ionic.Platform.exitApp();
        }
        e.preventDefault();
        return false;
      }
      $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.view);
    }]);
    IonicModule.provider('$ionicConfig', function() {
      var provider = this;
      provider.platform = {};
      var PLATFORM = 'platform';
      var configProperties = {
        views: {
          maxCache: PLATFORM,
          forwardCache: PLATFORM,
          transition: PLATFORM,
          swipeBackEnabled: PLATFORM,
          swipeBackHitWidth: PLATFORM
        },
        navBar: {
          alignTitle: PLATFORM,
          positionPrimaryButtons: PLATFORM,
          positionSecondaryButtons: PLATFORM,
          transition: PLATFORM
        },
        backButton: {
          icon: PLATFORM,
          text: PLATFORM,
          previousTitleText: PLATFORM
        },
        form: {
          checkbox: PLATFORM,
          toggle: PLATFORM
        },
        scrolling: {jsScrolling: PLATFORM},
        spinner: {icon: PLATFORM},
        tabs: {
          style: PLATFORM,
          position: PLATFORM
        },
        templates: {maxPrefetch: PLATFORM},
        platform: {}
      };
      createConfig(configProperties, provider, '');
      setPlatformConfig('default', {
        views: {
          maxCache: 10,
          forwardCache: false,
          transition: 'ios',
          swipeBackEnabled: true,
          swipeBackHitWidth: 45
        },
        navBar: {
          alignTitle: 'center',
          positionPrimaryButtons: 'left',
          positionSecondaryButtons: 'right',
          transition: 'view'
        },
        backButton: {
          icon: 'ion-ios-arrow-back',
          text: 'Back',
          previousTitleText: true
        },
        form: {
          checkbox: 'circle',
          toggle: 'large'
        },
        scrolling: {jsScrolling: true},
        spinner: {icon: 'ios'},
        tabs: {
          style: 'standard',
          position: 'bottom'
        },
        templates: {maxPrefetch: 30}
      });
      setPlatformConfig('ios', {});
      setPlatformConfig('android', {
        views: {
          transition: 'android',
          swipeBackEnabled: false
        },
        navBar: {
          alignTitle: 'left',
          positionPrimaryButtons: 'right',
          positionSecondaryButtons: 'right'
        },
        backButton: {
          icon: 'ion-android-arrow-back',
          text: false,
          previousTitleText: false
        },
        form: {
          checkbox: 'square',
          toggle: 'small'
        },
        spinner: {icon: 'android'},
        tabs: {
          style: 'striped',
          position: 'top'
        },
        scrolling: {jsScrolling: false}
      });
      setPlatformConfig('windowsphone', {spinner: {icon: 'android'}});
      provider.transitions = {
        views: {},
        navBar: {}
      };
      provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {
        function setStyles(ele, opacity, x, boxShadowOpacity) {
          var css = {};
          css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
          css.opacity = opacity;
          if (boxShadowOpacity > -1) {
            css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';
          }
          css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
          ionic.DomUtil.cachedStyles(ele, css);
        }
        var d = {
          run: function(step) {
            if (direction == 'forward') {
              setStyles(enteringEle, 1, (1 - step) * 99, 1 - step);
              setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);
            } else if (direction == 'back') {
              setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);
              setStyles(leavingEle, 1, step * 100, 1 - step);
            } else {
              setStyles(enteringEle, 1, 0, -1);
              setStyles(leavingEle, 0, 0, -1);
            }
          },
          shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
        };
        return d;
      };
      provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
        function setStyles(ctrl, opacity, titleX, backTextX) {
          var css = {};
          css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';
          css.opacity = opacity === 1 ? '' : opacity;
          ctrl.setCss('buttons-left', css);
          ctrl.setCss('buttons-right', css);
          ctrl.setCss('back-button', css);
          css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';
          ctrl.setCss('back-text', css);
          css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';
          ctrl.setCss('title', css);
        }
        function enter(ctrlA, ctrlB, step) {
          if (!ctrlA || !ctrlB)
            return;
          var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);
          var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;
          setStyles(ctrlA, step, titleX, backTextX);
        }
        function leave(ctrlA, ctrlB, step) {
          if (!ctrlA || !ctrlB)
            return;
          var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;
          setStyles(ctrlA, 1 - step, titleX, 0);
        }
        var d = {
          run: function(step) {
            var enteringHeaderCtrl = enteringHeaderBar.controller();
            var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();
            if (d.direction == 'back') {
              leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);
              enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);
            } else {
              enter(enteringHeaderCtrl, leavingHeaderCtrl, step);
              leave(leavingHeaderCtrl, enteringHeaderCtrl, step);
            }
          },
          direction: direction,
          shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
        };
        return d;
      };
      provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {
        shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');
        function setStyles(ele, x) {
          var css = {};
          css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;
          css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';
          ionic.DomUtil.cachedStyles(ele, css);
        }
        var d = {
          run: function(step) {
            if (direction == 'forward') {
              setStyles(enteringEle, (1 - step) * 99);
              setStyles(leavingEle, step * -100);
            } else if (direction == 'back') {
              setStyles(enteringEle, (1 - step) * -100);
              setStyles(leavingEle, step * 100);
            } else {
              setStyles(enteringEle, 0);
              setStyles(leavingEle, 0);
            }
          },
          shouldAnimate: shouldAnimate
        };
        return d;
      };
      provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {
        function setStyles(ctrl, opacity) {
          if (!ctrl)
            return;
          var css = {};
          css.opacity = opacity === 1 ? '' : opacity;
          ctrl.setCss('buttons-left', css);
          ctrl.setCss('buttons-right', css);
          ctrl.setCss('back-button', css);
          ctrl.setCss('back-text', css);
          ctrl.setCss('title', css);
        }
        return {
          run: function(step) {
            setStyles(enteringHeaderBar.controller(), step);
            setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);
          },
          shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')
        };
      };
      provider.transitions.views.none = function(enteringEle, leavingEle) {
        return {
          run: function(step) {
            provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);
          },
          shouldAnimate: false
        };
      };
      provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {
        return {
          run: function(step) {
            provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
            provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);
          },
          shouldAnimate: false
        };
      };
      function setPlatformConfig(platformName, platformConfigs) {
        configProperties.platform[platformName] = platformConfigs;
        provider.platform[platformName] = {};
        addConfig(configProperties, configProperties.platform[platformName]);
        createConfig(configProperties.platform[platformName], provider.platform[platformName], '');
      }
      function addConfig(configObj, platformObj) {
        for (var n in configObj) {
          if (n != PLATFORM && configObj.hasOwnProperty(n)) {
            if (angular.isObject(configObj[n])) {
              if (!isDefined(platformObj[n])) {
                platformObj[n] = {};
              }
              addConfig(configObj[n], platformObj[n]);
            } else if (!isDefined(platformObj[n])) {
              platformObj[n] = null;
            }
          }
        }
      }
      function createConfig(configObj, providerObj, platformPath) {
        forEach(configObj, function(value, namespace) {
          if (angular.isObject(configObj[namespace])) {
            providerObj[namespace] = {};
            createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);
          } else {
            providerObj[namespace] = function(newValue) {
              if (arguments.length) {
                configObj[namespace] = newValue;
                return providerObj;
              }
              if (configObj[namespace] == PLATFORM) {
                var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);
                if (platformConfig || platformConfig === false) {
                  return platformConfig;
                }
                return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);
              }
              return configObj[namespace];
            };
          }
        });
      }
      function stringObj(obj, str) {
        str = str.split(".");
        for (var i = 0; i < str.length; i++) {
          if (obj && isDefined(obj[str[i]])) {
            obj = obj[str[i]];
          } else {
            return null;
          }
        }
        return obj;
      }
      provider.setPlatformConfig = setPlatformConfig;
      provider.$get = function() {
        return provider;
      };
    }).config(['$compileProvider', function($compileProvider) {
      $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|sms|tel|geo|ftp|mailto|file|ghttps?|ms-appx-web|ms-appx|x-wmapp0):/);
      $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|content|blob|ms-appx|ms-appx-web|x-wmapp0):|data:image\//);
    }]);
    var LOADING_TPL = '<div class="loading-container">' + '<div class="loading">' + '</div>' + '</div>';
    var LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';
    var LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';
    var LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \'my content\' }).';
    IonicModule.constant('$ionicLoadingConfig', {template: '<ion-spinner></ion-spinner>'}).factory('$ionicLoading', ['$ionicLoadingConfig', '$ionicBody', '$ionicTemplateLoader', '$ionicBackdrop', '$timeout', '$q', '$log', '$compile', '$ionicPlatform', '$rootScope', 'IONIC_BACK_PRIORITY', function($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {
      var loaderInstance;
      var deregisterBackAction = noop;
      var deregisterStateListener1 = noop;
      var deregisterStateListener2 = noop;
      var loadingShowDelay = $q.when();
      return {
        show: showLoader,
        hide: hideLoader,
        _getLoader: getLoader
      };
      function getLoader() {
        if (!loaderInstance) {
          loaderInstance = $ionicTemplateLoader.compile({
            template: LOADING_TPL,
            appendTo: $ionicBody.get()
          }).then(function(self) {
            self.show = function(options) {
              var templatePromise = options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : $q.when(options.template || options.content || '');
              self.scope = options.scope || self.scope;
              if (!self.isShown) {
                self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;
                if (self.hasBackdrop) {
                  $ionicBackdrop.retain();
                  $ionicBackdrop.getElement().addClass('backdrop-loading');
                }
              }
              if (options.duration) {
                $timeout.cancel(self.durationTimeout);
                self.durationTimeout = $timeout(angular.bind(self, self.hide), +options.duration);
              }
              deregisterBackAction();
              deregisterBackAction = $ionicPlatform.registerBackButtonAction(noop, IONIC_BACK_PRIORITY.loading);
              templatePromise.then(function(html) {
                if (html) {
                  var loading = self.element.children();
                  loading.html(html);
                  $compile(loading.contents())(self.scope);
                }
                if (self.isShown) {
                  self.element.addClass('visible');
                  ionic.requestAnimationFrame(function() {
                    if (self.isShown) {
                      self.element.addClass('active');
                      $ionicBody.addClass('loading-active');
                    }
                  });
                }
              });
              self.isShown = true;
            };
            self.hide = function() {
              deregisterBackAction();
              if (self.isShown) {
                if (self.hasBackdrop) {
                  $ionicBackdrop.release();
                  $ionicBackdrop.getElement().removeClass('backdrop-loading');
                }
                self.element.removeClass('active');
                $ionicBody.removeClass('loading-active');
                self.element.removeClass('visible');
                ionic.requestAnimationFrame(function() {
                  !self.isShown && self.element.removeClass('visible');
                });
              }
              $timeout.cancel(self.durationTimeout);
              self.isShown = false;
              var loading = self.element.children();
              loading.html("");
            };
            return self;
          });
        }
        return loaderInstance;
      }
      function showLoader(options) {
        options = extend({}, $ionicLoadingConfig || {}, options || {});
        var delay = options.delay || options.showDelay || 0;
        deregisterStateListener1();
        deregisterStateListener2();
        if (options.hideOnStateChange) {
          deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);
          deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);
        }
        $timeout.cancel(loadingShowDelay);
        loadingShowDelay = $timeout(noop, delay);
        loadingShowDelay.then(getLoader).then(function(loader) {
          return loader.show(options);
        });
        return {
          hide: function deprecatedHide() {
            $log.error(LOADING_HIDE_DEPRECATED);
            return hideLoader.apply(this, arguments);
          },
          show: function deprecatedShow() {
            $log.error(LOADING_SHOW_DEPRECATED);
            return showLoader.apply(this, arguments);
          },
          setContent: function deprecatedSetContent(content) {
            $log.error(LOADING_SET_DEPRECATED);
            return getLoader().then(function(loader) {
              loader.show({template: content});
            });
          }
        };
      }
      function hideLoader() {
        deregisterStateListener1();
        deregisterStateListener2();
        $timeout.cancel(loadingShowDelay);
        getLoader().then(function(loader) {
          loader.hide();
        });
      }
    }]);
    IonicModule.factory('$ionicModal', ['$rootScope', '$ionicBody', '$compile', '$timeout', '$ionicPlatform', '$ionicTemplateLoader', '$$q', '$log', '$ionicClickBlock', '$window', 'IONIC_BACK_PRIORITY', function($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {
      var ModalView = ionic.views.Modal.inherit({
        initialize: function(opts) {
          ionic.views.Modal.prototype.initialize.call(this, opts);
          this.animation = opts.animation || 'slide-in-up';
        },
        show: function(target) {
          var self = this;
          if (self.scope.$$destroyed) {
            $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');
            return $$q.when();
          }
          $ionicClickBlock.show(600);
          stack.add(self);
          var modalEl = jqLite(self.modalEl);
          self.el.classList.remove('hide');
          $timeout(function() {
            if (!self._isShown)
              return;
            $ionicBody.addClass(self.viewType + '-open');
          }, 400, false);
          if (!self.el.parentElement) {
            modalEl.addClass(self.animation);
            $ionicBody.append(self.el);
          }
          var scrollCtrl = modalEl.data('$$ionicScrollController');
          scrollCtrl && scrollCtrl.resize();
          if (target && self.positionView) {
            self.positionView(target, modalEl);
            self._onWindowResize = function() {
              if (self._isShown)
                self.positionView(target, modalEl);
            };
            ionic.on('resize', self._onWindowResize, window);
          }
          modalEl.addClass('ng-enter active').removeClass('ng-leave ng-leave-active');
          self._isShown = true;
          self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop, IONIC_BACK_PRIORITY.modal);
          ionic.views.Modal.prototype.show.call(self);
          $timeout(function() {
            if (!self._isShown)
              return;
            modalEl.addClass('ng-enter-active');
            ionic.trigger('resize');
            self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);
            self.el.classList.add('active');
            self.scope.$broadcast('$ionicHeader.align');
            self.scope.$broadcast('$ionicFooter.align');
          }, 20);
          return $timeout(function() {
            if (!self._isShown)
              return;
            self.$el.on('touchmove', function(e) {
              var isInScroll = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'scroll');
              if (!isInScroll) {
                e.preventDefault();
              }
            });
            self.$el.on('click', function(e) {
              if (self.backdropClickToClose && e.target === self.el && stack.isHighest(self)) {
                self.hide();
              }
            });
          }, 400);
        },
        hide: function() {
          var self = this;
          var modalEl = jqLite(self.modalEl);
          $ionicClickBlock.show(600);
          stack.remove(self);
          self.el.classList.remove('active');
          modalEl.addClass('ng-leave');
          $timeout(function() {
            if (self._isShown)
              return;
            modalEl.addClass('ng-leave-active').removeClass('ng-enter ng-enter-active active');
          }, 20, false);
          self.$el.off('click');
          self._isShown = false;
          self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);
          self._deregisterBackButton && self._deregisterBackButton();
          ionic.views.Modal.prototype.hide.call(self);
          if (self.positionView) {
            ionic.off('resize', self._onWindowResize, window);
          }
          return $timeout(function() {
            $ionicBody.removeClass(self.viewType + '-open');
            self.el.classList.add('hide');
          }, self.hideDelay || 320);
        },
        remove: function() {
          var self = this;
          self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);
          return self.hide().then(function() {
            self.scope.$destroy();
            self.$el.remove();
          });
        },
        isShown: function() {
          return !!this._isShown;
        }
      });
      var createModal = function(templateString, options) {
        var scope = options.scope && options.scope.$new() || $rootScope.$new(true);
        options.viewType = options.viewType || 'modal';
        extend(scope, {
          $hasHeader: false,
          $hasSubheader: false,
          $hasFooter: false,
          $hasSubfooter: false,
          $hasTabs: false,
          $hasTabsTop: false
        });
        var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);
        options.$el = element;
        options.el = element[0];
        options.modalEl = options.el.querySelector('.' + options.viewType);
        var modal = new ModalView(options);
        modal.scope = scope;
        if (!options.scope) {
          scope[options.viewType] = modal;
        }
        return modal;
      };
      var modalStack = [];
      var stack = {
        add: function(modal) {
          modalStack.push(modal);
        },
        remove: function(modal) {
          var index = modalStack.indexOf(modal);
          if (index > -1 && index < modalStack.length) {
            modalStack.splice(index, 1);
          }
        },
        isHighest: function(modal) {
          var index = modalStack.indexOf(modal);
          return (index > -1 && index === modalStack.length - 1);
        }
      };
      return {
        fromTemplate: function(templateString, options) {
          var modal = createModal(templateString, options || {});
          return modal;
        },
        fromTemplateUrl: function(url, options, _) {
          var cb;
          if (angular.isFunction(options)) {
            cb = options;
            options = _;
          }
          return $ionicTemplateLoader.load(url).then(function(templateString) {
            var modal = createModal(templateString, options || {});
            cb && cb(modal);
            return modal;
          });
        },
        stack: stack
      };
    }]);
    IonicModule.service('$ionicNavBarDelegate', ionic.DelegateService(['align', 'showBackButton', 'showBar', 'title', 'changeTitle', 'setTitle', 'getTitle', 'back', 'getPreviousTitle']));
    IonicModule.service('$ionicNavViewDelegate', ionic.DelegateService(['clearCache']));
    IonicModule.constant('IONIC_BACK_PRIORITY', {
      view: 100,
      sideMenu: 150,
      modal: 200,
      actionSheet: 300,
      popup: 400,
      loading: 500
    }).provider('$ionicPlatform', function() {
      return {$get: ['$q', '$ionicScrollDelegate', function($q, $ionicScrollDelegate) {
          var self = {
            onHardwareBackButton: function(cb) {
              ionic.Platform.ready(function() {
                document.addEventListener('backbutton', cb, false);
              });
            },
            offHardwareBackButton: function(fn) {
              ionic.Platform.ready(function() {
                document.removeEventListener('backbutton', fn);
              });
            },
            $backButtonActions: {},
            registerBackButtonAction: function(fn, priority, actionId) {
              if (!self._hasBackButtonHandler) {
                self.$backButtonActions = {};
                self.onHardwareBackButton(self.hardwareBackButtonClick);
                self._hasBackButtonHandler = true;
              }
              var action = {
                id: (actionId ? actionId : ionic.Utils.nextUid()),
                priority: (priority ? priority : 0),
                fn: fn
              };
              self.$backButtonActions[action.id] = action;
              return function() {
                delete self.$backButtonActions[action.id];
              };
            },
            hardwareBackButtonClick: function(e) {
              var priorityAction,
                  actionId;
              for (actionId in self.$backButtonActions) {
                if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {
                  priorityAction = self.$backButtonActions[actionId];
                }
              }
              if (priorityAction) {
                priorityAction.fn(e);
                return priorityAction;
              }
            },
            is: function(type) {
              return ionic.Platform.is(type);
            },
            on: function(type, cb) {
              ionic.Platform.ready(function() {
                document.addEventListener(type, cb, false);
              });
              return function() {
                ionic.Platform.ready(function() {
                  document.removeEventListener(type, cb);
                });
              };
            },
            ready: function(cb) {
              var q = $q.defer();
              ionic.Platform.ready(function() {
                q.resolve();
                cb && cb();
              });
              return q.promise;
            }
          };
          window.addEventListener('statusTap', function() {
            $ionicScrollDelegate.scrollTop(true);
          });
          return self;
        }]};
    });
    IonicModule.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window', function($ionicModal, $ionicPosition, $document, $window) {
      var POPOVER_BODY_PADDING = 6;
      var POPOVER_OPTIONS = {
        viewType: 'popover',
        hideDelay: 1,
        animation: 'none',
        positionView: positionView
      };
      function positionView(target, popoverEle) {
        var targetEle = jqLite(target.target || target);
        var buttonOffset = $ionicPosition.offset(targetEle);
        var popoverWidth = popoverEle.prop('offsetWidth');
        var popoverHeight = popoverEle.prop('offsetHeight');
        var bodyWidth = $window.innerWidth;
        var bodyHeight = $window.innerHeight;
        var popoverCSS = {left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2};
        var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));
        if (popoverCSS.left < POPOVER_BODY_PADDING) {
          popoverCSS.left = POPOVER_BODY_PADDING;
        } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {
          popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;
        }
        if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight && buttonOffset.top - popoverHeight > 0) {
          popoverCSS.top = buttonOffset.top - popoverHeight;
          popoverEle.addClass('popover-bottom');
        } else {
          popoverCSS.top = buttonOffset.top + buttonOffset.height;
          popoverEle.removeClass('popover-bottom');
        }
        arrowEle.css({left: buttonOffset.left + buttonOffset.width / 2 - arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'});
        popoverEle.css({
          top: popoverCSS.top + 'px',
          left: popoverCSS.left + 'px',
          marginLeft: '0',
          opacity: '1'
        });
      }
      return {
        fromTemplate: function(templateString, options) {
          return $ionicModal.fromTemplate(templateString, ionic.Utils.extend({}, POPOVER_OPTIONS, options));
        },
        fromTemplateUrl: function(url, options) {
          return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend({}, POPOVER_OPTIONS, options));
        }
      };
    }]);
    var POPUP_TPL = '<div class="popup-container" ng-class="cssClass">' + '<div class="popup">' + '<div class="popup-head">' + '<h3 class="popup-title" ng-bind-html="title"></h3>' + '<h5 class="popup-sub-title" ng-bind-html="subTitle" ng-if="subTitle"></h5>' + '</div>' + '<div class="popup-body">' + '</div>' + '<div class="popup-buttons" ng-show="buttons.length">' + '<button ng-repeat="button in buttons" ng-click="$buttonTapped(button, $event)" class="button" ng-class="button.type || \'button-default\'" ng-bind-html="button.text"></button>' + '</div>' + '</div>' + '</div>';
    IonicModule.factory('$ionicPopup', ['$ionicTemplateLoader', '$ionicBackdrop', '$q', '$timeout', '$rootScope', '$ionicBody', '$compile', '$ionicPlatform', '$ionicModal', 'IONIC_BACK_PRIORITY', function($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {
      var config = {stackPushDelay: 75};
      var popupStack = [];
      var $ionicPopup = {
        show: showPopup,
        alert: showAlert,
        confirm: showConfirm,
        prompt: showPrompt,
        _createPopup: createPopup,
        _popupStack: popupStack
      };
      return $ionicPopup;
      function createPopup(options) {
        options = extend({
          scope: null,
          title: '',
          buttons: []
        }, options || {});
        var self = {};
        self.scope = (options.scope || $rootScope).$new();
        self.element = jqLite(POPUP_TPL);
        self.responseDeferred = $q.defer();
        $ionicBody.get().appendChild(self.element[0]);
        $compile(self.element)(self.scope);
        extend(self.scope, {
          title: options.title,
          buttons: options.buttons,
          subTitle: options.subTitle,
          cssClass: options.cssClass,
          $buttonTapped: function(button, event) {
            var result = (button.onTap || noop).apply(self, [event]);
            event = event.originalEvent || event;
            if (!event.defaultPrevented) {
              self.responseDeferred.resolve(result);
            }
          }
        });
        $q.when(options.templateUrl ? $ionicTemplateLoader.load(options.templateUrl) : (options.template || options.content || '')).then(function(template) {
          var popupBody = jqLite(self.element[0].querySelector('.popup-body'));
          if (template) {
            popupBody.html(template);
            $compile(popupBody.contents())(self.scope);
          } else {
            popupBody.remove();
          }
        });
        self.show = function() {
          if (self.isShown || self.removed)
            return;
          $ionicModal.stack.add(self);
          self.isShown = true;
          ionic.requestAnimationFrame(function() {
            if (!self.isShown)
              return;
            self.element.removeClass('popup-hidden');
            self.element.addClass('popup-showing active');
            focusInput(self.element);
          });
        };
        self.hide = function(callback) {
          callback = callback || noop;
          if (!self.isShown)
            return callback();
          $ionicModal.stack.remove(self);
          self.isShown = false;
          self.element.removeClass('active');
          self.element.addClass('popup-hidden');
          $timeout(callback, 250, false);
        };
        self.remove = function() {
          if (self.removed)
            return;
          self.hide(function() {
            self.element.remove();
            self.scope.$destroy();
          });
          self.removed = true;
        };
        return self;
      }
      function onHardwareBackButton() {
        var last = popupStack[popupStack.length - 1];
        last && last.responseDeferred.resolve();
      }
      function showPopup(options) {
        var popup = $ionicPopup._createPopup(options);
        var showDelay = 0;
        if (popupStack.length > 0) {
          showDelay = config.stackPushDelay;
          $timeout(popupStack[popupStack.length - 1].hide, showDelay, false);
        } else {
          $ionicBody.addClass('popup-open');
          $ionicBackdrop.retain();
          $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(onHardwareBackButton, IONIC_BACK_PRIORITY.popup);
        }
        popup.responseDeferred.promise.close = function popupClose(result) {
          if (!popup.removed)
            popup.responseDeferred.resolve(result);
        };
        popup.responseDeferred.notify({close: popup.responseDeferred.close});
        doShow();
        return popup.responseDeferred.promise;
        function doShow() {
          popupStack.push(popup);
          $timeout(popup.show, showDelay, false);
          popup.responseDeferred.promise.then(function(result) {
            var index = popupStack.indexOf(popup);
            if (index !== -1) {
              popupStack.splice(index, 1);
            }
            popup.remove();
            if (popupStack.length > 0) {
              popupStack[popupStack.length - 1].show();
            } else {
              $ionicBackdrop.release();
              $timeout(function() {
                if (!popupStack.length) {
                  $ionicBody.removeClass('popup-open');
                }
              }, 400, false);
              ($ionicPopup._backButtonActionDone || noop)();
            }
            return result;
          });
        }
      }
      function focusInput(element) {
        var focusOn = element[0].querySelector('[autofocus]');
        if (focusOn) {
          focusOn.focus();
        }
      }
      function showAlert(opts) {
        return showPopup(extend({buttons: [{
            text: opts.okText || 'OK',
            type: opts.okType || 'button-positive',
            onTap: function() {
              return true;
            }
          }]}, opts || {}));
      }
      function showConfirm(opts) {
        return showPopup(extend({buttons: [{
            text: opts.cancelText || 'Cancel',
            type: opts.cancelType || 'button-default',
            onTap: function() {
              return false;
            }
          }, {
            text: opts.okText || 'OK',
            type: opts.okType || 'button-positive',
            onTap: function() {
              return true;
            }
          }]}, opts || {}));
      }
      function showPrompt(opts) {
        var scope = $rootScope.$new(true);
        scope.data = {};
        scope.data.fieldtype = opts.inputType ? opts.inputType : 'text';
        scope.data.response = opts.defaultText ? opts.defaultText : '';
        scope.data.placeholder = opts.inputPlaceholder ? opts.inputPlaceholder : '';
        scope.data.maxlength = opts.maxLength ? parseInt(opts.maxLength) : '';
        var text = '';
        if (opts.template && /<[a-z][\s\S]*>/i.test(opts.template) === false) {
          text = '<span>' + opts.template + '</span>';
          delete opts.template;
        }
        return showPopup(extend({
          template: text + '<input ng-model="data.response" ' + 'type="{{ data.fieldtype }}"' + 'maxlength="{{ data.maxlength }}"' + 'placeholder="{{ data.placeholder }}"' + '>',
          scope: scope,
          buttons: [{
            text: opts.cancelText || 'Cancel',
            type: opts.cancelType || 'button-default',
            onTap: function() {}
          }, {
            text: opts.okText || 'OK',
            type: opts.okType || 'button-positive',
            onTap: function() {
              return scope.data.response || '';
            }
          }]
        }, opts || {}));
      }
    }]);
    IonicModule.factory('$ionicPosition', ['$document', '$window', function($document, $window) {
      function getStyle(el, cssprop) {
        if (el.currentStyle) {
          return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
          return $window.getComputedStyle(el)[cssprop];
        }
        return el.style[cssprop];
      }
      function isStaticPositioned(element) {
        return (getStyle(element, 'position') || 'static') === 'static';
      }
      var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
      };
      return {
        position: function(element) {
          var elBCR = this.offset(element);
          var offsetParentBCR = {
            top: 0,
            left: 0
          };
          var offsetParentEl = parentOffsetEl(element[0]);
          if (offsetParentEl != $document[0]) {
            offsetParentBCR = this.offset(jqLite(offsetParentEl));
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
            offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
          }
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: elBCR.top - offsetParentBCR.top,
            left: elBCR.left - offsetParentBCR.left
          };
        },
        offset: function(element) {
          var boundingClientRect = element[0].getBoundingClientRect();
          return {
            width: boundingClientRect.width || element.prop('offsetWidth'),
            height: boundingClientRect.height || element.prop('offsetHeight'),
            top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
            left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
          };
        }
      };
    }]);
    IonicModule.service('$ionicScrollDelegate', ionic.DelegateService(['resize', 'scrollTop', 'scrollBottom', 'scrollTo', 'scrollBy', 'zoomTo', 'zoomBy', 'getScrollPosition', 'anchorScroll', 'freezeScroll', 'freezeAllScrolls', 'getScrollView']));
    IonicModule.service('$ionicSideMenuDelegate', ionic.DelegateService(['toggleLeft', 'toggleRight', 'getOpenRatio', 'isOpen', 'isOpenLeft', 'isOpenRight', 'canDragContent', 'edgeDragThreshold']));
    IonicModule.service('$ionicSlideBoxDelegate', ionic.DelegateService(['update', 'slide', 'select', 'enableSlide', 'previous', 'next', 'stop', 'autoPlay', 'start', 'currentIndex', 'selected', 'slidesCount', 'count', 'loop']));
    IonicModule.service('$ionicTabsDelegate', ionic.DelegateService(['select', 'selectedIndex', 'showBar']));
    (function() {
      var templatesToCache = [];
      IonicModule.factory('$ionicTemplateCache', ['$http', '$templateCache', '$timeout', function($http, $templateCache, $timeout) {
        var toCache = templatesToCache,
            hasRun;
        function $ionicTemplateCache(templates) {
          if (typeof templates === 'undefined') {
            return run();
          }
          if (isString(templates)) {
            templates = [templates];
          }
          forEach(templates, function(template) {
            toCache.push(template);
          });
          if (hasRun) {
            run();
          }
        }
        function run() {
          var template;
          $ionicTemplateCache._runCount++;
          hasRun = true;
          if (toCache.length === 0)
            return;
          var i = 0;
          while (i < 4 && (template = toCache.pop())) {
            if (isString(template))
              $http.get(template, {cache: $templateCache});
            i++;
          }
          if (toCache.length) {
            $timeout(run, 1000);
          }
        }
        $ionicTemplateCache._runCount = 0;
        return $ionicTemplateCache;
      }]).config(['$stateProvider', '$ionicConfigProvider', function($stateProvider, $ionicConfigProvider) {
        var stateProviderState = $stateProvider.state;
        $stateProvider.state = function(stateName, definition) {
          if (typeof definition === 'object') {
            var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
            if (enabled && isString(definition.templateUrl))
              templatesToCache.push(definition.templateUrl);
            if (angular.isObject(definition.views)) {
              for (var key in definition.views) {
                enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();
                if (enabled && isString(definition.views[key].templateUrl))
                  templatesToCache.push(definition.views[key].templateUrl);
              }
            }
          }
          return stateProviderState.call($stateProvider, stateName, definition);
        };
      }]).run(['$ionicTemplateCache', function($ionicTemplateCache) {
        $ionicTemplateCache();
      }]);
    })();
    IonicModule.factory('$ionicTemplateLoader', ['$compile', '$controller', '$http', '$q', '$rootScope', '$templateCache', function($compile, $controller, $http, $q, $rootScope, $templateCache) {
      return {
        load: fetchTemplate,
        compile: loadAndCompile
      };
      function fetchTemplate(url) {
        return $http.get(url, {cache: $templateCache}).then(function(response) {
          return response.data && response.data.trim();
        });
      }
      function loadAndCompile(options) {
        options = extend({
          template: '',
          templateUrl: '',
          scope: null,
          controller: null,
          locals: {},
          appendTo: null
        }, options || {});
        var templatePromise = options.templateUrl ? this.load(options.templateUrl) : $q.when(options.template);
        return templatePromise.then(function(template) {
          var controller;
          var scope = options.scope || $rootScope.$new();
          var element = jqLite('<div>').html(template).contents();
          if (options.controller) {
            controller = $controller(options.controller, extend(options.locals, {$scope: scope}));
            element.children().data('$ngControllerController', controller);
          }
          if (options.appendTo) {
            jqLite(options.appendTo).append(element);
          }
          $compile(element)(scope);
          return {
            element: element,
            scope: scope
          };
        });
      }
    }]);
    IonicModule.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {
      function warn(oldMethod, newMethod) {
        $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');
      }
      warn('', '');
      var methodsMap = {
        getCurrentView: 'currentView',
        getBackView: 'backView',
        getForwardView: 'forwardView',
        getCurrentStateName: 'currentStateName',
        nextViewOptions: 'nextViewOptions',
        clearHistory: 'clearHistory'
      };
      forEach(methodsMap, function(newMethod, oldMethod) {
        methodsMap[oldMethod] = function() {
          warn('.' + oldMethod, '.' + newMethod);
          return $ionicHistory[newMethod].apply(this, arguments);
        };
      });
      return methodsMap;
    }]);
    IonicModule.factory('$ionicViewSwitcher', ['$timeout', '$document', '$q', '$ionicClickBlock', '$ionicConfig', '$ionicNavBarDelegate', function($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {
      var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
      var DATA_NO_CACHE = '$noCache';
      var DATA_DESTROY_ELE = '$destroyEle';
      var DATA_ELE_IDENTIFIER = '$eleId';
      var DATA_VIEW_ACCESSED = '$accessed';
      var DATA_FALLBACK_TIMER = '$fallbackTimer';
      var DATA_VIEW = '$viewData';
      var NAV_VIEW_ATTR = 'nav-view';
      var VIEW_STATUS_ACTIVE = 'active';
      var VIEW_STATUS_CACHED = 'cached';
      var VIEW_STATUS_STAGED = 'stage';
      var transitionCounter = 0;
      var nextTransition,
          nextDirection;
      ionic.transition = ionic.transition || {};
      ionic.transition.isActive = false;
      var isActiveTimer;
      var cachedAttr = ionic.DomUtil.cachedAttr;
      var transitionPromises = [];
      var defaultTimeout = 1100;
      var ionicViewSwitcher = {
        create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
          var enteringEle,
              leavingEle;
          var transitionId = ++transitionCounter;
          var alreadyInDom;
          var switcher = {
            init: function(registerData, callback) {
              ionicViewSwitcher.isTransitioning(true);
              switcher.loadViewElements(registerData);
              switcher.render(registerData, function() {
                callback && callback();
              });
            },
            loadViewElements: function(registerData) {
              var x,
                  l,
                  viewEle;
              var viewElements = navViewCtrl.getViewElements();
              var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);
              var navViewActiveEleId = navViewCtrl.activeEleId();
              for (x = 0, l = viewElements.length; x < l; x++) {
                viewEle = viewElements.eq(x);
                if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {
                  if (viewEle.data(DATA_NO_CACHE)) {
                    viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());
                    viewEle.data(DATA_DESTROY_ELE, true);
                  } else {
                    enteringEle = viewEle;
                  }
                } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {
                  leavingEle = viewEle;
                }
                if (enteringEle && leavingEle)
                  break;
              }
              alreadyInDom = !!enteringEle;
              if (!alreadyInDom) {
                enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);
                enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);
              }
              if (renderEnd) {
                navViewCtrl.activeEleId(enteringEleIdentifier);
              }
              registerData.ele = null;
            },
            render: function(registerData, callback) {
              if (alreadyInDom) {
                ionic.Utils.reconnectScope(enteringEle.scope());
              } else {
                navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);
                var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
                transitionFn(enteringEle, null, enteringData.direction, true).run(0);
                enteringEle.data(DATA_VIEW, {
                  viewId: enteringData.viewId,
                  historyId: enteringData.historyId,
                  stateName: enteringData.stateName,
                  stateParams: enteringData.stateParams
                });
                if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' || enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {
                  enteringEle.data(DATA_NO_CACHE, true);
                }
                var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);
                delete enteringData.direction;
                delete enteringData.transition;
                viewScope.$emit('$ionicView.loaded', enteringData);
              }
              enteringEle.data(DATA_VIEW_ACCESSED, Date.now());
              callback && callback();
            },
            transition: function(direction, enableBack, allowAnimate) {
              var deferred;
              var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);
              var leavingData = extend(extend({}, enteringData), getViewData(leavingView));
              enteringData.transitionId = leavingData.transitionId = transitionId;
              enteringData.fromCache = !!alreadyInDom;
              enteringData.enableBack = !!enableBack;
              enteringData.renderStart = renderStart;
              enteringData.renderEnd = renderEnd;
              cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);
              cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);
              $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
              var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;
              var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction, enteringData.shouldAnimate && allowAnimate && renderEnd);
              if (viewTransition.shouldAnimate) {
                enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));
                $ionicClickBlock.show(defaultTimeout);
              }
              if (renderStart) {
                switcher.emit('before', enteringData, leavingData);
                navViewAttr(enteringEle, VIEW_STATUS_STAGED);
                viewTransition.run(0);
              }
              if (renderEnd) {
                deferred = $q.defer();
                transitionPromises.push(deferred.promise);
              }
              if (renderStart && renderEnd) {
                $timeout(function() {
                  ionic.requestAnimationFrame(onReflow);
                });
              } else if (!renderEnd) {
                navViewAttr(enteringEle, 'entering');
                navViewAttr(leavingEle, 'leaving');
                return {
                  run: viewTransition.run,
                  cancel: function(shouldAnimate) {
                    if (shouldAnimate) {
                      enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                      enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));
                      $ionicClickBlock.show(defaultTimeout);
                    } else {
                      cancelTransition();
                    }
                    viewTransition.shouldAnimate = shouldAnimate;
                    viewTransition.run(0);
                    viewTransition = null;
                  }
                };
              } else if (renderEnd) {
                onReflow();
              }
              function onReflow() {
                navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);
                navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);
                viewTransition.run(1);
                $ionicNavBarDelegate._instances.forEach(function(instance) {
                  instance.triggerTransitionStart(transitionId);
                });
                if (!viewTransition.shouldAnimate) {
                  transitionComplete();
                }
              }
              function completeOnTransitionEnd(ev) {
                if (ev.target !== this)
                  return;
                transitionComplete();
              }
              function transitionComplete() {
                if (transitionComplete.x)
                  return;
                transitionComplete.x = true;
                enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);
                $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));
                deferred && deferred.resolve(navViewCtrl);
                if (transitionId === transitionCounter) {
                  $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);
                  switcher.emit('after', enteringData, leavingData);
                  switcher.cleanup(enteringData);
                }
                $ionicNavBarDelegate._instances.forEach(function(instance) {
                  instance.triggerTransitionEnd();
                });
                nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;
              }
              function cancelOnTransitionEnd(ev) {
                if (ev.target !== this)
                  return;
                cancelTransition();
              }
              function cancelTransition() {
                navViewAttr(enteringEle, VIEW_STATUS_CACHED);
                navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);
                enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);
                $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));
                ionicViewSwitcher.transitionEnd([navViewCtrl]);
              }
            },
            emit: function(step, enteringData, leavingData) {
              var enteringScope = enteringEle.scope(),
                  leavingScope = leavingEle && leavingEle.scope();
              if (step == 'after') {
                if (enteringScope) {
                  enteringScope.$emit('$ionicView.enter', enteringData);
                }
                if (leavingScope) {
                  leavingScope.$emit('$ionicView.leave', leavingData);
                } else if (enteringScope && leavingData && leavingData.viewId) {
                  enteringScope.$emit('$ionicNavView.leave', leavingData);
                }
              }
              if (enteringScope) {
                enteringScope.$emit('$ionicView.' + step + 'Enter', enteringData);
              }
              if (leavingScope) {
                leavingScope.$emit('$ionicView.' + step + 'Leave', leavingData);
              } else if (enteringScope && leavingData && leavingData.viewId) {
                enteringScope.$emit('$ionicNavView.' + step + 'Leave', leavingData);
              }
            },
            cleanup: function(transData) {
              if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {
                destroyViewEle(leavingEle);
              }
              var viewElements = navViewCtrl.getViewElements();
              var viewElementsLength = viewElements.length;
              var x,
                  viewElement;
              var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();
              var removableEle;
              var oldestAccess = Date.now();
              for (x = 0; x < viewElementsLength; x++) {
                viewElement = viewElements.eq(x);
                if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {
                  oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);
                  removableEle = viewElements.eq(x);
                } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {
                  destroyViewEle(viewElement);
                }
              }
              destroyViewEle(removableEle);
              if (enteringEle.data(DATA_NO_CACHE)) {
                enteringEle.data(DATA_DESTROY_ELE, true);
              }
            },
            enteringEle: function() {
              return enteringEle;
            },
            leavingEle: function() {
              return leavingEle;
            }
          };
          return switcher;
        },
        transitionEnd: function(navViewCtrls) {
          forEach(navViewCtrls, function(navViewCtrl) {
            navViewCtrl.transitionEnd();
          });
          ionicViewSwitcher.isTransitioning(false);
          $ionicClickBlock.hide();
          transitionPromises = [];
        },
        nextTransition: function(val) {
          nextTransition = val;
        },
        nextDirection: function(val) {
          nextDirection = val;
        },
        isTransitioning: function(val) {
          if (arguments.length) {
            ionic.transition.isActive = !!val;
            $timeout.cancel(isActiveTimer);
            if (val) {
              isActiveTimer = $timeout(function() {
                ionicViewSwitcher.isTransitioning(false);
              }, 999);
            }
          }
          return ionic.transition.isActive;
        },
        createViewEle: function(viewLocals) {
          var containerEle = $document[0].createElement('div');
          if (viewLocals && viewLocals.$template) {
            containerEle.innerHTML = viewLocals.$template;
            if (containerEle.children.length === 1) {
              containerEle.children[0].classList.add('pane');
              return jqLite(containerEle.children[0]);
            }
          }
          containerEle.className = "pane";
          return jqLite(containerEle);
        },
        viewEleIsActive: function(viewEle, isActiveAttr) {
          navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);
        },
        getTransitionData: getTransitionData,
        navViewAttr: navViewAttr,
        destroyViewEle: destroyViewEle
      };
      return ionicViewSwitcher;
      function getViewElementIdentifier(locals, view) {
        if (viewState(locals)['abstract'])
          return viewState(locals).name;
        if (view)
          return view.stateId || view.viewId;
        return ionic.Utils.nextUid();
      }
      function viewState(locals) {
        return locals && locals.$$state && locals.$$state.self || {};
      }
      function getTransitionData(viewLocals, enteringEle, direction, view) {
        var state = viewState(viewLocals);
        var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';
        var navBarTransition = $ionicConfig.navBar.transition();
        direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';
        return extend(getViewData(view), {
          transition: viewTransition,
          navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,
          direction: direction,
          shouldAnimate: (viewTransition !== 'none' && direction !== 'none')
        });
      }
      function getViewData(view) {
        view = view || {};
        return {
          viewId: view.viewId,
          historyId: view.historyId,
          stateId: view.stateId,
          stateName: view.stateName,
          stateParams: view.stateParams
        };
      }
      function navViewAttr(ele, value) {
        if (arguments.length > 1) {
          cachedAttr(ele, NAV_VIEW_ATTR, value);
        } else {
          return cachedAttr(ele, NAV_VIEW_ATTR);
        }
      }
      function destroyViewEle(ele) {
        if (ele && ele.length) {
          var viewScope = ele.scope();
          if (viewScope) {
            viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));
            viewScope.$destroy();
          }
          ele.remove();
        }
      }
    }]);
    angular.module('ngIOS9UIWebViewPatch', ['ng']).config(['$provide', function($provide) {
      'use strict';
      $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {
        if (isIOS9UIWebView($window.navigator.userAgent)) {
          return applyIOS9Shim($delegate);
        }
        return $delegate;
        function isIOS9UIWebView(userAgent) {
          return /(iPhone|iPad|iPod).* OS 9_\d/.test(userAgent) && !/Version\/9\./.test(userAgent);
        }
        function applyIOS9Shim(browser) {
          var pendingLocationUrl = null;
          var originalUrlFn = browser.url;
          browser.url = function() {
            if (arguments.length) {
              pendingLocationUrl = arguments[0];
              return originalUrlFn.apply(browser, arguments);
            }
            return pendingLocationUrl || originalUrlFn.apply(browser, arguments);
          };
          window.addEventListener('popstate', clearPendingLocationUrl, false);
          window.addEventListener('hashchange', clearPendingLocationUrl, false);
          function clearPendingLocationUrl() {
            pendingLocationUrl = null;
          }
          return browser;
        }
      }]);
    }]);
    IonicModule.config(['$provide', function($provide) {
      $provide.decorator('$compile', ['$delegate', function($compile) {
        $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {
          var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';
          $element.data(dataName, scope);
        };
        return $compile;
      }]);
    }]);
    IonicModule.config(['$provide', function($provide) {
      function $LocationDecorator($location, $timeout) {
        $location.__hash = $location.hash;
        $location.hash = function(value) {
          if (isDefined(value) && value.length > 0) {
            $timeout(function() {
              var scroll = document.querySelector('.scroll-content');
              if (scroll) {
                scroll.scrollTop = 0;
              }
            }, 0, false);
          }
          return $location.__hash(value);
        };
        return $location;
      }
      $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);
    }]);
    IonicModule.controller('$ionicHeaderBar', ['$scope', '$element', '$attrs', '$q', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {
      var TITLE = 'title';
      var BACK_TEXT = 'back-text';
      var BACK_BUTTON = 'back-button';
      var DEFAULT_TITLE = 'default-title';
      var PREVIOUS_TITLE = 'previous-title';
      var HIDE = 'hide';
      var self = this;
      var titleText = '';
      var previousTitleText = '';
      var titleLeft = 0;
      var titleRight = 0;
      var titleCss = '';
      var isBackEnabled = false;
      var isBackShown = true;
      var isNavBackShown = true;
      var isBackElementShown = false;
      var titleTextWidth = 0;
      self.beforeEnter = function(viewData) {
        $scope.$broadcast('$ionicView.beforeEnter', viewData);
      };
      self.title = function(newTitleText) {
        if (arguments.length && newTitleText !== titleText) {
          getEle(TITLE).innerHTML = newTitleText;
          titleText = newTitleText;
          titleTextWidth = 0;
        }
        return titleText;
      };
      self.enableBack = function(shouldEnable, disableReset) {
        if (arguments.length) {
          isBackEnabled = shouldEnable;
          if (!disableReset)
            self.updateBackButton();
        }
        return isBackEnabled;
      };
      self.showBack = function(shouldShow, disableReset) {
        if (arguments.length) {
          isBackShown = shouldShow;
          if (!disableReset)
            self.updateBackButton();
        }
        return isBackShown;
      };
      self.showNavBack = function(shouldShow) {
        isNavBackShown = shouldShow;
        self.updateBackButton();
      };
      self.updateBackButton = function() {
        var ele;
        if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {
          isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;
          ele = getEle(BACK_BUTTON);
          ele && ele.classList[isBackElementShown ? 'remove' : 'add'](HIDE);
        }
        if (isBackEnabled) {
          ele = ele || getEle(BACK_BUTTON);
          if (ele) {
            if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {
              ele = getEle(BACK_BUTTON + ' .icon');
              if (ele) {
                self.backButtonIcon = $ionicConfig.backButton.icon();
                ele.className = 'icon ' + self.backButtonIcon;
              }
            }
            if (self.backButtonText !== $ionicConfig.backButton.text()) {
              ele = getEle(BACK_BUTTON + ' .back-text');
              if (ele) {
                ele.textContent = self.backButtonText = $ionicConfig.backButton.text();
              }
            }
          }
        }
      };
      self.titleTextWidth = function() {
        if (!titleTextWidth) {
          var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));
          titleTextWidth = Math.min(bounds && bounds.width || 30);
        }
        return titleTextWidth;
      };
      self.titleWidth = function() {
        var titleWidth = self.titleTextWidth();
        var offsetWidth = getEle(TITLE).offsetWidth;
        if (offsetWidth < titleWidth) {
          titleWidth = offsetWidth + (titleLeft - titleRight - 5);
        }
        return titleWidth;
      };
      self.titleTextX = function() {
        return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);
      };
      self.titleLeftRight = function() {
        return titleLeft - titleRight;
      };
      self.backButtonTextLeft = function() {
        var offsetLeft = 0;
        var ele = getEle(BACK_TEXT);
        while (ele) {
          offsetLeft += ele.offsetLeft;
          ele = ele.parentElement;
        }
        return offsetLeft;
      };
      self.resetBackButton = function(viewData) {
        if ($ionicConfig.backButton.previousTitleText()) {
          var previousTitleEle = getEle(PREVIOUS_TITLE);
          if (previousTitleEle) {
            previousTitleEle.classList.remove(HIDE);
            var view = (viewData && $ionicHistory.getViewById(viewData.viewId));
            var newPreviousTitleText = $ionicHistory.backTitle(view);
            if (newPreviousTitleText !== previousTitleText) {
              previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;
            }
          }
          var defaultTitleEle = getEle(DEFAULT_TITLE);
          if (defaultTitleEle) {
            defaultTitleEle.classList.remove(HIDE);
          }
        }
      };
      self.align = function(textAlign) {
        var titleEle = getEle(TITLE);
        textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
        var widths = self.calcWidths(textAlign, false);
        if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {
          var previousTitleWidths = self.calcWidths(textAlign, true);
          var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;
          if (self.titleTextWidth() <= availableTitleWidth) {
            widths = previousTitleWidths;
          }
        }
        return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);
      };
      self.calcWidths = function(textAlign, isPreviousTitle) {
        var titleEle = getEle(TITLE);
        var backBtnEle = getEle(BACK_BUTTON);
        var x,
            y,
            z,
            b,
            c,
            d,
            childSize,
            bounds;
        var childNodes = $element[0].childNodes;
        var buttonsLeft = 0;
        var buttonsRight = 0;
        var isCountRightOfTitle;
        var updateTitleLeft = 0;
        var updateTitleRight = 0;
        var updateCss = '';
        var backButtonWidth = 0;
        for (x = 0; x < childNodes.length; x++) {
          c = childNodes[x];
          childSize = 0;
          if (c.nodeType == 1) {
            if (c === titleEle) {
              isCountRightOfTitle = true;
              continue;
            }
            if (c.classList.contains(HIDE)) {
              continue;
            }
            if (isBackShown && c === backBtnEle) {
              for (y = 0; y < c.childNodes.length; y++) {
                b = c.childNodes[y];
                if (b.nodeType == 1) {
                  if (b.classList.contains(BACK_TEXT)) {
                    for (z = 0; z < b.children.length; z++) {
                      d = b.children[z];
                      if (isPreviousTitle) {
                        if (d.classList.contains(DEFAULT_TITLE))
                          continue;
                        backButtonWidth += d.offsetWidth;
                      } else {
                        if (d.classList.contains(PREVIOUS_TITLE))
                          continue;
                        backButtonWidth += d.offsetWidth;
                      }
                    }
                  } else {
                    backButtonWidth += b.offsetWidth;
                  }
                } else if (b.nodeType == 3 && b.nodeValue.trim()) {
                  bounds = ionic.DomUtil.getTextBounds(b);
                  backButtonWidth += bounds && bounds.width || 0;
                }
              }
              childSize = backButtonWidth || c.offsetWidth;
            } else {
              childSize = c.offsetWidth;
            }
          } else if (c.nodeType == 3 && c.nodeValue.trim()) {
            bounds = ionic.DomUtil.getTextBounds(c);
            childSize = bounds && bounds.width || 0;
          }
          if (isCountRightOfTitle) {
            buttonsRight += childSize;
          } else {
            buttonsLeft += childSize;
          }
        }
        if (textAlign == 'left') {
          updateCss = 'title-left';
          if (buttonsLeft) {
            updateTitleLeft = buttonsLeft + 15;
          }
          if (buttonsRight) {
            updateTitleRight = buttonsRight + 15;
          }
        } else if (textAlign == 'right') {
          updateCss = 'title-right';
          if (buttonsLeft) {
            updateTitleLeft = buttonsLeft + 15;
          }
          if (buttonsRight) {
            updateTitleRight = buttonsRight + 15;
          }
        } else {
          var margin = Math.max(buttonsLeft, buttonsRight) + 10;
          if (margin > 10) {
            updateTitleLeft = updateTitleRight = margin;
          }
        }
        return {
          backButtonWidth: backButtonWidth,
          buttonsLeft: buttonsLeft,
          buttonsRight: buttonsRight,
          titleLeft: updateTitleLeft,
          titleRight: updateTitleRight,
          showPrevTitle: isPreviousTitle,
          css: updateCss
        };
      };
      self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {
        var deferred = $q.defer();
        if (titleEle) {
          if (updateTitleLeft !== titleLeft) {
            titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';
            titleLeft = updateTitleLeft;
          }
          if (updateTitleRight !== titleRight) {
            titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';
            titleRight = updateTitleRight;
          }
          if (updateCss !== titleCss) {
            updateCss && titleEle.classList.add(updateCss);
            titleCss && titleEle.classList.remove(titleCss);
            titleCss = updateCss;
          }
        }
        if ($ionicConfig.backButton.previousTitleText()) {
          var prevTitle = getEle(PREVIOUS_TITLE);
          var defaultTitle = getEle(DEFAULT_TITLE);
          prevTitle && prevTitle.classList[showPreviousTitle ? 'remove' : 'add'](HIDE);
          defaultTitle && defaultTitle.classList[showPreviousTitle ? 'add' : 'remove'](HIDE);
        }
        ionic.requestAnimationFrame(function() {
          if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {
            var minRight = buttonsRight + 5;
            var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;
            updateTitleRight = testRight < minRight ? minRight : testRight;
            if (updateTitleRight !== titleRight) {
              titleEle.style.right = updateTitleRight + 'px';
              titleRight = updateTitleRight;
            }
          }
          deferred.resolve();
        });
        return deferred.promise;
      };
      self.setCss = function(elementClassname, css) {
        ionic.DomUtil.cachedStyles(getEle(elementClassname), css);
      };
      var eleCache = {};
      function getEle(className) {
        if (!eleCache[className]) {
          eleCache[className] = $element[0].querySelector('.' + className);
        }
        return eleCache[className];
      }
      $scope.$on('$destroy', function() {
        for (var n in eleCache)
          eleCache[n] = null;
      });
    }]);
    IonicModule.controller('$ionInfiniteScroll', ['$scope', '$attrs', '$element', '$timeout', function($scope, $attrs, $element, $timeout) {
      var self = this;
      self.isLoading = false;
      $scope.icon = function() {
        return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';
      };
      $scope.spinner = function() {
        return isDefined($attrs.spinner) ? $attrs.spinner : '';
      };
      $scope.$on('scroll.infiniteScrollComplete', function() {
        finishInfiniteScroll();
      });
      $scope.$on('$destroy', function() {
        if (self.scrollCtrl && self.scrollCtrl.$element)
          self.scrollCtrl.$element.off('scroll', self.checkBounds);
        if (self.scrollEl && self.scrollEl.removeEventListener) {
          self.scrollEl.removeEventListener('scroll', self.checkBounds);
        }
      });
      self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);
      function onInfinite() {
        ionic.requestAnimationFrame(function() {
          $element[0].classList.add('active');
        });
        self.isLoading = true;
        $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');
      }
      function finishInfiniteScroll() {
        ionic.requestAnimationFrame(function() {
          $element[0].classList.remove('active');
        });
        $timeout(function() {
          if (self.jsScrolling)
            self.scrollView.resize();
          if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) || !self.jsScrolling) {
            self.checkBounds();
          }
        }, 30, false);
        self.isLoading = false;
      }
      function checkInfiniteBounds() {
        if (self.isLoading)
          return;
        var maxScroll = {};
        if (self.jsScrolling) {
          maxScroll = self.getJSMaxScroll();
          var scrollValues = self.scrollView.getValues();
          if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) || (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {
            onInfinite();
          }
        } else {
          maxScroll = self.getNativeMaxScroll();
          if ((maxScroll.left !== -1 && self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth) || (maxScroll.top !== -1 && self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight)) {
            onInfinite();
          }
        }
      }
      self.getJSMaxScroll = function() {
        var maxValues = self.scrollView.getScrollMax();
        return {
          left: self.scrollView.options.scrollingX ? calculateMaxValue(maxValues.left) : -1,
          top: self.scrollView.options.scrollingY ? calculateMaxValue(maxValues.top) : -1
        };
      };
      self.getNativeMaxScroll = function() {
        var maxValues = {
          left: self.scrollEl.scrollWidth,
          top: self.scrollEl.scrollHeight
        };
        var computedStyle = window.getComputedStyle(self.scrollEl) || {};
        return {
          left: maxValues.left && (computedStyle.overflowX === 'scroll' || computedStyle.overflowX === 'auto' || self.scrollEl.style['overflow-x'] === 'scroll') ? calculateMaxValue(maxValues.left) : -1,
          top: maxValues.top && (computedStyle.overflowY === 'scroll' || computedStyle.overflowY === 'auto' || self.scrollEl.style['overflow-y'] === 'scroll') ? calculateMaxValue(maxValues.top) : -1
        };
      };
      function calculateMaxValue(maximum) {
        var distance = ($attrs.distance || '2.5%').trim();
        var isPercent = distance.indexOf('%') !== -1;
        return isPercent ? maximum * (1 - parseFloat(distance) / 100) : maximum - parseFloat(distance);
      }
      self.__finishInfiniteScroll = finishInfiniteScroll;
    }]);
    IonicModule.service('$ionicListDelegate', ionic.DelegateService(['showReorder', 'showDelete', 'canSwipeItems', 'closeOptionButtons'])).controller('$ionicList', ['$scope', '$attrs', '$ionicListDelegate', '$ionicHistory', function($scope, $attrs, $ionicListDelegate, $ionicHistory) {
      var self = this;
      var isSwipeable = true;
      var isReorderShown = false;
      var isDeleteShown = false;
      var deregisterInstance = $ionicListDelegate._registerInstance(self, $attrs.delegateHandle, function() {
        return $ionicHistory.isActiveScope($scope);
      });
      $scope.$on('$destroy', deregisterInstance);
      self.showReorder = function(show) {
        if (arguments.length) {
          isReorderShown = !!show;
        }
        return isReorderShown;
      };
      self.showDelete = function(show) {
        if (arguments.length) {
          isDeleteShown = !!show;
        }
        return isDeleteShown;
      };
      self.canSwipeItems = function(can) {
        if (arguments.length) {
          isSwipeable = !!can;
        }
        return isSwipeable;
      };
      self.closeOptionButtons = function() {
        self.listView && self.listView.clearDragEffects();
      };
    }]);
    IonicModule.controller('$ionicNavBar', ['$scope', '$element', '$attrs', '$compile', '$timeout', '$ionicNavBarDelegate', '$ionicConfig', '$ionicHistory', function($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {
      var CSS_HIDE = 'hide';
      var DATA_NAV_BAR_CTRL = '$ionNavBarController';
      var PRIMARY_BUTTONS = 'primaryButtons';
      var SECONDARY_BUTTONS = 'secondaryButtons';
      var BACK_BUTTON = 'backButton';
      var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');
      var self = this;
      var headerBars = [];
      var navElementHtml = {};
      var isVisible = true;
      var queuedTransitionStart,
          queuedTransitionEnd,
          latestTransitionId;
      $element.parent().data(DATA_NAV_BAR_CTRL, self);
      var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();
      var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);
      self.init = function() {
        $element.addClass('nav-bar-container');
        ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());
        self.createHeaderBar(false);
        self.createHeaderBar(true);
        $scope.$emit('ionNavBar.init', delegateHandle);
      };
      self.createHeaderBar = function(isActive) {
        var containerEle = jqLite('<div class="nav-bar-block">');
        ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');
        var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();
        var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);
        if (isDefined($attrs.noTapScroll))
          headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);
        var titleEle = jqLite('<div class="title title-' + alignTitle + '">');
        var navEle = {};
        var lastViewItemEle = {};
        var leftButtonsEle,
            rightButtonsEle;
        navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);
        navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);
        headerBarEle.append(titleEle);
        forEach(ITEM_TYPES, function(itemType) {
          navEle[itemType] = createNavElement(itemType);
          positionItem(navEle[itemType], itemType);
        });
        for (var x = 0; x < headerBarEle[0].children.length; x++) {
          headerBarEle[0].children[x].classList.add('header-item');
        }
        containerEle.append(headerBarEle);
        $element.append($compile(containerEle)($scope.$new()));
        var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');
        headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();
        headerBarCtrl.backButtonText = $ionicConfig.backButton.text();
        var headerBarInstance = {
          isActive: isActive,
          title: function(newTitleText) {
            headerBarCtrl.title(newTitleText);
          },
          setItem: function(navBarItemEle, itemType) {
            headerBarInstance.removeItem(itemType);
            if (navBarItemEle) {
              if (itemType === 'title') {
                headerBarInstance.title("");
              }
              positionItem(navBarItemEle, itemType);
              if (navEle[itemType]) {
                navEle[itemType].addClass(CSS_HIDE);
              }
              lastViewItemEle[itemType] = navBarItemEle;
            } else if (navEle[itemType]) {
              navEle[itemType].removeClass(CSS_HIDE);
            }
          },
          removeItem: function(itemType) {
            if (lastViewItemEle[itemType]) {
              lastViewItemEle[itemType].scope().$destroy();
              lastViewItemEle[itemType].remove();
              lastViewItemEle[itemType] = null;
            }
          },
          containerEle: function() {
            return containerEle;
          },
          headerBarEle: function() {
            return headerBarEle;
          },
          afterLeave: function() {
            forEach(ITEM_TYPES, function(itemType) {
              headerBarInstance.removeItem(itemType);
            });
            headerBarCtrl.resetBackButton();
          },
          controller: function() {
            return headerBarCtrl;
          },
          destroy: function() {
            forEach(ITEM_TYPES, function(itemType) {
              headerBarInstance.removeItem(itemType);
            });
            containerEle.scope().$destroy();
            for (var n in navEle) {
              if (navEle[n]) {
                navEle[n].removeData();
                navEle[n] = null;
              }
            }
            leftButtonsEle && leftButtonsEle.removeData();
            rightButtonsEle && rightButtonsEle.removeData();
            titleEle.removeData();
            headerBarEle.removeData();
            containerEle.remove();
            containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;
          }
        };
        function positionItem(ele, itemType) {
          if (!ele)
            return;
          if (itemType === 'title') {
            titleEle.append(ele);
          } else if (itemType == 'rightButtons' || (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') || (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {
            if (!rightButtonsEle) {
              rightButtonsEle = jqLite('<div class="buttons buttons-right">');
              headerBarEle.append(rightButtonsEle);
            }
            if (itemType == SECONDARY_BUTTONS) {
              rightButtonsEle.append(ele);
            } else {
              rightButtonsEle.prepend(ele);
            }
          } else {
            if (!leftButtonsEle) {
              leftButtonsEle = jqLite('<div class="buttons buttons-left">');
              if (navEle[BACK_BUTTON]) {
                navEle[BACK_BUTTON].after(leftButtonsEle);
              } else {
                headerBarEle.prepend(leftButtonsEle);
              }
            }
            if (itemType == SECONDARY_BUTTONS) {
              leftButtonsEle.append(ele);
            } else {
              leftButtonsEle.prepend(ele);
            }
          }
        }
        headerBars.push(headerBarInstance);
        return headerBarInstance;
      };
      self.navElement = function(type, html) {
        if (isDefined(html)) {
          navElementHtml[type] = html;
        }
        return navElementHtml[type];
      };
      self.update = function(viewData) {
        var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;
        viewData.transition = $ionicConfig.views.transition();
        if (!showNavBar) {
          viewData.direction = 'none';
        }
        self.enable(showNavBar);
        var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();
        var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;
        var enteringHeaderCtrl = enteringHeaderBar.controller();
        enteringHeaderCtrl.enableBack(viewData.enableBack, true);
        enteringHeaderCtrl.showBack(viewData.showBack, true);
        enteringHeaderCtrl.updateBackButton();
        self.title(viewData.title, enteringHeaderBar);
        self.showBar(showNavBar);
        if (viewData.navBarItems) {
          forEach(ITEM_TYPES, function(itemType) {
            enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);
          });
        }
        self.transition(enteringHeaderBar, leavingHeaderBar, viewData);
        self.isInitialized = true;
        navSwipeAttr('');
      };
      self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {
        var enteringHeaderBarCtrl = enteringHeaderBar.controller();
        var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;
        var transitionId = viewData.transitionId;
        enteringHeaderBarCtrl.beforeEnter(viewData);
        var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);
        ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);
        ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);
        if (navBarTransition.shouldAnimate && viewData.renderEnd) {
          navBarAttr(enteringHeaderBar, 'stage');
        } else {
          navBarAttr(enteringHeaderBar, 'entering');
          navBarAttr(leavingHeaderBar, 'leaving');
        }
        enteringHeaderBarCtrl.resetBackButton(viewData);
        navBarTransition.run(0);
        self.activeTransition = {
          run: function(step) {
            navBarTransition.shouldAnimate = false;
            navBarTransition.direction = 'back';
            navBarTransition.run(step);
          },
          cancel: function(shouldAnimate, speed, cancelData) {
            navSwipeAttr(speed);
            navBarAttr(leavingHeaderBar, 'active');
            navBarAttr(enteringHeaderBar, 'cached');
            navBarTransition.shouldAnimate = shouldAnimate;
            navBarTransition.run(0);
            self.activeTransition = navBarTransition = null;
            var runApply;
            if (cancelData.showBar !== self.showBar()) {
              self.showBar(cancelData.showBar);
            }
            if (cancelData.showBackButton !== self.showBackButton()) {
              self.showBackButton(cancelData.showBackButton);
            }
            if (runApply) {
              $scope.$apply();
            }
          },
          complete: function(shouldAnimate, speed) {
            navSwipeAttr(speed);
            navBarTransition.shouldAnimate = shouldAnimate;
            navBarTransition.run(1);
            queuedTransitionEnd = transitionEnd;
          }
        };
        $timeout(enteringHeaderBarCtrl.align, 16);
        queuedTransitionStart = function() {
          if (latestTransitionId !== transitionId)
            return;
          navBarAttr(enteringHeaderBar, 'entering');
          navBarAttr(leavingHeaderBar, 'leaving');
          navBarTransition.run(1);
          queuedTransitionEnd = function() {
            if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {
              transitionEnd();
            }
          };
          queuedTransitionStart = null;
        };
        function transitionEnd() {
          for (var x = 0; x < headerBars.length; x++) {
            headerBars[x].isActive = false;
          }
          enteringHeaderBar.isActive = true;
          navBarAttr(enteringHeaderBar, 'active');
          navBarAttr(leavingHeaderBar, 'cached');
          self.activeTransition = navBarTransition = queuedTransitionEnd = null;
        }
        queuedTransitionStart();
      };
      self.triggerTransitionStart = function(triggerTransitionId) {
        latestTransitionId = triggerTransitionId;
        queuedTransitionStart && queuedTransitionStart();
      };
      self.triggerTransitionEnd = function() {
        queuedTransitionEnd && queuedTransitionEnd();
      };
      self.showBar = function(shouldShow) {
        if (arguments.length) {
          self.visibleBar(shouldShow);
          $scope.$parent.$hasHeader = !!shouldShow;
        }
        return !!$scope.$parent.$hasHeader;
      };
      self.visibleBar = function(shouldShow) {
        if (shouldShow && !isVisible) {
          $element.removeClass(CSS_HIDE);
          self.align();
        } else if (!shouldShow && isVisible) {
          $element.addClass(CSS_HIDE);
        }
        isVisible = shouldShow;
      };
      self.enable = function(val) {
        self.visibleBar(val);
        for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
          if ($ionicNavBarDelegate._instances[x] !== self)
            $ionicNavBarDelegate._instances[x].visibleBar(false);
        }
      };
      self.showBackButton = function(shouldShow) {
        if (arguments.length) {
          for (var x = 0; x < headerBars.length; x++) {
            headerBars[x].controller().showNavBack(!!shouldShow);
          }
          $scope.$isBackButtonShown = !!shouldShow;
        }
        return $scope.$isBackButtonShown;
      };
      self.showActiveBackButton = function(shouldShow) {
        var headerBar = getOnScreenHeaderBar();
        if (headerBar) {
          if (arguments.length) {
            return headerBar.controller().showBack(shouldShow);
          }
          return headerBar.controller().showBack();
        }
      };
      self.title = function(newTitleText, headerBar) {
        if (isDefined(newTitleText)) {
          newTitleText = newTitleText || '';
          headerBar = headerBar || getOnScreenHeaderBar();
          headerBar && headerBar.title(newTitleText);
          $scope.$title = newTitleText;
          $ionicHistory.currentTitle(newTitleText);
        }
        return $scope.$title;
      };
      self.align = function(val, headerBar) {
        headerBar = headerBar || getOnScreenHeaderBar();
        headerBar && headerBar.controller().align(val);
      };
      self.hasTabsTop = function(isTabsTop) {
        $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');
      };
      self.hasBarSubheader = function(isBarSubheader) {
        $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');
      };
      self.changeTitle = function(val) {
        deprecatedWarning('changeTitle(val)', 'title(val)');
        self.title(val);
      };
      self.setTitle = function(val) {
        deprecatedWarning('setTitle(val)', 'title(val)');
        self.title(val);
      };
      self.getTitle = function() {
        deprecatedWarning('getTitle()', 'title()');
        return self.title();
      };
      self.back = function() {
        deprecatedWarning('back()', '$ionicHistory.goBack()');
        $ionicHistory.goBack();
      };
      self.getPreviousTitle = function() {
        deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');
        $ionicHistory.goBack();
      };
      function deprecatedWarning(oldMethod, newMethod) {
        var warn = console.warn || console.log;
        warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');
      }
      function createNavElement(type) {
        if (navElementHtml[type]) {
          return jqLite(navElementHtml[type]);
        }
      }
      function getOnScreenHeaderBar() {
        for (var x = 0; x < headerBars.length; x++) {
          if (headerBars[x].isActive)
            return headerBars[x];
        }
      }
      function getOffScreenHeaderBar() {
        for (var x = 0; x < headerBars.length; x++) {
          if (!headerBars[x].isActive)
            return headerBars[x];
        }
      }
      function navBarAttr(ctrl, val) {
        ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);
      }
      function navSwipeAttr(val) {
        ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
      }
      $scope.$on('$destroy', function() {
        $scope.$parent.$hasHeader = false;
        $element.parent().removeData(DATA_NAV_BAR_CTRL);
        for (var x = 0; x < headerBars.length; x++) {
          headerBars[x].destroy();
        }
        $element.remove();
        $element = headerBars = null;
        deregisterInstance();
      });
    }]);
    IonicModule.controller('$ionicNavView', ['$scope', '$element', '$attrs', '$compile', '$controller', '$ionicNavBarDelegate', '$ionicNavViewDelegate', '$ionicHistory', '$ionicViewSwitcher', '$ionicConfig', '$ionicScrollDelegate', function($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {
      var DATA_ELE_IDENTIFIER = '$eleId';
      var DATA_DESTROY_ELE = '$destroyEle';
      var DATA_NO_CACHE = '$noCache';
      var VIEW_STATUS_ACTIVE = 'active';
      var VIEW_STATUS_CACHED = 'cached';
      var self = this;
      var direction;
      var isPrimary = false;
      var navBarDelegate;
      var activeEleId;
      var navViewAttr = $ionicViewSwitcher.navViewAttr;
      var disableRenderStartViewId,
          disableAnimation;
      self.scope = $scope;
      self.element = $element;
      self.init = function() {
        var navViewName = $attrs.name || '';
        var parent = $element.parent().inheritedData('$uiView');
        var parentViewName = ((parent && parent.state) ? parent.state.name : '');
        if (navViewName.indexOf('@') < 0)
          navViewName = navViewName + '@' + parentViewName;
        var viewData = {
          name: navViewName,
          state: null
        };
        $element.data('$uiView', viewData);
        var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);
        $scope.$on('$destroy', function() {
          deregisterInstance();
          if (self.isSwipeFreeze) {
            $ionicScrollDelegate.freezeAllScrolls(false);
          }
        });
        $scope.$on('$ionicHistory.deselect', self.cacheCleanup);
        $scope.$on('$ionicTabs.top', onTabsTop);
        $scope.$on('$ionicSubheader', onBarSubheader);
        $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);
        $scope.$on('$ionicTabs.afterLeave', onTabsLeave);
        $scope.$on('$ionicTabs.leave', onTabsLeave);
        ionic.Platform.ready(function() {
          if (ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled()) {
            self.initSwipeBack();
          }
        });
        return viewData;
      };
      self.register = function(viewLocals) {
        var leavingView = extend({}, $ionicHistory.currentView());
        var registerData = $ionicHistory.register($scope, viewLocals);
        self.update(registerData);
        var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};
        var renderStart = (disableRenderStartViewId !== registerData.viewId);
        self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);
      };
      self.update = function(registerData) {
        isPrimary = true;
        direction = registerData.direction;
        var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');
        if (parentNavViewCtrl) {
          parentNavViewCtrl.isPrimary(false);
          if (direction === 'enter' || direction === 'exit') {
            parentNavViewCtrl.direction(direction);
            if (direction === 'enter') {
              direction = 'none';
            }
          }
        }
      };
      self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {
        var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);
        switcher.init(registerData, function() {
          switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);
          disableRenderStartViewId = disableAnimation = null;
        });
      };
      self.beforeEnter = function(transitionData) {
        if (isPrimary) {
          navBarDelegate = transitionData.navBarDelegate;
          var associatedNavBarCtrl = getAssociatedNavBarCtrl();
          associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);
          navSwipeAttr('');
        }
      };
      self.activeEleId = function(eleId) {
        if (arguments.length) {
          activeEleId = eleId;
        }
        return activeEleId;
      };
      self.transitionEnd = function() {
        var viewElements = $element.children();
        var x,
            l,
            viewElement;
        for (x = 0, l = viewElements.length; x < l; x++) {
          viewElement = viewElements.eq(x);
          if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {
            navViewAttr(viewElement, VIEW_STATUS_ACTIVE);
          } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {
            if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {
              $ionicViewSwitcher.destroyViewEle(viewElement);
            } else {
              navViewAttr(viewElement, VIEW_STATUS_CACHED);
              ionic.Utils.disconnectScope(viewElement.scope());
            }
          }
        }
        navSwipeAttr('');
        if (self.isSwipeFreeze) {
          $ionicScrollDelegate.freezeAllScrolls(false);
        }
      };
      function onTabsLeave(ev, data) {
        var viewElements = $element.children();
        var viewElement,
            viewScope;
        for (var x = 0,
            l = viewElements.length; x < l; x++) {
          viewElement = viewElements.eq(x);
          if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
            viewScope = viewElement.scope();
            viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);
            break;
          }
        }
      }
      self.cacheCleanup = function() {
        var viewElements = $element.children();
        for (var x = 0,
            l = viewElements.length; x < l; x++) {
          if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {
            $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));
          }
        }
      };
      self.clearCache = function(stateIds) {
        var viewElements = $element.children();
        var viewElement,
            viewScope,
            x,
            l,
            y,
            eleIdentifier;
        for (x = 0, l = viewElements.length; x < l; x++) {
          viewElement = viewElements.eq(x);
          if (stateIds) {
            eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);
            for (y = 0; y < stateIds.length; y++) {
              if (eleIdentifier === stateIds[y]) {
                $ionicViewSwitcher.destroyViewEle(viewElement);
              }
            }
            continue;
          }
          if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {
            $ionicViewSwitcher.destroyViewEle(viewElement);
          } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {
            viewScope = viewElement.scope();
            viewScope && viewScope.$broadcast('$ionicView.clearCache');
          }
        }
      };
      self.getViewElements = function() {
        return $element.children();
      };
      self.appendViewElement = function(viewEle, viewLocals) {
        var linkFn = $compile(viewEle);
        $element.append(viewEle);
        var viewScope = $scope.$new();
        if (viewLocals && viewLocals.$$controller) {
          viewLocals.$scope = viewScope;
          var controller = $controller(viewLocals.$$controller, viewLocals);
          if (viewLocals.$$controllerAs) {
            viewScope[viewLocals.$$controllerAs] = controller;
          }
          $element.children().data('$ngControllerController', controller);
        }
        linkFn(viewScope);
        return viewScope;
      };
      self.title = function(val) {
        var associatedNavBarCtrl = getAssociatedNavBarCtrl();
        associatedNavBarCtrl && associatedNavBarCtrl.title(val);
      };
      self.enableBackButton = function(shouldEnable) {
        var associatedNavBarCtrl = getAssociatedNavBarCtrl();
        associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);
      };
      self.showBackButton = function(shouldShow) {
        var associatedNavBarCtrl = getAssociatedNavBarCtrl();
        if (associatedNavBarCtrl) {
          if (arguments.length) {
            return associatedNavBarCtrl.showActiveBackButton(shouldShow);
          }
          return associatedNavBarCtrl.showActiveBackButton();
        }
        return true;
      };
      self.showBar = function(val) {
        var associatedNavBarCtrl = getAssociatedNavBarCtrl();
        if (associatedNavBarCtrl) {
          if (arguments.length) {
            return associatedNavBarCtrl.showBar(val);
          }
          return associatedNavBarCtrl.showBar();
        }
        return true;
      };
      self.isPrimary = function(val) {
        if (arguments.length) {
          isPrimary = val;
        }
        return isPrimary;
      };
      self.direction = function(val) {
        if (arguments.length) {
          direction = val;
        }
        return direction;
      };
      self.initSwipeBack = function() {
        var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();
        var viewTransition,
            associatedNavBarCtrl,
            backView;
        var deregDragStart,
            deregDrag,
            deregRelease;
        var windowWidth,
            startDragX,
            dragPoints;
        var cancelData = {};
        function onDragStart(ev) {
          if (!isPrimary)
            return;
          startDragX = getDragX(ev);
          if (startDragX > swipeBackHitWidth)
            return;
          backView = $ionicHistory.backView();
          var currentView = $ionicHistory.currentView();
          if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false)
            return;
          if (!windowWidth)
            windowWidth = window.innerWidth;
          self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);
          var registerData = {direction: 'back'};
          dragPoints = [];
          cancelData = {
            showBar: self.showBar(),
            showBackButton: self.showBackButton()
          };
          var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);
          switcher.loadViewElements(registerData);
          switcher.render(registerData);
          viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);
          associatedNavBarCtrl = getAssociatedNavBarCtrl();
          deregDrag = ionic.onGesture('drag', onDrag, $element[0]);
          deregRelease = ionic.onGesture('release', onRelease, $element[0]);
        }
        function onDrag(ev) {
          if (isPrimary && viewTransition) {
            var dragX = getDragX(ev);
            dragPoints.push({
              t: Date.now(),
              x: dragX
            });
            if (dragX >= windowWidth - 15) {
              onRelease(ev);
            } else {
              var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);
              viewTransition.run(step);
              associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);
            }
          }
        }
        function onRelease(ev) {
          if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {
            var now = Date.now();
            var releaseX = getDragX(ev);
            var startDrag = dragPoints[dragPoints.length - 1];
            for (var x = dragPoints.length - 2; x >= 0; x--) {
              if (now - startDrag.t > 200) {
                break;
              }
              startDrag = dragPoints[x];
            }
            var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);
            var releaseSwipeCompletion = getSwipeCompletion(releaseX);
            var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);
            disableRenderStartViewId = backView.viewId;
            disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);
            if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {
              var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';
              navSwipeAttr(disableAnimation ? '' : speed);
              backView.go();
              associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);
            } else {
              navSwipeAttr(disableAnimation ? '' : 'fast');
              disableRenderStartViewId = null;
              viewTransition.cancel(!disableAnimation);
              associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);
              disableAnimation = null;
            }
          }
          ionic.offGesture(deregDrag, 'drag', onDrag);
          ionic.offGesture(deregRelease, 'release', onRelease);
          windowWidth = viewTransition = dragPoints = null;
          self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);
        }
        function getDragX(ev) {
          return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;
        }
        function getSwipeCompletion(dragX) {
          return (dragX - startDragX) / windowWidth;
        }
        deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);
        $scope.$on('$destroy', function() {
          ionic.offGesture(deregDragStart, 'dragstart', onDragStart);
          ionic.offGesture(deregDrag, 'drag', onDrag);
          ionic.offGesture(deregRelease, 'release', onRelease);
          self.element = viewTransition = associatedNavBarCtrl = null;
        });
      };
      function navSwipeAttr(val) {
        ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);
      }
      function onTabsTop(ev, isTabsTop) {
        var associatedNavBarCtrl = getAssociatedNavBarCtrl();
        associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);
      }
      function onBarSubheader(ev, isBarSubheader) {
        var associatedNavBarCtrl = getAssociatedNavBarCtrl();
        associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);
      }
      function getAssociatedNavBarCtrl() {
        if (navBarDelegate) {
          for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {
            if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {
              return $ionicNavBarDelegate._instances[x];
            }
          }
        }
        return $element.inheritedData('$ionNavBarController');
      }
    }]);
    IonicModule.controller('$ionicRefresher', ['$scope', '$attrs', '$element', '$ionicBind', '$timeout', function($scope, $attrs, $element, $ionicBind, $timeout) {
      var self = this,
          isDragging = false,
          isOverscrolling = false,
          dragOffset = 0,
          lastOverscroll = 0,
          ptrThreshold = 60,
          activated = false,
          scrollTime = 500,
          startY = null,
          deltaY = null,
          canOverscroll = true,
          scrollParent,
          scrollChild;
      if (!isDefined($attrs.pullingIcon)) {
        $attrs.$set('pullingIcon', 'ion-android-arrow-down');
      }
      $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';
      $scope.showIcon = isDefined($attrs.refreshingIcon);
      $ionicBind($scope, $attrs, {
        pullingIcon: '@',
        pullingText: '@',
        refreshingIcon: '@',
        refreshingText: '@',
        spinner: '@',
        disablePullingRotation: '@',
        $onRefresh: '&onRefresh',
        $onPulling: '&onPulling'
      });
      function handleMousedown(e) {
        e.touches = e.touches || [{
          screenX: e.screenX,
          screenY: e.screenY
        }];
        startY = Math.floor(e.touches[0].screenY);
      }
      function handleTouchstart(e) {
        e.touches = e.touches || [{
          screenX: e.screenX,
          screenY: e.screenY
        }];
        startY = e.touches[0].screenY;
      }
      function handleTouchend() {
        startY = null;
        if (!canOverscroll && !isDragging) {
          return;
        }
        if (!isDragging) {
          dragOffset = 0;
          isOverscrolling = false;
          setScrollLock(false);
        } else {
          isDragging = false;
          dragOffset = 0;
          if (lastOverscroll > ptrThreshold) {
            start();
            scrollTo(ptrThreshold, scrollTime);
          } else {
            scrollTo(0, scrollTime, deactivate);
            isOverscrolling = false;
          }
        }
      }
      function handleTouchmove(e) {
        e.touches = e.touches || [{
          screenX: e.screenX,
          screenY: e.screenY
        }];
        if (!startY && e.type == 'mousemove') {
          return;
        }
        if (!canOverscroll || e.touches.length > 1) {
          return;
        }
        if (startY === null) {
          startY = e.touches[0].screenY;
        }
        deltaY = e.touches[0].screenY - startY;
        if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && !ionic.Platform.isCrosswalk() && scrollParent.scrollTop === 0 && deltaY > 0) {
          isDragging = true;
          e.preventDefault();
        }
        if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {
          if (isOverscrolling) {
            isOverscrolling = false;
            setScrollLock(false);
          }
          if (isDragging) {
            nativescroll(scrollParent, deltaY - dragOffset * -1);
          }
          if (lastOverscroll !== 0) {
            overscroll(0);
          }
          return;
        } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {
          dragOffset = deltaY;
        }
        e.preventDefault();
        if (!isOverscrolling) {
          isOverscrolling = true;
          setScrollLock(true);
        }
        isDragging = true;
        overscroll((deltaY - dragOffset) / 3);
        if (!activated && lastOverscroll > ptrThreshold) {
          activated = true;
          ionic.requestAnimationFrame(activate);
        } else if (activated && lastOverscroll < ptrThreshold) {
          activated = false;
          ionic.requestAnimationFrame(deactivate);
        }
      }
      function handleScroll(e) {
        canOverscroll = (e.target.scrollTop === 0) || isDragging;
      }
      function overscroll(val) {
        scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';
        lastOverscroll = val;
      }
      function nativescroll(target, newScrollTop) {
        target.scrollTop = newScrollTop;
        var e = document.createEvent("UIEvents");
        e.initUIEvent("scroll", true, true, window, 1);
        target.dispatchEvent(e);
      }
      function setScrollLock(enabled) {
        if (enabled) {
          ionic.requestAnimationFrame(function() {
            scrollChild.classList.add('overscroll');
            show();
          });
        } else {
          ionic.requestAnimationFrame(function() {
            scrollChild.classList.remove('overscroll');
            hide();
            deactivate();
          });
        }
      }
      $scope.$on('scroll.refreshComplete', function() {
        $timeout(function() {
          ionic.requestAnimationFrame(tail);
          scrollTo(0, scrollTime, deactivate);
          $timeout(function() {
            if (isOverscrolling) {
              isOverscrolling = false;
              setScrollLock(false);
            }
          }, scrollTime);
        }, scrollTime);
      });
      function scrollTo(Y, duration, callback) {
        var start = Date.now(),
            from = lastOverscroll;
        if (from === Y) {
          callback();
          return;
        }
        function easeOutCubic(t) {
          return (--t) * t * t + 1;
        }
        function scroll() {
          var currentTime = Date.now(),
              time = Math.min(1, ((currentTime - start) / duration)),
              easedT = easeOutCubic(time);
          overscroll(Math.floor((easedT * (Y - from)) + from));
          if (time < 1) {
            ionic.requestAnimationFrame(scroll);
          } else {
            if (Y < 5 && Y > -5) {
              isOverscrolling = false;
              setScrollLock(false);
            }
            callback && callback();
          }
        }
        ionic.requestAnimationFrame(scroll);
      }
      var touchStartEvent,
          touchMoveEvent,
          touchEndEvent;
      if (window.navigator.pointerEnabled) {
        touchStartEvent = 'pointerdown';
        touchMoveEvent = 'pointermove';
        touchEndEvent = 'pointerup';
      } else if (window.navigator.msPointerEnabled) {
        touchStartEvent = 'MSPointerDown';
        touchMoveEvent = 'MSPointerMove';
        touchEndEvent = 'MSPointerUp';
      } else {
        touchStartEvent = 'touchstart';
        touchMoveEvent = 'touchmove';
        touchEndEvent = 'touchend';
      }
      self.init = function() {
        scrollParent = $element.parent().parent()[0];
        scrollChild = $element.parent()[0];
        if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') || !scrollChild || !scrollChild.classList.contains('scroll')) {
          throw new Error('Refresher must be immediate child of ion-content or ion-scroll');
        }
        ionic.on(touchStartEvent, handleTouchstart, scrollChild);
        ionic.on(touchMoveEvent, handleTouchmove, scrollChild);
        ionic.on(touchEndEvent, handleTouchend, scrollChild);
        ionic.on('mousedown', handleMousedown, scrollChild);
        ionic.on('mousemove', handleTouchmove, scrollChild);
        ionic.on('mouseup', handleTouchend, scrollChild);
        ionic.on('scroll', handleScroll, scrollParent);
        $scope.$on('$destroy', destroy);
      };
      function destroy() {
        ionic.off(touchStartEvent, handleTouchstart, scrollChild);
        ionic.off(touchMoveEvent, handleTouchmove, scrollChild);
        ionic.off(touchEndEvent, handleTouchend, scrollChild);
        ionic.off('mousedown', handleMousedown, scrollChild);
        ionic.off('mousemove', handleTouchmove, scrollChild);
        ionic.off('mouseup', handleTouchend, scrollChild);
        ionic.off('scroll', handleScroll, scrollParent);
        scrollParent = null;
        scrollChild = null;
      }
      self.getRefresherDomMethods = function() {
        return {
          activate: activate,
          deactivate: deactivate,
          start: start,
          show: show,
          hide: hide,
          tail: tail
        };
      };
      function activate() {
        $element[0].classList.add('active');
        $scope.$onPulling();
      }
      function deactivate() {
        $timeout(function() {
          $element.removeClass('active refreshing refreshing-tail');
          if (activated)
            activated = false;
        }, 150);
      }
      function start() {
        $element[0].classList.add('refreshing');
        var q = $scope.$onRefresh();
        if (q && q.then) {
          q['finally'](function() {
            $scope.$broadcast('scroll.refreshComplete');
          });
        }
      }
      function show() {
        $element[0].classList.remove('invisible');
      }
      function hide() {
        $element[0].classList.add('invisible');
      }
      function tail() {
        $element[0].classList.add('refreshing-tail');
      }
      self.__handleTouchmove = handleTouchmove;
      self.__getScrollChild = function() {
        return scrollChild;
      };
      self.__getScrollParent = function() {
        return scrollParent;
      };
    }]);
    IonicModule.controller('$ionicScroll', ['$scope', 'scrollViewOptions', '$timeout', '$window', '$location', '$document', '$ionicScrollDelegate', '$ionicHistory', function($scope, scrollViewOptions, $timeout, $window, $location, $document, $ionicScrollDelegate, $ionicHistory) {
      var self = this;
      self.__timeout = $timeout;
      self._scrollViewOptions = scrollViewOptions;
      self.isNative = function() {
        return !!scrollViewOptions.nativeScrolling;
      };
      var element = self.element = scrollViewOptions.el;
      var $element = self.$element = jqLite(element);
      var scrollView;
      if (self.isNative()) {
        scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);
      } else {
        scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);
      }
      ($element.parent().length ? $element.parent() : $element).data('$$ionicScrollController', self);
      var deregisterInstance = $ionicScrollDelegate._registerInstance(self, scrollViewOptions.delegateHandle, function() {
        return $ionicHistory.isActiveScope($scope);
      });
      if (!isDefined(scrollViewOptions.bouncing)) {
        ionic.Platform.ready(function() {
          if (scrollView && scrollView.options) {
            scrollView.options.bouncing = true;
            if (ionic.Platform.isAndroid()) {
              scrollView.options.bouncing = false;
              scrollView.options.deceleration = 0.95;
            }
          }
        });
      }
      var resize = angular.bind(scrollView, scrollView.resize);
      angular.element($window).on('resize', resize);
      var scrollFunc = function(e) {
        var detail = (e.originalEvent || e).detail || {};
        $scope.$onScroll && $scope.$onScroll({
          event: e,
          scrollTop: detail.scrollTop || 0,
          scrollLeft: detail.scrollLeft || 0
        });
      };
      $element.on('scroll', scrollFunc);
      $scope.$on('$destroy', function() {
        deregisterInstance();
        scrollView && scrollView.__cleanup && scrollView.__cleanup();
        angular.element($window).off('resize', resize);
        $element.off('scroll', scrollFunc);
        scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;
      });
      $timeout(function() {
        scrollView && scrollView.run && scrollView.run();
      });
      self.getScrollView = function() {
        return scrollView;
      };
      self.getScrollPosition = function() {
        return scrollView.getValues();
      };
      self.resize = function() {
        return $timeout(resize, 0, false).then(function() {
          $element && $element.triggerHandler('scroll-resize');
        });
      };
      self.scrollTop = function(shouldAnimate) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          scrollView.scrollTo(0, 0, !!shouldAnimate);
        });
      };
      self.scrollBottom = function(shouldAnimate) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          var max = scrollView.getScrollMax();
          scrollView.scrollTo(max.left, max.top, !!shouldAnimate);
        });
      };
      self.scrollTo = function(left, top, shouldAnimate) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          scrollView.scrollTo(left, top, !!shouldAnimate);
        });
      };
      self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);
        });
      };
      self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);
        });
      };
      self.scrollBy = function(left, top, shouldAnimate) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          scrollView.scrollBy(left, top, !!shouldAnimate);
        });
      };
      self.anchorScroll = function(shouldAnimate) {
        self.resize().then(function() {
          if (!scrollView) {
            return;
          }
          var hash = $location.hash();
          var elm = hash && $document[0].getElementById(hash);
          if (!(hash && elm)) {
            scrollView.scrollTo(0, 0, !!shouldAnimate);
            return;
          }
          var curElm = elm;
          var scrollLeft = 0,
              scrollTop = 0;
          do {
            if (curElm !== null)
              scrollLeft += curElm.offsetLeft;
            if (curElm !== null)
              scrollTop += curElm.offsetTop;
            curElm = curElm.offsetParent;
          } while (curElm.attributes != self.element.attributes && curElm.offsetParent);
          scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);
        });
      };
      self.freezeScroll = scrollView.freeze;
      self.freezeScrollShut = scrollView.freezeShut;
      self.freezeAllScrolls = function(shouldFreeze) {
        for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {
          $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);
        }
      };
      self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {
        self.refresher = refresherElement;
        var refresherHeight = self.refresher.clientHeight || 60;
        scrollView.activatePullToRefresh(refresherHeight, refresherMethods);
      };
    }]);
    IonicModule.controller('$ionicSideMenus', ['$scope', '$attrs', '$ionicSideMenuDelegate', '$ionicPlatform', '$ionicBody', '$ionicHistory', '$ionicScrollDelegate', 'IONIC_BACK_PRIORITY', '$rootScope', function($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {
      var self = this;
      var rightShowing,
          leftShowing,
          isDragging;
      var startX,
          lastX,
          offsetX,
          isAsideExposed;
      var enableMenuWithBackViews = true;
      self.$scope = $scope;
      self.initialize = function(options) {
        self.left = options.left;
        self.right = options.right;
        self.setContent(options.content);
        self.dragThresholdX = options.dragThresholdX || 10;
        $ionicHistory.registerHistory(self.$scope);
      };
      self.setContent = function(content) {
        if (content) {
          self.content = content;
          self.content.onDrag = function(e) {
            self._handleDrag(e);
          };
          self.content.endDrag = function(e) {
            self._endDrag(e);
          };
        }
      };
      self.isOpenLeft = function() {
        return self.getOpenAmount() > 0;
      };
      self.isOpenRight = function() {
        return self.getOpenAmount() < 0;
      };
      self.toggleLeft = function(shouldOpen) {
        if (isAsideExposed || !self.left.isEnabled)
          return;
        var openAmount = self.getOpenAmount();
        if (arguments.length === 0) {
          shouldOpen = openAmount <= 0;
        }
        self.content.enableAnimation();
        if (!shouldOpen) {
          self.openPercentage(0);
          $rootScope.$emit('$ionicSideMenuClose', 'left');
        } else {
          self.openPercentage(100);
          $rootScope.$emit('$ionicSideMenuOpen', 'left');
        }
      };
      self.toggleRight = function(shouldOpen) {
        if (isAsideExposed || !self.right.isEnabled)
          return;
        var openAmount = self.getOpenAmount();
        if (arguments.length === 0) {
          shouldOpen = openAmount >= 0;
        }
        self.content.enableAnimation();
        if (!shouldOpen) {
          self.openPercentage(0);
          $rootScope.$emit('$ionicSideMenuClose', 'right');
        } else {
          self.openPercentage(-100);
          $rootScope.$emit('$ionicSideMenuOpen', 'right');
        }
      };
      self.toggle = function(side) {
        if (side == 'right') {
          self.toggleRight();
        } else {
          self.toggleLeft();
        }
      };
      self.close = function() {
        self.openPercentage(0);
        $rootScope.$emit('$ionicSideMenuClose', 'left');
        $rootScope.$emit('$ionicSideMenuClose', 'right');
      };
      self.getOpenAmount = function() {
        return self.content && self.content.getTranslateX() || 0;
      };
      self.getOpenRatio = function() {
        var amount = self.getOpenAmount();
        if (amount >= 0) {
          return amount / self.left.width;
        }
        return amount / self.right.width;
      };
      self.isOpen = function() {
        return self.getOpenAmount() !== 0;
      };
      self.getOpenPercentage = function() {
        return self.getOpenRatio() * 100;
      };
      self.openPercentage = function(percentage) {
        var p = percentage / 100;
        if (self.left && percentage >= 0) {
          self.openAmount(self.left.width * p);
        } else if (self.right && percentage < 0) {
          self.openAmount(self.right.width * p);
        }
        $ionicBody.enableClass((percentage !== 0), 'menu-open');
        self.content.setCanScroll(percentage == 0);
      };
      self.openAmount = function(amount) {
        var maxLeft = self.left && self.left.width || 0;
        var maxRight = self.right && self.right.width || 0;
        if (!(self.left && self.left.isEnabled) && amount > 0) {
          self.content.setTranslateX(0);
          return;
        }
        if (!(self.right && self.right.isEnabled) && amount < 0) {
          self.content.setTranslateX(0);
          return;
        }
        if (leftShowing && amount > maxLeft) {
          self.content.setTranslateX(maxLeft);
          return;
        }
        if (rightShowing && amount < -maxRight) {
          self.content.setTranslateX(-maxRight);
          return;
        }
        self.content.setTranslateX(amount);
        if (amount >= 0) {
          leftShowing = true;
          rightShowing = false;
          if (amount > 0) {
            self.right && self.right.pushDown && self.right.pushDown();
            self.left && self.left.bringUp && self.left.bringUp();
          }
        } else {
          rightShowing = true;
          leftShowing = false;
          self.right && self.right.bringUp && self.right.bringUp();
          self.left && self.left.pushDown && self.left.pushDown();
        }
      };
      self.snapToRest = function(e) {
        self.content.enableAnimation();
        isDragging = false;
        var ratio = self.getOpenRatio();
        if (ratio === 0) {
          self.openPercentage(0);
          return;
        }
        var velocityThreshold = 0.3;
        var velocityX = e.gesture.velocityX;
        var direction = e.gesture.direction;
        if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
          self.openPercentage(0);
        } else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {
          self.openPercentage(100);
        } else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {
          self.openPercentage(0);
        } else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {
          self.openPercentage(-100);
        } else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {
          self.openPercentage(100);
        } else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {
          self.openPercentage(-100);
        } else {
          self.openPercentage(0);
        }
      };
      self.enableMenuWithBackViews = function(val) {
        if (arguments.length) {
          enableMenuWithBackViews = !!val;
        }
        return enableMenuWithBackViews;
      };
      self.isAsideExposed = function() {
        return !!isAsideExposed;
      };
      self.exposeAside = function(shouldExposeAside) {
        if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled))
          return;
        self.close();
        isAsideExposed = shouldExposeAside;
        if ((self.left && self.left.isEnabled) && (self.right && self.right.isEnabled)) {
          self.content.setMarginLeftAndRight(isAsideExposed ? self.left.width : 0, isAsideExposed ? self.right.width : 0);
        } else if (self.left && self.left.isEnabled) {
          self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);
        } else if (self.right && self.right.isEnabled) {
          self.content.setMarginRight(isAsideExposed ? self.right.width : 0);
        }
        self.$scope.$emit('$ionicExposeAside', isAsideExposed);
      };
      self.activeAsideResizing = function(isResizing) {
        $ionicBody.enableClass(isResizing, 'aside-resizing');
      };
      self._endDrag = function(e) {
        if (isAsideExposed)
          return;
        if (isDragging) {
          self.snapToRest(e);
        }
        startX = null;
        lastX = null;
        offsetX = null;
      };
      self._handleDrag = function(e) {
        if (isAsideExposed || !$scope.dragContent)
          return;
        if (!startX) {
          startX = e.gesture.touches[0].pageX;
          lastX = startX;
        } else {
          lastX = e.gesture.touches[0].pageX;
        }
        if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {
          startX = lastX;
          isDragging = true;
          self.content.disableAnimation();
          offsetX = self.getOpenAmount();
        }
        if (isDragging) {
          self.openAmount(offsetX + (lastX - startX));
        }
      };
      self.canDragContent = function(canDrag) {
        if (arguments.length) {
          $scope.dragContent = !!canDrag;
        }
        return $scope.dragContent;
      };
      self.edgeThreshold = 25;
      self.edgeThresholdEnabled = false;
      self.edgeDragThreshold = function(value) {
        if (arguments.length) {
          if (isNumber(value) && value > 0) {
            self.edgeThreshold = value;
            self.edgeThresholdEnabled = true;
          } else {
            self.edgeThresholdEnabled = !!value;
          }
        }
        return self.edgeThresholdEnabled;
      };
      self.isDraggableTarget = function(e) {
        var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();
        var startX = e.gesture.startEvent && e.gesture.startEvent.center && e.gesture.startEvent.center.pageX;
        var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag || startX <= self.edgeThreshold || startX >= self.content.element.offsetWidth - self.edgeThreshold;
        var backView = $ionicHistory.backView();
        var menuEnabled = enableMenuWithBackViews ? true : !backView;
        if (!menuEnabled) {
          var currentView = $ionicHistory.currentView() || {};
          return (dragIsWithinBounds && (backView.historyId !== currentView.historyId));
        }
        return ($scope.dragContent || self.isOpen()) && dragIsWithinBounds && !e.gesture.srcEvent.defaultPrevented && menuEnabled && !e.target.tagName.match(/input|textarea|select|object|embed/i) && !e.target.isContentEditable && !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');
      };
      $scope.sideMenuContentTranslateX = 0;
      var deregisterBackButtonAction = noop;
      var closeSideMenu = angular.bind(self, self.close);
      $scope.$watch(function() {
        return self.getOpenAmount() !== 0;
      }, function(isOpen) {
        deregisterBackButtonAction();
        if (isOpen) {
          deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(closeSideMenu, IONIC_BACK_PRIORITY.sideMenu);
        }
      });
      var deregisterInstance = $ionicSideMenuDelegate._registerInstance(self, $attrs.delegateHandle, function() {
        return $ionicHistory.isActiveScope($scope);
      });
      $scope.$on('$destroy', function() {
        deregisterInstance();
        deregisterBackButtonAction();
        self.$scope = null;
        if (self.content) {
          self.content.setCanScroll(true);
          self.content.element = null;
          self.content = null;
        }
      });
      self.initialize({
        left: {width: 275},
        right: {width: 275}
      });
    }]);
    (function(ionic) {
      var TRANSLATE32 = 'translate(32,32)';
      var STROKE_OPACITY = 'stroke-opacity';
      var ROUND = 'round';
      var INDEFINITE = 'indefinite';
      var DURATION = '750ms';
      var NONE = 'none';
      var SHORTCUTS = {
        a: 'animate',
        an: 'attributeName',
        at: 'animateTransform',
        c: 'circle',
        da: 'stroke-dasharray',
        os: 'stroke-dashoffset',
        f: 'fill',
        lc: 'stroke-linecap',
        rc: 'repeatCount',
        sw: 'stroke-width',
        t: 'transform',
        v: 'values'
      };
      var SPIN_ANIMATION = {
        v: '0,32,32;360,32,32',
        an: 'transform',
        type: 'rotate',
        rc: INDEFINITE,
        dur: DURATION
      };
      function createSvgElement(tagName, data, parent, spinnerName) {
        var ele = document.createElement(SHORTCUTS[tagName] || tagName);
        var k,
            x,
            y;
        for (k in data) {
          if (angular.isArray(data[k])) {
            for (x = 0; x < data[k].length; x++) {
              if (data[k][x].fn) {
                for (y = 0; y < data[k][x].t; y++) {
                  createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);
                }
              } else {
                createSvgElement(k, data[k][x], ele, spinnerName);
              }
            }
          } else {
            setSvgAttribute(ele, k, data[k]);
          }
        }
        parent.appendChild(ele);
      }
      function setSvgAttribute(ele, k, v) {
        ele.setAttribute(SHORTCUTS[k] || k, v);
      }
      function animationValues(strValues, i) {
        var values = strValues.split(';');
        var back = values.slice(i);
        var front = values.slice(0, values.length - back.length);
        values = back.concat(front).reverse();
        return values.join(';') + ';' + values[0];
      }
      var IOS_SPINNER = {
        sw: 4,
        lc: ROUND,
        line: [{
          fn: function(i, spinnerName) {
            return {
              y1: spinnerName == 'ios' ? 17 : 12,
              y2: spinnerName == 'ios' ? 29 : 20,
              t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',
              a: [{
                fn: function() {
                  return {
                    an: STROKE_OPACITY,
                    dur: DURATION,
                    v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),
                    rc: INDEFINITE
                  };
                },
                t: 1
              }]
            };
          },
          t: 12
        }]
      };
      var spinners = {
        android: {c: [{
            sw: 6,
            da: 128,
            os: 82,
            r: 26,
            cx: 32,
            cy: 32,
            f: NONE
          }]},
        ios: IOS_SPINNER,
        'ios-small': IOS_SPINNER,
        bubbles: {
          sw: 0,
          c: [{
            fn: function(i) {
              return {
                cx: 24 * Math.cos(2 * Math.PI * i / 8),
                cy: 24 * Math.sin(2 * Math.PI * i / 8),
                t: TRANSLATE32,
                a: [{
                  fn: function() {
                    return {
                      an: 'r',
                      dur: DURATION,
                      v: animationValues('1;2;3;4;5;6;7;8', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 8
          }]
        },
        circles: {c: [{
            fn: function(i) {
              return {
                r: 5,
                cx: 24 * Math.cos(2 * Math.PI * i / 8),
                cy: 24 * Math.sin(2 * Math.PI * i / 8),
                t: TRANSLATE32,
                sw: 0,
                a: [{
                  fn: function() {
                    return {
                      an: 'fill-opacity',
                      dur: DURATION,
                      v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 8
          }]},
        crescent: {c: [{
            sw: 4,
            da: 128,
            os: 82,
            r: 26,
            cx: 32,
            cy: 32,
            f: NONE,
            at: [SPIN_ANIMATION]
          }]},
        dots: {c: [{
            fn: function(i) {
              return {
                cx: 16 + (16 * i),
                cy: 32,
                sw: 0,
                a: [{
                  fn: function() {
                    return {
                      an: 'fill-opacity',
                      dur: DURATION,
                      v: animationValues('.5;.6;.8;1;.8;.6;.5', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }, {
                  fn: function() {
                    return {
                      an: 'r',
                      dur: DURATION,
                      v: animationValues('4;5;6;5;4;3;3', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 3
          }]},
        lines: {
          sw: 7,
          lc: ROUND,
          line: [{
            fn: function(i) {
              return {
                x1: 10 + (i * 14),
                x2: 10 + (i * 14),
                a: [{
                  fn: function() {
                    return {
                      an: 'y1',
                      dur: DURATION,
                      v: animationValues('16;18;28;18;16', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }, {
                  fn: function() {
                    return {
                      an: 'y2',
                      dur: DURATION,
                      v: animationValues('48;44;36;46;48', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }, {
                  fn: function() {
                    return {
                      an: STROKE_OPACITY,
                      dur: DURATION,
                      v: animationValues('1;.8;.5;.4;1', i),
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 4
          }]
        },
        ripple: {
          f: NONE,
          'fill-rule': 'evenodd',
          sw: 3,
          circle: [{
            fn: function(i) {
              return {
                cx: 32,
                cy: 32,
                a: [{
                  fn: function() {
                    return {
                      an: 'r',
                      begin: (i * -1) + 's',
                      dur: '2s',
                      v: '0;24',
                      keyTimes: '0;1',
                      keySplines: '0.1,0.2,0.3,1',
                      calcMode: 'spline',
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }, {
                  fn: function() {
                    return {
                      an: STROKE_OPACITY,
                      begin: (i * -1) + 's',
                      dur: '2s',
                      v: '.2;1;.2;0',
                      rc: INDEFINITE
                    };
                  },
                  t: 1
                }]
              };
            },
            t: 2
          }]
        },
        spiral: {
          defs: [{linearGradient: [{
              id: 'sGD',
              gradientUnits: 'userSpaceOnUse',
              x1: 55,
              y1: 46,
              x2: 2,
              y2: 46,
              stop: [{
                offset: 0.1,
                class: 'stop1'
              }, {
                offset: 1,
                class: 'stop2'
              }]
            }]}],
          g: [{
            sw: 4,
            lc: ROUND,
            f: NONE,
            path: [{
              stroke: 'url(#sGD)',
              d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'
            }, {d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'}],
            at: [SPIN_ANIMATION]
          }]
        }
      };
      var animations = {android: function(ele) {
          var self = this;
          this.stop = false;
          var rIndex = 0;
          var rotateCircle = 0;
          var startTime;
          var svgEle = ele.querySelector('g');
          var circleEle = ele.querySelector('circle');
          function run() {
            if (self.stop)
              return;
            var v = easeInOutCubic(Date.now() - startTime, 650);
            var scaleX = 1;
            var translateX = 0;
            var dasharray = (188 - (58 * v));
            var dashoffset = (182 - (182 * v));
            if (rIndex % 2) {
              scaleX = -1;
              translateX = -64;
              dasharray = (128 - (-58 * v));
              dashoffset = (182 * v);
            }
            var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];
            setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));
            setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));
            setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');
            rotateCircle += 4.1;
            if (rotateCircle > 359)
              rotateCircle = 0;
            setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');
            if (v >= 1) {
              rIndex++;
              if (rIndex > 7)
                rIndex = 0;
              startTime = Date.now();
            }
            ionic.requestAnimationFrame(run);
          }
          return function() {
            startTime = Date.now();
            run();
            return self;
          };
        }};
      function easeInOutCubic(t, c) {
        t /= c / 2;
        if (t < 1)
          return 1 / 2 * t * t * t;
        t -= 2;
        return 1 / 2 * (t * t * t + 2);
      }
      IonicModule.controller('$ionicSpinner', ['$element', '$attrs', '$ionicConfig', function($element, $attrs, $ionicConfig) {
        var spinnerName,
            anim;
        this.init = function() {
          spinnerName = $attrs.icon || $ionicConfig.spinner.icon();
          var container = document.createElement('div');
          createSvgElement('svg', {
            viewBox: '0 0 64 64',
            g: [spinners[spinnerName]]
          }, container, spinnerName);
          $element.html(container.innerHTML);
          this.start();
          return spinnerName;
        };
        this.start = function() {
          animations[spinnerName] && (anim = animations[spinnerName]($element[0])());
        };
        this.stop = function() {
          animations[spinnerName] && (anim.stop = true);
        };
      }]);
    })(ionic);
    IonicModule.controller('$ionicTab', ['$scope', '$ionicHistory', '$attrs', '$location', '$state', function($scope, $ionicHistory, $attrs, $location, $state) {
      this.$scope = $scope;
      this.hrefMatchesState = function() {
        return $attrs.href && $location.path().indexOf($attrs.href.replace(/^#/, '').replace(/\/$/, '')) === 0;
      };
      this.srefMatchesState = function() {
        return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);
      };
      this.navNameMatchesState = function() {
        return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);
      };
      this.tabMatchesState = function() {
        return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();
      };
    }]);
    IonicModule.controller('$ionicTabs', ['$scope', '$element', '$ionicHistory', function($scope, $element, $ionicHistory) {
      var self = this;
      var selectedTab = null;
      var previousSelectedTab = null;
      var selectedTabIndex;
      var isVisible = true;
      self.tabs = [];
      self.selectedIndex = function() {
        return self.tabs.indexOf(selectedTab);
      };
      self.selectedTab = function() {
        return selectedTab;
      };
      self.previousSelectedTab = function() {
        return previousSelectedTab;
      };
      self.add = function(tab) {
        $ionicHistory.registerHistory(tab);
        self.tabs.push(tab);
      };
      self.remove = function(tab) {
        var tabIndex = self.tabs.indexOf(tab);
        if (tabIndex === -1) {
          return;
        }
        if (tab.$tabSelected) {
          self.deselect(tab);
          if (self.tabs.length === 1) {} else {
            var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;
            self.select(self.tabs[newTabIndex]);
          }
        }
        self.tabs.splice(tabIndex, 1);
      };
      self.deselect = function(tab) {
        if (tab.$tabSelected) {
          previousSelectedTab = selectedTab;
          selectedTab = selectedTabIndex = null;
          tab.$tabSelected = false;
          (tab.onDeselect || noop)();
          tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');
        }
      };
      self.select = function(tab, shouldEmitEvent) {
        var tabIndex;
        if (isNumber(tab)) {
          tabIndex = tab;
          if (tabIndex >= self.tabs.length)
            return;
          tab = self.tabs[tabIndex];
        } else {
          tabIndex = self.tabs.indexOf(tab);
        }
        if (arguments.length === 1) {
          shouldEmitEvent = !!(tab.navViewName || tab.uiSref);
        }
        if (selectedTab && selectedTab.$historyId == tab.$historyId) {
          if (shouldEmitEvent) {
            $ionicHistory.goToHistoryRoot(tab.$historyId);
          }
        } else if (selectedTabIndex !== tabIndex) {
          forEach(self.tabs, function(tab) {
            self.deselect(tab);
          });
          selectedTab = tab;
          selectedTabIndex = tabIndex;
          if (self.$scope && self.$scope.$parent) {
            self.$scope.$parent.$activeHistoryId = tab.$historyId;
          }
          tab.$tabSelected = true;
          (tab.onSelect || noop)();
          if (shouldEmitEvent) {
            $scope.$emit('$ionicHistory.change', {
              type: 'tab',
              tabIndex: tabIndex,
              historyId: tab.$historyId,
              navViewName: tab.navViewName,
              hasNavView: !!tab.navViewName,
              title: tab.title,
              url: tab.href,
              uiSref: tab.uiSref
            });
          }
        }
      };
      self.hasActiveScope = function() {
        for (var x = 0; x < self.tabs.length; x++) {
          if ($ionicHistory.isActiveScope(self.tabs[x])) {
            return true;
          }
        }
        return false;
      };
      self.showBar = function(show) {
        if (arguments.length) {
          if (show) {
            $element.removeClass('tabs-item-hide');
          } else {
            $element.addClass('tabs-item-hide');
          }
          isVisible = !!show;
        }
        return isVisible;
      };
    }]);
    IonicModule.controller('$ionicView', ['$scope', '$element', '$attrs', '$compile', '$rootScope', function($scope, $element, $attrs, $compile, $rootScope) {
      var self = this;
      var navElementHtml = {};
      var navViewCtrl;
      var navBarDelegateHandle;
      var hasViewHeaderBar;
      var deregisters = [];
      var viewTitle;
      var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {
        ev.stopPropagation();
        navBarDelegateHandle = delegateHandle;
      });
      self.init = function() {
        deregIonNavBarInit();
        var modalCtrl = $element.inheritedData('$ionModalController');
        navViewCtrl = $element.inheritedData('$ionNavViewController');
        if (!navViewCtrl || modalCtrl)
          return;
        $scope.$on('$ionicView.beforeEnter', self.beforeEnter);
        $scope.$on('$ionicView.afterEnter', afterEnter);
        $scope.$on('$ionicView.beforeLeave', deregisterFns);
      };
      self.beforeEnter = function(ev, transData) {
        if (transData && !transData.viewNotified) {
          transData.viewNotified = true;
          if (!$rootScope.$$phase)
            $scope.$digest();
          viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;
          var navBarItems = {};
          for (var n in navElementHtml) {
            navBarItems[n] = generateNavBarItem(navElementHtml[n]);
          }
          navViewCtrl.beforeEnter(extend(transData, {
            title: viewTitle,
            showBack: !attrTrue('hideBackButton'),
            navBarItems: navBarItems,
            navBarDelegate: navBarDelegateHandle || null,
            showNavBar: !attrTrue('hideNavBar'),
            hasHeaderBar: !!hasViewHeaderBar
          }));
          deregisterFns();
        }
      };
      function afterEnter() {
        var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';
        if (viewTitleAttr) {
          titleUpdate($attrs[viewTitleAttr]);
          deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));
        }
        if (isDefined($attrs.hideBackButton)) {
          deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {
            navViewCtrl.showBackButton(!val);
          }));
        }
        if (isDefined($attrs.hideNavBar)) {
          deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {
            navViewCtrl.showBar(!val);
          }));
        }
      }
      function titleUpdate(newTitle) {
        if (isDefined(newTitle) && newTitle !== viewTitle) {
          viewTitle = newTitle;
          navViewCtrl.title(viewTitle);
        }
      }
      function deregisterFns() {
        for (var x = 0; x < deregisters.length; x++) {
          deregisters[x]();
        }
        deregisters = [];
      }
      function generateNavBarItem(html) {
        if (html) {
          return $compile(html)($scope.$new());
        }
      }
      function attrTrue(key) {
        return !!$scope.$eval($attrs[key]);
      }
      self.navElement = function(type, html) {
        navElementHtml[type] = html;
      };
    }]);
    IonicModule.directive('ionActionSheet', ['$document', function($document) {
      return {
        restrict: 'E',
        scope: true,
        replace: true,
        link: function($scope, $element) {
          var keyUp = function(e) {
            if (e.which == 27) {
              $scope.cancel();
              $scope.$apply();
            }
          };
          var backdropClick = function(e) {
            if (e.target == $element[0]) {
              $scope.cancel();
              $scope.$apply();
            }
          };
          $scope.$on('$destroy', function() {
            $element.remove();
            $document.unbind('keyup', keyUp);
          });
          $document.bind('keyup', keyUp);
          $element.bind('click', backdropClick);
        },
        template: '<div class="action-sheet-backdrop">' + '<div class="action-sheet-wrapper">' + '<div class="action-sheet" ng-class="{\'action-sheet-has-icons\': $actionSheetHasIcon}">' + '<div class="action-sheet-group action-sheet-options">' + '<div class="action-sheet-title" ng-if="titleText" ng-bind-html="titleText"></div>' + '<button class="button action-sheet-option" ng-click="buttonClicked($index)" ng-class="b.className" ng-repeat="b in buttons" ng-bind-html="b.text"></button>' + '<button class="button destructive action-sheet-destructive" ng-if="destructiveText" ng-click="destructiveButtonClicked()" ng-bind-html="destructiveText"></button>' + '</div>' + '<div class="action-sheet-group action-sheet-cancel" ng-if="cancelText">' + '<button class="button" ng-click="cancel()" ng-bind-html="cancelText"></button>' + '</div>' + '</div>' + '</div>' + '</div>'
      };
    }]);
    IonicModule.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {
      return {
        restrict: 'E',
        replace: true,
        require: '?ngModel',
        transclude: true,
        template: '<label class="item item-checkbox">' + '<div class="checkbox checkbox-input-hidden disable-pointer-events">' + '<input type="checkbox">' + '<i class="checkbox-icon"></i>' + '</div>' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '</label>',
        compile: function(element, attr) {
          var input = element.find('input');
          forEach({
            'name': attr.name,
            'ng-value': attr.ngValue,
            'ng-model': attr.ngModel,
            'ng-checked': attr.ngChecked,
            'ng-disabled': attr.ngDisabled,
            'ng-true-value': attr.ngTrueValue,
            'ng-false-value': attr.ngFalseValue,
            'ng-change': attr.ngChange,
            'ng-required': attr.ngRequired,
            'required': attr.required
          }, function(value, name) {
            if (isDefined(value)) {
              input.attr(name, value);
            }
          });
          var checkboxWrapper = element[0].querySelector('.checkbox');
          checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());
        }
      };
    }]);
    IonicModule.directive('collectionRepeat', CollectionRepeatDirective).factory('$ionicCollectionManager', RepeatManagerFactory);
    var ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
    var WIDTH_HEIGHT_REGEX = /height:.*?px;\s*width:.*?px/;
    var DEFAULT_RENDER_BUFFER = 3;
    CollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];
    function CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {
      return {
        restrict: 'A',
        priority: 1000,
        transclude: 'element',
        $$tlb: true,
        require: '^^$ionicScroll',
        link: postLink
      };
      function postLink(scope, element, attr, scrollCtrl, transclude) {
        var scrollView = scrollCtrl.scrollView;
        var node = element[0];
        var containerNode = angular.element('<div class="collection-repeat-container">')[0];
        node.parentNode.replaceChild(containerNode, node);
        if (scrollView.options.scrollingX && scrollView.options.scrollingY) {
          throw new Error("collection-repeat expected a parent x or y scrollView, not " + "an xy scrollView.");
        }
        var repeatExpr = attr.collectionRepeat;
        var match = repeatExpr.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
        if (!match) {
          throw new Error("collection-repeat expected expression in form of '_item_ in " + "_collection_[ track by _id_]' but got '" + attr.collectionRepeat + "'.");
        }
        var keyExpr = match[1];
        var listExpr = match[2];
        var listGetter = $parse(listExpr);
        var heightData = {};
        var widthData = {};
        var computedStyleDimensions = {};
        var data = [];
        var repeatManager;
        var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;
        var renderBuffer = angular.isDefined(renderBufferExpr) ? parseInt(renderBufferExpr) : DEFAULT_RENDER_BUFFER;
        var heightExpr = attr.itemHeight || attr.collectionItemHeight;
        var widthExpr = attr.itemWidth || attr.collectionItemWidth;
        var afterItemsContainer = initAfterItemsContainer();
        var changeValidator = makeChangeValidator();
        initDimensions();
        scrollCtrl.$element.on('scroll-resize', refreshDimensions);
        angular.element($window).on('resize', onResize);
        var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {
          scrollCtrl.scrollView.resize();
          onResize();
        }));
        $timeout(refreshDimensions, 0, false);
        function onResize() {
          if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {
            refreshDimensions();
          }
        }
        scope.$watchCollection(listGetter, function(newValue) {
          data = newValue || (newValue = []);
          if (!angular.isArray(newValue)) {
            throw new Error("collection-repeat expected an array for '" + listExpr + "', " + "but got a " + typeof value);
          }
          scope.$$postDigest(function() {
            getRepeatManager().setData(data);
            if (changeValidator.dataChangeRequiresRefresh(data))
              refreshDimensions();
          });
        });
        scope.$on('$destroy', function() {
          angular.element($window).off('resize', onResize);
          unlistenToExposeAside();
          scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);
          computedStyleNode && computedStyleNode.parentNode && computedStyleNode.parentNode.removeChild(computedStyleNode);
          computedStyleScope && computedStyleScope.$destroy();
          computedStyleScope = computedStyleNode = null;
          repeatManager && repeatManager.destroy();
          repeatManager = null;
        });
        function makeChangeValidator() {
          var self;
          return (self = {
            dataLength: 0,
            width: 0,
            height: 0,
            resizeRequiresRefresh: function(newWidth, newHeight) {
              var requiresRefresh = self.dataLength && newWidth && newHeight && (newWidth !== self.width || newHeight !== self.height);
              self.width = newWidth;
              self.height = newHeight;
              return !!requiresRefresh;
            },
            dataChangeRequiresRefresh: function(newData) {
              var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;
              self.dataLength = newData.length;
              return !!requiresRefresh;
            }
          });
        }
        function getRepeatManager() {
          return repeatManager || (repeatManager = new $ionicCollectionManager({
            afterItemsNode: afterItemsContainer[0],
            containerNode: containerNode,
            heightData: heightData,
            widthData: widthData,
            forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),
            keyExpression: keyExpr,
            renderBuffer: renderBuffer,
            scope: scope,
            scrollView: scrollCtrl.scrollView,
            transclude: transclude
          }));
        }
        function initAfterItemsContainer() {
          var container = angular.element(scrollView.__content.querySelector('.collection-repeat-after-container'));
          if (!container.length) {
            var elementIsAfterRepeater = false;
            var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {
              if (ionic.DomUtil.contains(node, containerNode)) {
                elementIsAfterRepeater = true;
                return false;
              }
              return elementIsAfterRepeater;
            });
            container = angular.element('<span class="collection-repeat-after-container">');
            if (scrollView.options.scrollingX) {
              container.addClass('horizontal');
            }
            container.append(afterNodes);
            scrollView.__content.appendChild(container[0]);
          }
          return container;
        }
        function initDimensions() {
          if (heightExpr) {
            parseDimensionAttr(heightExpr, heightData);
          } else {
            heightData.computed = true;
          }
          if (widthExpr) {
            parseDimensionAttr(widthExpr, widthData);
          } else {
            widthData.computed = true;
          }
        }
        function refreshDimensions() {
          var hasData = data.length > 0;
          if (hasData && (heightData.computed || widthData.computed)) {
            computeStyleDimensions();
          }
          if (hasData && heightData.computed) {
            heightData.value = computedStyleDimensions.height;
            if (!heightData.value) {
              throw new Error('collection-repeat tried to compute the height of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-height" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
            }
          } else if (!heightData.dynamic && heightData.getValue) {
            heightData.value = heightData.getValue();
          }
          if (hasData && widthData.computed) {
            widthData.value = computedStyleDimensions.width;
            if (!widthData.value) {
              throw new Error('collection-repeat tried to compute the width of repeated elements "' + repeatExpr + '", but was unable to. Please provide the "item-width" attribute. ' + 'http://ionicframework.com/docs/api/directive/collectionRepeat/');
            }
          } else if (!widthData.dynamic && widthData.getValue) {
            widthData.value = widthData.getValue();
          }
          getRepeatManager().refreshLayout();
        }
        function parseDimensionAttr(attrValue, dimensionData) {
          if (!attrValue)
            return;
          var parsedValue;
          try {
            parsedValue = $parse(attrValue);
          } catch (e) {
            if (attrValue.trim().match(/\d+(px|%)$/)) {
              attrValue = '"' + attrValue + '"';
            }
            parsedValue = $parse(attrValue);
          }
          var constantAttrValue = attrValue.replace(/(\'|\"|px|%)/g, '').trim();
          var isConstant = constantAttrValue.length && !/([a-zA-Z]|\$|:|\?)/.test(constantAttrValue);
          dimensionData.attrValue = attrValue;
          if (isConstant) {
            if (attrValue.indexOf('%') > -1) {
              var decimalValue = parseFloat(parsedValue()) / 100;
              dimensionData.getValue = dimensionData === heightData ? function() {
                return Math.floor(decimalValue * scrollView.__clientHeight);
              } : function() {
                return Math.floor(decimalValue * scrollView.__clientWidth);
              };
            } else {
              dimensionData.value = parseInt(parsedValue());
            }
          } else {
            dimensionData.dynamic = true;
            dimensionData.getValue = dimensionData === heightData ? function heightGetter(scope, locals) {
              var result = parsedValue(scope, locals);
              if (result.charAt && result.charAt(result.length - 1) === '%') {
                return Math.floor(parseFloat(result) / 100 * scrollView.__clientHeight);
              }
              return parseInt(result);
            } : function widthGetter(scope, locals) {
              var result = parsedValue(scope, locals);
              if (result.charAt && result.charAt(result.length - 1) === '%') {
                return Math.floor(parseFloat(result) / 100 * scrollView.__clientWidth);
              }
              return parseInt(result);
            };
          }
        }
        var computedStyleNode;
        var computedStyleScope;
        function computeStyleDimensions() {
          if (!computedStyleNode) {
            transclude(computedStyleScope = scope.$new(), function(clone) {
              clone[0].removeAttribute('collection-repeat');
              computedStyleNode = clone[0];
            });
          }
          computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];
          if (!$rootScope.$$phase)
            computedStyleScope.$digest();
          containerNode.appendChild(computedStyleNode);
          var style = $window.getComputedStyle(computedStyleNode);
          computedStyleDimensions.width = parseInt(style.width);
          computedStyleDimensions.height = parseInt(style.height);
          containerNode.removeChild(computedStyleNode);
        }
      }
    }
    RepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];
    function RepeatManagerFactory($rootScope, $window, $$rAF) {
      var EMPTY_DIMENSION = {
        primaryPos: 0,
        secondaryPos: 0,
        primarySize: 0,
        secondarySize: 0,
        rowPrimarySize: 0
      };
      return function RepeatController(options) {
        var afterItemsNode = options.afterItemsNode;
        var containerNode = options.containerNode;
        var forceRefreshImages = options.forceRefreshImages;
        var heightData = options.heightData;
        var widthData = options.widthData;
        var keyExpression = options.keyExpression;
        var renderBuffer = options.renderBuffer;
        var scope = options.scope;
        var scrollView = options.scrollView;
        var transclude = options.transclude;
        var data = [];
        var getterLocals = {};
        var heightFn = heightData.getValue || function() {
          return heightData.value;
        };
        var heightGetter = function(index, value) {
          getterLocals[keyExpression] = value;
          getterLocals.$index = index;
          return heightFn(scope, getterLocals);
        };
        var widthFn = widthData.getValue || function() {
          return widthData.value;
        };
        var widthGetter = function(index, value) {
          getterLocals[keyExpression] = value;
          getterLocals.$index = index;
          return widthFn(scope, getterLocals);
        };
        var isVertical = !!scrollView.options.scrollingY;
        var isGridView = isVertical ? (widthData.dynamic || widthData.value !== scrollView.__clientWidth) : (heightData.dynamic || heightData.value !== scrollView.__clientHeight);
        var isStaticView = !heightData.dynamic && !widthData.dynamic;
        var PRIMARY = 'PRIMARY';
        var SECONDARY = 'SECONDARY';
        var TRANSLATE_TEMPLATE_STR = isVertical ? 'translate3d(SECONDARYpx,PRIMARYpx,0)' : 'translate3d(PRIMARYpx,SECONDARYpx,0)';
        var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ? 'height: PRIMARYpx; width: SECONDARYpx;' : 'height: SECONDARYpx; width: PRIMARYpx;';
        var estimatedHeight;
        var estimatedWidth;
        var repeaterBeforeSize = 0;
        var repeaterAfterSize = 0;
        var renderStartIndex = -1;
        var renderEndIndex = -1;
        var renderAfterBoundary = -1;
        var renderBeforeBoundary = -1;
        var itemsPool = [];
        var itemsLeaving = [];
        var itemsEntering = [];
        var itemsShownMap = {};
        var nextItemId = 0;
        var scrollViewSetDimensions = isVertical ? function() {
          scrollView.setDimensions(null, null, null, view.getContentSize(), true);
        } : function() {
          scrollView.setDimensions(null, null, view.getContentSize(), null, true);
        };
        var view = isVertical ? new VerticalViewType() : new HorizontalViewType();
        (isGridView ? GridViewType : ListViewType).call(view);
        (isStaticView ? StaticViewType : DynamicViewType).call(view);
        var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';
        var originalGetContentSize = scrollView.options[contentSizeStr];
        scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);
        scrollView.__$callback = scrollView.__callback;
        scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {
          var scrollValue = view.getScrollValue();
          if (renderStartIndex === -1 || scrollValue + view.scrollPrimarySize > renderAfterBoundary || scrollValue < renderBeforeBoundary) {
            render();
          }
          scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);
        };
        var isLayoutReady = false;
        var isDataReady = false;
        this.refreshLayout = function() {
          if (data.length) {
            estimatedHeight = heightGetter(0, data[0]);
            estimatedWidth = widthGetter(0, data[0]);
          } else {
            estimatedHeight = 100;
            estimatedWidth = 100;
          }
          var style = getComputedStyle(afterItemsNode) || {};
          var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};
          var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};
          repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) + (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) + (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);
          repeaterBeforeSize = 0;
          var current = containerNode;
          do {
            repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];
          } while (ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent));
          var containerPrevNode = containerNode.previousElementSibling;
          var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};
          var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);
          containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, -beforeMargin).replace(SECONDARY, 0);
          repeaterBeforeSize -= beforeMargin;
          if (!scrollView.__clientHeight || !scrollView.__clientWidth) {
            scrollView.__clientWidth = scrollView.__container.clientWidth;
            scrollView.__clientHeight = scrollView.__container.clientHeight;
          }
          (view.onRefreshLayout || angular.noop)();
          view.refreshDirection();
          scrollViewSetDimensions();
          if (!isLayoutReady) {
            var poolSize = Math.max(20, renderBuffer * 3);
            for (var i = 0; i < poolSize; i++) {
              itemsPool.push(new RepeatItem());
            }
          }
          isLayoutReady = true;
          if (isLayoutReady && isDataReady) {
            if (scrollView.__scrollLeft > scrollView.__maxScrollLeft || scrollView.__scrollTop > scrollView.__maxScrollTop) {
              scrollView.resize();
            }
            forceRerender(true);
          }
        };
        this.setData = function(newData) {
          data = newData;
          (view.onRefreshData || angular.noop)();
          isDataReady = true;
        };
        this.destroy = function() {
          render.destroyed = true;
          itemsPool.forEach(function(item) {
            item.scope.$destroy();
            item.scope = item.element = item.node = item.images = null;
          });
          itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;
          itemsShownMap = {};
          scrollView.options[contentSizeStr] = originalGetContentSize;
          scrollView.__callback = scrollView.__$callback;
          scrollView.resize();
          (view.onDestroy || angular.noop)();
        };
        function forceRerender() {
          return render(true);
        }
        function render(forceRerender) {
          if (render.destroyed)
            return;
          var i;
          var ii;
          var item;
          var dim;
          var scope;
          var scrollValue = view.getScrollValue();
          var scrollValueEnd = scrollValue + view.scrollPrimarySize;
          view.updateRenderRange(scrollValue, scrollValueEnd);
          renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);
          renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);
          for (i in itemsShownMap) {
            if (i < renderStartIndex || i > renderEndIndex) {
              item = itemsShownMap[i];
              delete itemsShownMap[i];
              itemsLeaving.push(item);
              item.isShown = false;
            }
          }
          for (i = renderStartIndex; i <= renderEndIndex; i++) {
            if (i >= data.length || (itemsShownMap[i] && !forceRerender))
              continue;
            item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() : itemsPool.length ? itemsPool.shift() : new RepeatItem());
            itemsEntering.push(item);
            item.isShown = true;
            scope = item.scope;
            scope.$index = i;
            scope[keyExpression] = data[i];
            scope.$first = (i === 0);
            scope.$last = (i === (data.length - 1));
            scope.$middle = !(scope.$first || scope.$last);
            scope.$odd = !(scope.$even = (i & 1) === 0);
            if (scope.$$disconnected)
              ionic.Utils.reconnectScope(item.scope);
            dim = view.getDimensions(i);
            if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {
              item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, (item.primaryPos = dim.primaryPos)).replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));
            }
            if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {
              item.node.style.cssText = item.node.style.cssText.replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR.replace(PRIMARY, (item.primarySize = dim.primarySize) + 1).replace(SECONDARY, (item.secondarySize = dim.secondarySize)));
            }
          }
          if (renderEndIndex === data.length - 1) {
            dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;
            afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR.replace(PRIMARY, dim.primaryPos + dim.primarySize).replace(SECONDARY, 0);
          }
          while (itemsLeaving.length) {
            item = itemsLeaving.pop();
            item.scope.$broadcast('$collectionRepeatLeave');
            ionic.Utils.disconnectScope(item.scope);
            itemsPool.push(item);
            item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
            item.primaryPos = item.secondaryPos = null;
          }
          if (forceRefreshImages) {
            for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {
              if (!item.images)
                continue;
              for (var j = 0,
                  jj = item.images.length,
                  img; j < jj && (img = item.images[j]); j++) {
                var src = img.src;
                img.src = ONE_PX_TRANSPARENT_IMG_SRC;
                img.src = src;
              }
            }
          }
          if (forceRerender) {
            var rootScopePhase = $rootScope.$$phase;
            while (itemsEntering.length) {
              item = itemsEntering.pop();
              if (!rootScopePhase)
                item.scope.$digest();
            }
          } else {
            digestEnteringItems();
          }
        }
        function digestEnteringItems() {
          var item;
          if (digestEnteringItems.running)
            return;
          digestEnteringItems.running = true;
          $$rAF(function process() {
            var rootScopePhase = $rootScope.$$phase;
            while (itemsEntering.length) {
              item = itemsEntering.pop();
              if (item.isShown) {
                if (!rootScopePhase)
                  item.scope.$digest();
              }
            }
            digestEnteringItems.running = false;
          });
        }
        function RepeatItem() {
          var self = this;
          this.scope = scope.$new();
          this.id = 'item' + (nextItemId++);
          transclude(this.scope, function(clone) {
            self.element = clone;
            self.element.data('$$collectionRepeatItem', self);
            self.node = clone[0];
            self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';
            self.node.style.cssText += ' height: 0px; width: 0px;';
            ionic.Utils.disconnectScope(self.scope);
            containerNode.appendChild(self.node);
            self.images = clone[0].getElementsByTagName('img');
          });
        }
        function VerticalViewType() {
          this.getItemPrimarySize = heightGetter;
          this.getItemSecondarySize = widthGetter;
          this.getScrollValue = function() {
            return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize, scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));
          };
          this.refreshDirection = function() {
            this.scrollPrimarySize = scrollView.__clientHeight;
            this.scrollSecondarySize = scrollView.__clientWidth;
            this.estimatedPrimarySize = estimatedHeight;
            this.estimatedSecondarySize = estimatedWidth;
            this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientWidth / estimatedWidth) || 1;
          };
        }
        function HorizontalViewType() {
          this.getItemPrimarySize = widthGetter;
          this.getItemSecondarySize = heightGetter;
          this.getScrollValue = function() {
            return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize, scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));
          };
          this.refreshDirection = function() {
            this.scrollPrimarySize = scrollView.__clientWidth;
            this.scrollSecondarySize = scrollView.__clientHeight;
            this.estimatedPrimarySize = estimatedWidth;
            this.estimatedSecondarySize = estimatedHeight;
            this.estimatedItemsAcross = isGridView && Math.floor(scrollView.__clientHeight / estimatedHeight) || 1;
          };
        }
        function GridViewType() {
          this.getEstimatedSecondaryPos = function(index) {
            return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;
          };
          this.getEstimatedPrimaryPos = function(index) {
            return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;
          };
          this.getEstimatedIndex = function(scrollValue) {
            return Math.floor(scrollValue / this.estimatedPrimarySize) * this.estimatedItemsAcross;
          };
        }
        function ListViewType() {
          this.getEstimatedSecondaryPos = function() {
            return 0;
          };
          this.getEstimatedPrimaryPos = function(index) {
            return index * this.estimatedPrimarySize;
          };
          this.getEstimatedIndex = function(scrollValue) {
            return Math.floor((scrollValue) / this.estimatedPrimarySize);
          };
        }
        function StaticViewType() {
          this.getContentSize = function() {
            return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize + repeaterBeforeSize + repeaterAfterSize;
          };
          var dim = {};
          this.getDimensions = function(index) {
            dim.primaryPos = this.getEstimatedPrimaryPos(index);
            dim.secondaryPos = this.getEstimatedSecondaryPos(index);
            dim.primarySize = this.estimatedPrimarySize;
            dim.secondarySize = this.estimatedSecondarySize;
            return dim;
          };
          this.updateRenderRange = function(scrollValue, scrollValueEnd) {
            renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));
            renderEndIndex = Math.min(data.length - 1, this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);
            renderBeforeBoundary = Math.max(0, this.getEstimatedPrimaryPos(renderStartIndex));
            renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) + this.estimatedPrimarySize;
          };
        }
        function DynamicViewType() {
          var self = this;
          var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);
          var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;
          var dimensionsIndex;
          var dimensions = [];
          function calculateDimensionsList(toIndex) {
            var i,
                prevDimension,
                dim;
            for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {
              prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
              dim.primarySize = self.getItemPrimarySize(i, data[i]);
              dim.secondarySize = self.scrollSecondarySize;
              dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;
              dim.secondaryPos = 0;
            }
          }
          function calculateDimensionsGrid(toIndex) {
            var i,
                prevDimension,
                dim;
            for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {
              prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;
              dim.secondarySize = Math.min(self.getItemSecondarySize(i, data[i]), self.scrollSecondarySize);
              dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;
              if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {
                dim.secondaryPos = 0;
                dim.primarySize = self.getItemPrimarySize(i, data[i]);
                dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;
                dim.rowStartIndex = i;
                dim.rowPrimarySize = dim.primarySize;
              } else {
                dim.primarySize = self.getItemPrimarySize(i, data[i]);
                dim.primaryPos = prevDimension.primaryPos;
                dim.rowStartIndex = prevDimension.rowStartIndex;
                dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(dimensions[dim.rowStartIndex].rowPrimarySize, dim.primarySize);
                dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);
              }
            }
          }
          this.getContentSize = function() {
            var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;
            return ((dim.primaryPos + dim.primarySize) || 0) + this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) + repeaterBeforeSize + repeaterAfterSize;
          };
          this.onDestroy = function() {
            dimensions.length = 0;
          };
          this.onRefreshData = function() {
            var i;
            var ii;
            for (i = dimensions.length, ii = data.length; i < ii; i++) {
              dimensions.push({});
            }
            dimensionsIndex = -1;
          };
          this.onRefreshLayout = function() {
            dimensionsIndex = -1;
          };
          this.getDimensions = function(index) {
            index = Math.min(index, data.length - 1);
            if (dimensionsIndex < index) {
              if (index > data.length * 0.9) {
                calculateDimensions(data.length - 1);
                dimensionsIndex = data.length - 1;
                scrollViewSetDimensions();
              } else {
                calculateDimensions(index);
                dimensionsIndex = index;
                debouncedScrollViewSetDimensions();
              }
            }
            return dimensions[index];
          };
          var oldRenderStartIndex = -1;
          var oldScrollValue = -1;
          this.updateRenderRange = function(scrollValue, scrollValueEnd) {
            var i;
            var len;
            var dim;
            this.getDimensions(this.getEstimatedIndex(scrollValueEnd) * 2);
            if (oldRenderStartIndex === -1 || scrollValue === 0) {
              i = 0;
            } else if (scrollValue >= oldScrollValue) {
              for (i = oldRenderStartIndex, len = data.length; i < len; i++) {
                if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {
                  break;
                }
              }
            } else {
              for (i = oldRenderStartIndex; i >= 0; i--) {
                if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {
                  i = isGridView ? dim.rowStartIndex : i;
                  break;
                }
              }
            }
            renderStartIndex = Math.min(Math.max(0, i), data.length - 1);
            renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;
            var lastRowDim;
            for (i = renderStartIndex + 1, len = data.length; i < len; i++) {
              if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {
                if (isGridView) {
                  lastRowDim = dim;
                  while (i < len - 1 && (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {
                    i++;
                  }
                }
                break;
              }
            }
            renderEndIndex = Math.min(i, data.length - 1);
            renderAfterBoundary = renderEndIndex !== -1 ? ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) : -1;
            oldScrollValue = scrollValue;
            oldRenderStartIndex = renderStartIndex;
          };
        }
      };
    }
    IonicModule.directive('ionContent', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
      return {
        restrict: 'E',
        require: '^?ionNavView',
        scope: true,
        priority: 800,
        compile: function(element, attr) {
          var innerElement;
          var scrollCtrl;
          element.addClass('scroll-content ionic-scroll');
          if (attr.scroll != 'false') {
            innerElement = jqLite('<div class="scroll"></div>');
            innerElement.append(element.contents());
            element.append(innerElement);
          } else {
            element.addClass('scroll-content-false');
          }
          var nativeScrolling = attr.overflowScroll !== "false" && (attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling());
          if (nativeScrolling) {
            nativeScrolling = !element[0].querySelector('[collection-repeat]');
          }
          return {pre: prelink};
          function prelink($scope, $element, $attr) {
            var parentScope = $scope.$parent;
            $scope.$watch(function() {
              return (parentScope.$hasHeader ? ' has-header' : '') + (parentScope.$hasSubheader ? ' has-subheader' : '') + (parentScope.$hasFooter ? ' has-footer' : '') + (parentScope.$hasSubfooter ? ' has-subfooter' : '') + (parentScope.$hasTabs ? ' has-tabs' : '') + (parentScope.$hasTabsTop ? ' has-tabs-top' : '');
            }, function(className, oldClassName) {
              $element.removeClass(oldClassName);
              $element.addClass(className);
            });
            $scope.$hasHeader = $scope.$hasSubheader = $scope.$hasFooter = $scope.$hasSubfooter = $scope.$hasTabs = $scope.$hasTabsTop = false;
            $ionicBind($scope, $attr, {
              $onScroll: '&onScroll',
              $onScrollComplete: '&onScrollComplete',
              hasBouncing: '@',
              padding: '@',
              direction: '@',
              scrollbarX: '@',
              scrollbarY: '@',
              startX: '@',
              startY: '@',
              scrollEventInterval: '@'
            });
            $scope.direction = $scope.direction || 'y';
            if (isDefined($attr.padding)) {
              $scope.$watch($attr.padding, function(newVal) {
                (innerElement || $element).toggleClass('padding', !!newVal);
              });
            }
            if ($attr.scroll === "false") {} else {
              var scrollViewOptions = {};
              if (nativeScrolling) {
                $element.addClass('overflow-scroll');
                scrollViewOptions = {
                  el: $element[0],
                  delegateHandle: attr.delegateHandle,
                  startX: $scope.$eval($scope.startX) || 0,
                  startY: $scope.$eval($scope.startY) || 0,
                  nativeScrolling: true
                };
              } else {
                scrollViewOptions = {
                  el: $element[0],
                  delegateHandle: attr.delegateHandle,
                  locking: (attr.locking || 'true') === 'true',
                  bouncing: $scope.$eval($scope.hasBouncing),
                  startX: $scope.$eval($scope.startX) || 0,
                  startY: $scope.$eval($scope.startY) || 0,
                  scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
                  scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
                  scrollingX: $scope.direction.indexOf('x') >= 0,
                  scrollingY: $scope.direction.indexOf('y') >= 0,
                  scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,
                  scrollingComplete: onScrollComplete
                };
              }
              scrollCtrl = $controller('$ionicScroll', {
                $scope: $scope,
                scrollViewOptions: scrollViewOptions
              });
              $scope.scrollCtrl = scrollCtrl;
              $scope.$on('$destroy', function() {
                if (scrollViewOptions) {
                  scrollViewOptions.scrollingComplete = noop;
                  delete scrollViewOptions.el;
                }
                innerElement = null;
                $element = null;
                attr.$$element = null;
              });
            }
            function onScrollComplete() {
              $scope.$onScrollComplete({
                scrollTop: scrollCtrl.scrollView.__scrollTop,
                scrollLeft: scrollCtrl.scrollView.__scrollLeft
              });
            }
          }
        }
      };
    }]);
    IonicModule.directive('exposeAsideWhen', ['$window', function($window) {
      return {
        restrict: 'A',
        require: '^ionSideMenus',
        link: function($scope, $element, $attr, sideMenuCtrl) {
          var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;
          var mql = $window.matchMedia(mq);
          mql.addListener(function() {
            onResize();
          });
          function checkAsideExpose() {
            var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;
            sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);
            sideMenuCtrl.activeAsideResizing(false);
          }
          function onResize() {
            sideMenuCtrl.activeAsideResizing(true);
            debouncedCheck();
          }
          var debouncedCheck = ionic.debounce(function() {
            $scope.$apply(checkAsideExpose);
          }, 300, false);
          $scope.$evalAsync(checkAsideExpose);
        }
      };
    }]);
    var GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');
    GESTURE_DIRECTIVES.forEach(function(name) {
      IonicModule.directive(name, gestureDirective(name));
    });
    function gestureDirective(directiveName) {
      return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {
        var eventType = directiveName.substr(2).toLowerCase();
        return function(scope, element, attr) {
          var fn = $parse(attr[directiveName]);
          var listener = function(ev) {
            scope.$apply(function() {
              fn(scope, {$event: ev});
            });
          };
          var gesture = $ionicGesture.on(eventType, listener, element);
          scope.$on('$destroy', function() {
            $ionicGesture.off(gesture, eventType, listener);
          });
        };
      }];
    }
    IonicModule.directive('ionHeaderBar', headerFooterBarDirective(true)).directive('ionFooterBar', headerFooterBarDirective(false));
    function tapScrollToTopDirective() {
      return ['$ionicScrollDelegate', function($ionicScrollDelegate) {
        return {
          restrict: 'E',
          link: function($scope, $element, $attr) {
            if ($attr.noTapScroll == 'true') {
              return;
            }
            ionic.on('tap', onTap, $element[0]);
            $scope.$on('$destroy', function() {
              ionic.off('tap', onTap, $element[0]);
            });
            function onTap(e) {
              var depth = 3;
              var current = e.target;
              while (depth-- && current) {
                if (current.classList.contains('button') || current.tagName.match(/input|textarea|select/i) || current.isContentEditable) {
                  return;
                }
                current = current.parentNode;
              }
              var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];
              var bounds = $element[0].getBoundingClientRect();
              if (ionic.DomUtil.rectContains(touch.pageX, touch.pageY, bounds.left, bounds.top - 20, bounds.left + bounds.width, bounds.top + bounds.height)) {
                $ionicScrollDelegate.scrollTop(true);
              }
            }
          }
        };
      }];
    }
    function headerFooterBarDirective(isHeader) {
      return ['$document', '$timeout', function($document, $timeout) {
        return {
          restrict: 'E',
          controller: '$ionicHeaderBar',
          compile: function(tElement) {
            tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');
            $timeout(function() {
              if (isHeader && $document[0].getElementsByClassName('tabs-top').length)
                tElement.addClass('has-tabs-top');
            });
            return {pre: prelink};
            function prelink($scope, $element, $attr, ctrl) {
              if (isHeader) {
                $scope.$watch(function() {
                  return $element[0].className;
                }, function(value) {
                  var isShown = value.indexOf('ng-hide') === -1;
                  var isSubheader = value.indexOf('bar-subheader') !== -1;
                  $scope.$hasHeader = isShown && !isSubheader;
                  $scope.$hasSubheader = isShown && isSubheader;
                  $scope.$emit('$ionicSubheader', $scope.$hasSubheader);
                });
                $scope.$on('$destroy', function() {
                  delete $scope.$hasHeader;
                  delete $scope.$hasSubheader;
                });
                ctrl.align();
                $scope.$on('$ionicHeader.align', function() {
                  ionic.requestAnimationFrame(function() {
                    ctrl.align();
                  });
                });
              } else {
                $scope.$watch(function() {
                  return $element[0].className;
                }, function(value) {
                  var isShown = value.indexOf('ng-hide') === -1;
                  var isSubfooter = value.indexOf('bar-subfooter') !== -1;
                  $scope.$hasFooter = isShown && !isSubfooter;
                  $scope.$hasSubfooter = isShown && isSubfooter;
                });
                $scope.$on('$destroy', function() {
                  delete $scope.$hasFooter;
                  delete $scope.$hasSubfooter;
                });
                $scope.$watch('$hasTabs', function(val) {
                  $element.toggleClass('has-tabs', !!val);
                });
                ctrl.align();
                $scope.$on('$ionicFooter.align', function() {
                  ionic.requestAnimationFrame(function() {
                    ctrl.align();
                  });
                });
              }
            }
          }
        };
      }];
    }
    IonicModule.directive('ionInfiniteScroll', ['$timeout', function($timeout) {
      return {
        restrict: 'E',
        require: ['?^$ionicScroll', 'ionInfiniteScroll'],
        template: function($element, $attrs) {
          if ($attrs.icon)
            return '<i class="icon {{icon()}} icon-refreshing {{scrollingType}}"></i>';
          return '<ion-spinner icon="{{spinner()}}"></ion-spinner>';
        },
        scope: true,
        controller: '$ionInfiniteScroll',
        link: function($scope, $element, $attrs, ctrls) {
          var infiniteScrollCtrl = ctrls[1];
          var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];
          var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();
          if (jsScrolling) {
            infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;
            $scope.scrollingType = 'js-scrolling';
            scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);
          } else {
            var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');
            infiniteScrollCtrl.scrollEl = scrollEl;
            if (!scrollEl) {
              throw 'Infinite scroll must be used inside a scrollable div';
            }
            infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);
          }
          var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;
          if (doImmediateCheck) {
            $timeout(function() {
              infiniteScrollCtrl.checkBounds();
            });
          }
        }
      };
    }]);
    var labelIds = -1;
    IonicModule.directive('ionInput', [function() {
      return {
        restrict: 'E',
        controller: ['$scope', '$element', function($scope, $element) {
          this.$scope = $scope;
          this.$element = $element;
          this.setInputAriaLabeledBy = function(id) {
            var inputs = $element[0].querySelectorAll('input,textarea');
            inputs.length && inputs[0].setAttribute('aria-labelledby', id);
          };
          this.focus = function() {
            var inputs = $element[0].querySelectorAll('input,textarea');
            inputs.length && inputs[0].focus();
          };
        }]
      };
    }]);
    IonicModule.directive('ionLabel', [function() {
      return {
        restrict: 'E',
        require: '?^ionInput',
        compile: function() {
          return function link($scope, $element, $attrs, ionInputCtrl) {
            var element = $element[0];
            $element.addClass('input-label');
            $element.attr('aria-label', $element.text());
            var id = element.id || '_label-' + ++labelIds;
            if (!element.id) {
              $element.attr('id', id);
            }
            if (ionInputCtrl) {
              ionInputCtrl.setInputAriaLabeledBy(id);
              $element.on('click', function() {
                ionInputCtrl.focus();
              });
            }
          };
        }
      };
    }]);
    IonicModule.directive('inputLabel', [function() {
      return {
        restrict: 'C',
        require: '?^ionInput',
        compile: function() {
          return function link($scope, $element, $attrs, ionInputCtrl) {
            var element = $element[0];
            $element.attr('aria-label', $element.text());
            var id = element.id || '_label-' + ++labelIds;
            if (!element.id) {
              $element.attr('id', id);
            }
            if (ionInputCtrl) {
              ionInputCtrl.setInputAriaLabeledBy(id);
            }
          };
        }
      };
    }]);
    IonicModule.directive('ionItem', ['$$rAF', function($$rAF) {
      return {
        restrict: 'E',
        controller: ['$scope', '$element', function($scope, $element) {
          this.$scope = $scope;
          this.$element = $element;
        }],
        scope: true,
        compile: function($element, $attrs) {
          var isAnchor = isDefined($attrs.href) || isDefined($attrs.ngHref) || isDefined($attrs.uiSref);
          var isComplexItem = isAnchor || /ion-(delete|option|reorder)-button/i.test($element.html());
          if (isComplexItem) {
            var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');
            innerElement.addClass('item-content');
            if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {
              innerElement.attr('ng-href', '{{$href()}}');
              if (isDefined($attrs.target)) {
                innerElement.attr('target', '{{$target()}}');
              }
            }
            innerElement.append($element.contents());
            $element.addClass('item item-complex').append(innerElement);
          } else {
            $element.addClass('item');
          }
          return function link($scope, $element, $attrs) {
            $scope.$href = function() {
              return $attrs.href || $attrs.ngHref;
            };
            $scope.$target = function() {
              return $attrs.target;
            };
            var content = $element[0].querySelector('.item-content');
            if (content) {
              $scope.$on('$collectionRepeatLeave', function() {
                if (content && content.$$ionicOptionsOpen) {
                  content.style[ionic.CSS.TRANSFORM] = '';
                  content.style[ionic.CSS.TRANSITION] = 'none';
                  $$rAF(function() {
                    content.style[ionic.CSS.TRANSITION] = '';
                  });
                  content.$$ionicOptionsOpen = false;
                }
              });
            }
          };
        }
      };
    }]);
    var ITEM_TPL_DELETE_BUTTON = '<div class="item-left-edit item-delete enable-pointer-events">' + '</div>';
    IonicModule.directive('ionDeleteButton', function() {
      function stopPropagation(ev) {
        ev.stopPropagation();
      }
      return {
        restrict: 'E',
        require: ['^^ionItem', '^?ionList'],
        priority: Number.MAX_VALUE,
        compile: function($element, $attr) {
          $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
          return function($scope, $element, $attr, ctrls) {
            var itemCtrl = ctrls[0];
            var listCtrl = ctrls[1];
            var container = jqLite(ITEM_TPL_DELETE_BUTTON);
            container.append($element);
            itemCtrl.$element.append(container).addClass('item-left-editable');
            $element.on('click', stopPropagation);
            init();
            $scope.$on('$ionic.reconnectScope', init);
            function init() {
              listCtrl = listCtrl || $element.controller('ionList');
              if (listCtrl && listCtrl.showDelete()) {
                container.addClass('visible active');
              }
            }
          };
        }
      };
    });
    IonicModule.directive('itemFloatingLabel', function() {
      return {
        restrict: 'C',
        link: function(scope, element) {
          var el = element[0];
          var input = el.querySelector('input, textarea');
          var inputLabel = el.querySelector('.input-label');
          if (!input || !inputLabel)
            return;
          var onInput = function() {
            if (input.value) {
              inputLabel.classList.add('has-input');
            } else {
              inputLabel.classList.remove('has-input');
            }
          };
          input.addEventListener('input', onInput);
          var ngModelCtrl = jqLite(input).controller('ngModel');
          if (ngModelCtrl) {
            ngModelCtrl.$render = function() {
              input.value = ngModelCtrl.$viewValue || '';
              onInput();
            };
          }
          scope.$on('$destroy', function() {
            input.removeEventListener('input', onInput);
          });
        }
      };
    });
    var ITEM_TPL_OPTION_BUTTONS = '<div class="item-options invisible">' + '</div>';
    IonicModule.directive('ionOptionButton', [function() {
      function stopPropagation(e) {
        e.stopPropagation();
      }
      return {
        restrict: 'E',
        require: '^ionItem',
        priority: Number.MAX_VALUE,
        compile: function($element, $attr) {
          $attr.$set('class', ($attr['class'] || '') + ' button', true);
          return function($scope, $element, $attr, itemCtrl) {
            if (!itemCtrl.optionsContainer) {
              itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);
              itemCtrl.$element.append(itemCtrl.optionsContainer);
            }
            itemCtrl.optionsContainer.append($element);
            itemCtrl.$element.addClass('item-right-editable');
            $element.on('click', stopPropagation);
          };
        }
      };
    }]);
    var ITEM_TPL_REORDER_BUTTON = '<div data-prevent-scroll="true" class="item-right-edit item-reorder enable-pointer-events">' + '</div>';
    IonicModule.directive('ionReorderButton', ['$parse', function($parse) {
      return {
        restrict: 'E',
        require: ['^ionItem', '^?ionList'],
        priority: Number.MAX_VALUE,
        compile: function($element, $attr) {
          $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);
          $element[0].setAttribute('data-prevent-scroll', true);
          return function($scope, $element, $attr, ctrls) {
            var itemCtrl = ctrls[0];
            var listCtrl = ctrls[1];
            var onReorderFn = $parse($attr.onReorder);
            $scope.$onReorder = function(oldIndex, newIndex) {
              onReorderFn($scope, {
                $fromIndex: oldIndex,
                $toIndex: newIndex
              });
            };
            if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {
              $element[0].onclick = function(e) {
                e.stopPropagation();
                return false;
              };
            }
            var container = jqLite(ITEM_TPL_REORDER_BUTTON);
            container.append($element);
            itemCtrl.$element.append(container).addClass('item-right-editable');
            if (listCtrl && listCtrl.showReorder()) {
              container.addClass('visible active');
            }
          };
        }
      };
    }]);
    IonicModule.directive('keyboardAttach', function() {
      return function(scope, element) {
        ionic.on('native.keyboardshow', onShow, window);
        ionic.on('native.keyboardhide', onHide, window);
        ionic.on('native.showkeyboard', onShow, window);
        ionic.on('native.hidekeyboard', onHide, window);
        var scrollCtrl;
        function onShow(e) {
          if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
            return;
          }
          var keyboardHeight = e.keyboardHeight || (e.detail && e.detail.keyboardHeight);
          element.css('bottom', keyboardHeight + "px");
          scrollCtrl = element.controller('$ionicScroll');
          if (scrollCtrl) {
            scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + "px";
          }
        }
        function onHide() {
          if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {
            return;
          }
          element.css('bottom', '');
          if (scrollCtrl) {
            scrollCtrl.scrollView.__container.style.bottom = '';
          }
        }
        scope.$on('$destroy', function() {
          ionic.off('native.keyboardshow', onShow, window);
          ionic.off('native.keyboardhide', onHide, window);
          ionic.off('native.showkeyboard', onShow, window);
          ionic.off('native.hidekeyboard', onHide, window);
        });
      };
    });
    function keyboardAttachGetClientHeight(element) {
      return element.clientHeight;
    }
    IonicModule.directive('ionList', ['$timeout', function($timeout) {
      return {
        restrict: 'E',
        require: ['ionList', '^?$ionicScroll'],
        controller: '$ionicList',
        compile: function($element, $attr) {
          var listEl = jqLite('<div class="list">').append($element.contents()).addClass($attr.type);
          $element.append(listEl);
          return function($scope, $element, $attrs, ctrls) {
            var listCtrl = ctrls[0];
            var scrollCtrl = ctrls[1];
            $timeout(init);
            function init() {
              var listView = listCtrl.listView = new ionic.views.ListView({
                el: $element[0],
                listEl: $element.children()[0],
                scrollEl: scrollCtrl && scrollCtrl.element,
                scrollView: scrollCtrl && scrollCtrl.scrollView,
                onReorder: function(el, oldIndex, newIndex) {
                  var itemScope = jqLite(el).scope();
                  if (itemScope && itemScope.$onReorder) {
                    $timeout(function() {
                      itemScope.$onReorder(oldIndex, newIndex);
                    });
                  }
                },
                canSwipe: function() {
                  return listCtrl.canSwipeItems();
                }
              });
              $scope.$on('$destroy', function() {
                if (listView) {
                  listView.deregister && listView.deregister();
                  listView = null;
                }
              });
              if (isDefined($attr.canSwipe)) {
                $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {
                  listCtrl.canSwipeItems(value);
                });
              }
              if (isDefined($attr.showDelete)) {
                $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {
                  listCtrl.showDelete(value);
                });
              }
              if (isDefined($attr.showReorder)) {
                $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {
                  listCtrl.showReorder(value);
                });
              }
              $scope.$watch(function() {
                return listCtrl.showDelete();
              }, function(isShown, wasShown) {
                if (!isShown && !wasShown) {
                  return;
                }
                if (isShown)
                  listCtrl.closeOptionButtons();
                listCtrl.canSwipeItems(!isShown);
                $element.children().toggleClass('list-left-editing', isShown);
                $element.toggleClass('disable-pointer-events', isShown);
                var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));
                setButtonShown(deleteButton, listCtrl.showDelete);
              });
              $scope.$watch(function() {
                return listCtrl.showReorder();
              }, function(isShown, wasShown) {
                if (!isShown && !wasShown) {
                  return;
                }
                if (isShown)
                  listCtrl.closeOptionButtons();
                listCtrl.canSwipeItems(!isShown);
                $element.children().toggleClass('list-right-editing', isShown);
                $element.toggleClass('disable-pointer-events', isShown);
                var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));
                setButtonShown(reorderButton, listCtrl.showReorder);
              });
              function setButtonShown(el, shown) {
                shown() && el.addClass('visible') || el.removeClass('active');
                ionic.requestAnimationFrame(function() {
                  shown() && el.addClass('active') || el.removeClass('visible');
                });
              }
            }
          };
        }
      };
    }]);
    IonicModule.directive('menuClose', ['$ionicHistory', '$timeout', function($ionicHistory, $timeout) {
      return {
        restrict: 'AC',
        link: function($scope, $element) {
          $element.bind('click', function() {
            var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
            if (sideMenuCtrl) {
              $ionicHistory.nextViewOptions({
                historyRoot: true,
                disableAnimate: true,
                expire: 300
              });
              $timeout(function() {
                $ionicHistory.nextViewOptions({
                  historyRoot: false,
                  disableAnimate: false
                });
              }, 300);
              sideMenuCtrl.close();
            }
          });
        }
      };
    }]);
    IonicModule.directive('menuToggle', function() {
      return {
        restrict: 'AC',
        link: function($scope, $element, $attr) {
          $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {
            if (viewData.enableBack) {
              var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
              if (!sideMenuCtrl.enableMenuWithBackViews()) {
                $element.addClass('hide');
              }
            } else {
              $element.removeClass('hide');
            }
          });
          $element.bind('click', function() {
            var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');
            sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);
          });
        }
      };
    });
    IonicModule.directive('ionModal', [function() {
      return {
        restrict: 'E',
        transclude: true,
        replace: true,
        controller: [function() {}],
        template: '<div class="modal-backdrop">' + '<div class="modal-backdrop-bg"></div>' + '<div class="modal-wrapper" ng-transclude></div>' + '</div>'
      };
    }]);
    IonicModule.directive('ionModalView', function() {
      return {
        restrict: 'E',
        compile: function(element) {
          element.addClass('modal');
        }
      };
    });
    IonicModule.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {
      return {
        restrict: 'E',
        require: '^ionNavBar',
        compile: function(tElement, tAttrs) {
          var buttonEle = $document[0].createElement('button');
          for (var n in tAttrs.$attr) {
            buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
          }
          if (!tAttrs.ngClick) {
            buttonEle.setAttribute('ng-click', '$ionicGoBack()');
          }
          buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');
          buttonEle.innerHTML = tElement.html() || '';
          var childNode;
          var hasIcon = hasIconClass(tElement[0]);
          var hasInnerText;
          var hasButtonText;
          var hasPreviousTitle;
          for (var x = 0; x < tElement[0].childNodes.length; x++) {
            childNode = tElement[0].childNodes[x];
            if (childNode.nodeType === 1) {
              if (hasIconClass(childNode)) {
                hasIcon = true;
              } else if (childNode.classList.contains('default-title')) {
                hasButtonText = true;
              } else if (childNode.classList.contains('previous-title')) {
                hasPreviousTitle = true;
              }
            } else if (!hasInnerText && childNode.nodeType === 3) {
              hasInnerText = !!childNode.nodeValue.trim();
            }
          }
          function hasIconClass(ele) {
            return /ion-|icon/.test(ele.className);
          }
          var defaultIcon = $ionicConfig.backButton.icon();
          if (!hasIcon && defaultIcon && defaultIcon !== 'none') {
            buttonEle.innerHTML = '<i class="icon ' + defaultIcon + '"></i> ' + buttonEle.innerHTML;
            buttonEle.className += ' button-clear';
          }
          if (!hasInnerText) {
            var buttonTextEle = $document[0].createElement('span');
            buttonTextEle.className = 'back-text';
            if (!hasButtonText && $ionicConfig.backButton.text()) {
              buttonTextEle.innerHTML += '<span class="default-title">' + $ionicConfig.backButton.text() + '</span>';
            }
            if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {
              buttonTextEle.innerHTML += '<span class="previous-title"></span>';
            }
            buttonEle.appendChild(buttonTextEle);
          }
          tElement.attr('class', 'hide');
          tElement.empty();
          return {pre: function($scope, $element, $attr, navBarCtrl) {
              navBarCtrl.navElement('backButton', buttonEle.outerHTML);
              buttonEle = null;
            }};
        }
      };
    }]);
    IonicModule.directive('ionNavBar', function() {
      return {
        restrict: 'E',
        controller: '$ionicNavBar',
        scope: true,
        link: function($scope, $element, $attr, ctrl) {
          ctrl.init();
        }
      };
    });
    IonicModule.directive('ionNavButtons', ['$document', function($document) {
      return {
        require: '^ionNavBar',
        restrict: 'E',
        compile: function(tElement, tAttrs) {
          var side = 'left';
          if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {
            side = tAttrs.side.toLowerCase();
          }
          var spanEle = $document[0].createElement('span');
          spanEle.className = side + '-buttons';
          spanEle.innerHTML = tElement.html();
          var navElementType = side + 'Buttons';
          tElement.attr('class', 'hide');
          tElement.empty();
          return {pre: function($scope, $element, $attrs, navBarCtrl) {
              var parentViewCtrl = $element.parent().data('$ionViewController');
              if (parentViewCtrl) {
                parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
              } else {
                navBarCtrl.navElement(navElementType, spanEle.outerHTML);
              }
              spanEle = null;
            }};
        }
      };
    }]);
    IonicModule.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
      return {
        restrict: 'A',
        priority: 1000,
        link: function($scope, $element, $attr) {
          $element.bind('click', function() {
            $ionicViewSwitcher.nextDirection($attr.navDirection);
          });
        }
      };
    }]);
    IonicModule.directive('ionNavTitle', ['$document', function($document) {
      return {
        require: '^ionNavBar',
        restrict: 'E',
        compile: function(tElement, tAttrs) {
          var navElementType = 'title';
          var spanEle = $document[0].createElement('span');
          for (var n in tAttrs.$attr) {
            spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);
          }
          spanEle.classList.add('nav-bar-title');
          spanEle.innerHTML = tElement.html();
          tElement.attr('class', 'hide');
          tElement.empty();
          return {pre: function($scope, $element, $attrs, navBarCtrl) {
              var parentViewCtrl = $element.parent().data('$ionViewController');
              if (parentViewCtrl) {
                parentViewCtrl.navElement(navElementType, spanEle.outerHTML);
              } else {
                navBarCtrl.navElement(navElementType, spanEle.outerHTML);
              }
              spanEle = null;
            }};
        }
      };
    }]);
    IonicModule.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {
      return {
        restrict: 'A',
        priority: 1000,
        link: function($scope, $element, $attr) {
          $element.bind('click', function() {
            $ionicViewSwitcher.nextTransition($attr.navTransition);
          });
        }
      };
    }]);
    IonicModule.directive('ionNavView', ['$state', '$ionicConfig', function($state, $ionicConfig) {
      return {
        restrict: 'E',
        terminal: true,
        priority: 2000,
        transclude: true,
        controller: '$ionicNavView',
        compile: function(tElement, tAttrs, transclude) {
          tElement.addClass('view-container');
          ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());
          return function($scope, $element, $attr, navViewCtrl) {
            var latestLocals;
            transclude($scope, function(clone) {
              $element.append(clone);
            });
            var viewData = navViewCtrl.init();
            $scope.$on('$stateChangeSuccess', function() {
              updateView(false);
            });
            $scope.$on('$viewContentLoading', function() {
              updateView(false);
            });
            updateView(true);
            function updateView(firstTime) {
              var viewLocals = $state.$current && $state.$current.locals[viewData.name];
              if (!viewLocals || (!firstTime && viewLocals === latestLocals))
                return;
              latestLocals = viewLocals;
              viewData.state = viewLocals.$$state;
              navViewCtrl.register(viewLocals);
            }
          };
        }
      };
    }]);
    IonicModule.config(['$provide', function($provide) {
      $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {
        $delegate.shift();
        return $delegate;
      }]);
    }]).factory('$ionicNgClick', ['$parse', function($parse) {
      return function(scope, element, clickExpr) {
        var clickHandler = angular.isFunction(clickExpr) ? clickExpr : $parse(clickExpr);
        element.on('click', function(event) {
          scope.$apply(function() {
            clickHandler(scope, {$event: (event)});
          });
        });
        element.onclick = noop;
      };
    }]).directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {
      return function(scope, element, attr) {
        $ionicNgClick(scope, element, attr.ngClick);
      };
    }]).directive('ionStopEvent', function() {
      return {
        restrict: 'A',
        link: function(scope, element, attr) {
          element.bind(attr.ionStopEvent, eventStopPropagation);
        }
      };
    });
    function eventStopPropagation(e) {
      e.stopPropagation();
    }
    IonicModule.directive('ionPane', function() {
      return {
        restrict: 'E',
        link: function(scope, element) {
          element.addClass('pane');
        }
      };
    });
    IonicModule.directive('ionPopover', [function() {
      return {
        restrict: 'E',
        transclude: true,
        replace: true,
        controller: [function() {}],
        template: '<div class="popover-backdrop">' + '<div class="popover-wrapper" ng-transclude></div>' + '</div>'
      };
    }]);
    IonicModule.directive('ionPopoverView', function() {
      return {
        restrict: 'E',
        compile: function(element) {
          element.append(jqLite('<div class="popover-arrow">'));
          element.addClass('popover');
        }
      };
    });
    IonicModule.directive('ionRadio', function() {
      return {
        restrict: 'E',
        replace: true,
        require: '?ngModel',
        transclude: true,
        template: '<label class="item item-radio">' + '<input type="radio" name="radio-group">' + '<div class="radio-content">' + '<div class="item-content disable-pointer-events" ng-transclude></div>' + '<i class="radio-icon disable-pointer-events icon ion-checkmark"></i>' + '</div>' + '</label>',
        compile: function(element, attr) {
          if (attr.icon) {
            var iconElm = element.find('i');
            iconElm.removeClass('ion-checkmark').addClass(attr.icon);
          }
          var input = element.find('input');
          forEach({
            'name': attr.name,
            'value': attr.value,
            'disabled': attr.disabled,
            'ng-value': attr.ngValue,
            'ng-model': attr.ngModel,
            'ng-disabled': attr.ngDisabled,
            'ng-change': attr.ngChange,
            'ng-required': attr.ngRequired,
            'required': attr.required
          }, function(value, name) {
            if (isDefined(value)) {
              input.attr(name, value);
            }
          });
          return function(scope, element, attr) {
            scope.getValue = function() {
              return scope.ngValue || attr.value;
            };
          };
        }
      };
    });
    IonicModule.directive('ionRefresher', [function() {
      return {
        restrict: 'E',
        replace: true,
        require: ['?^$ionicScroll', 'ionRefresher'],
        controller: '$ionicRefresher',
        template: '<div class="scroll-refresher invisible" collection-repeat-ignore>' + '<div class="ionic-refresher-content" ' + 'ng-class="{\'ionic-refresher-with-text\': pullingText || refreshingText}">' + '<div class="icon-pulling" ng-class="{\'pulling-rotation-disabled\':disablePullingRotation}">' + '<i class="icon {{pullingIcon}}"></i>' + '</div>' + '<div class="text-pulling" ng-bind-html="pullingText"></div>' + '<div class="icon-refreshing">' + '<ion-spinner ng-if="showSpinner" icon="{{spinner}}"></ion-spinner>' + '<i ng-if="showIcon" class="icon {{refreshingIcon}}"></i>' + '</div>' + '<div class="text-refreshing" ng-bind-html="refreshingText"></div>' + '</div>' + '</div>',
        link: function($scope, $element, $attrs, ctrls) {
          var scrollCtrl = ctrls[0],
              refresherCtrl = ctrls[1];
          if (!scrollCtrl || scrollCtrl.isNative()) {
            refresherCtrl.init();
          } else {
            $element[0].classList.add('js-scrolling');
            scrollCtrl._setRefresher($scope, $element[0], refresherCtrl.getRefresherDomMethods());
            $scope.$on('scroll.refreshComplete', function() {
              $scope.$evalAsync(function() {
                scrollCtrl.scrollView.finishPullToRefresh();
              });
            });
          }
        }
      };
    }]);
    IonicModule.directive('ionScroll', ['$timeout', '$controller', '$ionicBind', '$ionicConfig', function($timeout, $controller, $ionicBind, $ionicConfig) {
      return {
        restrict: 'E',
        scope: true,
        controller: function() {},
        compile: function(element, attr) {
          element.addClass('scroll-view ionic-scroll');
          var innerElement = jqLite('<div class="scroll"></div>');
          innerElement.append(element.contents());
          element.append(innerElement);
          var nativeScrolling = attr.overflowScroll !== "false" && (attr.overflowScroll === "true" || !$ionicConfig.scrolling.jsScrolling());
          return {pre: prelink};
          function prelink($scope, $element, $attr) {
            $ionicBind($scope, $attr, {
              direction: '@',
              paging: '@',
              $onScroll: '&onScroll',
              scroll: '@',
              scrollbarX: '@',
              scrollbarY: '@',
              zooming: '@',
              minZoom: '@',
              maxZoom: '@'
            });
            $scope.direction = $scope.direction || 'y';
            if (isDefined($attr.padding)) {
              $scope.$watch($attr.padding, function(newVal) {
                innerElement.toggleClass('padding', !!newVal);
              });
            }
            if ($scope.$eval($scope.paging) === true) {
              innerElement.addClass('scroll-paging');
            }
            if (!$scope.direction) {
              $scope.direction = 'y';
            }
            var isPaging = $scope.$eval($scope.paging) === true;
            if (nativeScrolling) {
              $element.addClass('overflow-scroll');
            }
            $element.addClass('scroll-' + $scope.direction);
            var scrollViewOptions = {
              el: $element[0],
              delegateHandle: $attr.delegateHandle,
              locking: ($attr.locking || 'true') === 'true',
              bouncing: $scope.$eval($attr.hasBouncing),
              paging: isPaging,
              scrollbarX: $scope.$eval($scope.scrollbarX) !== false,
              scrollbarY: $scope.$eval($scope.scrollbarY) !== false,
              scrollingX: $scope.direction.indexOf('x') >= 0,
              scrollingY: $scope.direction.indexOf('y') >= 0,
              zooming: $scope.$eval($scope.zooming) === true,
              maxZoom: $scope.$eval($scope.maxZoom) || 3,
              minZoom: $scope.$eval($scope.minZoom) || 0.5,
              preventDefault: true,
              nativeScrolling: nativeScrolling
            };
            if (isPaging) {
              scrollViewOptions.speedMultiplier = 0.8;
              scrollViewOptions.bouncing = false;
            }
            $controller('$ionicScroll', {
              $scope: $scope,
              scrollViewOptions: scrollViewOptions
            });
          }
        }
      };
    }]);
    IonicModule.directive('ionSideMenu', function() {
      return {
        restrict: 'E',
        require: '^ionSideMenus',
        scope: true,
        compile: function(element, attr) {
          angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');
          angular.isUndefined(attr.width) && attr.$set('width', '275');
          element.addClass('menu menu-' + attr.side);
          return function($scope, $element, $attr, sideMenuCtrl) {
            $scope.side = $attr.side || 'left';
            var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({
              width: attr.width,
              el: $element[0],
              isEnabled: true
            });
            $scope.$watch($attr.width, function(val) {
              var numberVal = +val;
              if (numberVal && numberVal == val) {
                sideMenu.setWidth(+val);
              }
            });
            $scope.$watch($attr.isEnabled, function(val) {
              sideMenu.setIsEnabled(!!val);
            });
          };
        }
      };
    });
    IonicModule.directive('ionSideMenuContent', ['$timeout', '$ionicGesture', '$window', function($timeout, $ionicGesture, $window) {
      return {
        restrict: 'EA',
        require: '^ionSideMenus',
        scope: true,
        compile: function(element, attr) {
          element.addClass('menu-content pane');
          return {pre: prelink};
          function prelink($scope, $element, $attr, sideMenuCtrl) {
            var startCoord = null;
            var primaryScrollAxis = null;
            if (isDefined(attr.dragContent)) {
              $scope.$watch(attr.dragContent, function(value) {
                sideMenuCtrl.canDragContent(value);
              });
            } else {
              sideMenuCtrl.canDragContent(true);
            }
            if (isDefined(attr.edgeDragThreshold)) {
              $scope.$watch(attr.edgeDragThreshold, function(value) {
                sideMenuCtrl.edgeDragThreshold(value);
              });
            }
            function onContentTap(gestureEvt) {
              if (sideMenuCtrl.getOpenAmount() !== 0) {
                sideMenuCtrl.close();
                gestureEvt.gesture.srcEvent.preventDefault();
                startCoord = null;
                primaryScrollAxis = null;
              } else if (!startCoord) {
                startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
              }
            }
            function onDragX(e) {
              if (!sideMenuCtrl.isDraggableTarget(e))
                return;
              if (getPrimaryScrollAxis(e) == 'x') {
                sideMenuCtrl._handleDrag(e);
                e.gesture.srcEvent.preventDefault();
              }
            }
            function onDragY(e) {
              if (getPrimaryScrollAxis(e) == 'x') {
                e.gesture.srcEvent.preventDefault();
              }
            }
            function onDragRelease(e) {
              sideMenuCtrl._endDrag(e);
              startCoord = null;
              primaryScrollAxis = null;
            }
            function getPrimaryScrollAxis(gestureEvt) {
              if (primaryScrollAxis) {
                return primaryScrollAxis;
              }
              if (gestureEvt && gestureEvt.gesture) {
                if (!startCoord) {
                  startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                } else {
                  var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);
                  var xDistance = Math.abs(endCoord.x - startCoord.x);
                  var yDistance = Math.abs(endCoord.y - startCoord.y);
                  var scrollAxis = (xDistance < yDistance ? 'y' : 'x');
                  if (Math.max(xDistance, yDistance) > 30) {
                    primaryScrollAxis = scrollAxis;
                  }
                  return scrollAxis;
                }
              }
              return 'y';
            }
            var content = {
              element: element[0],
              onDrag: function() {},
              endDrag: function() {},
              setCanScroll: function(canScroll) {
                var c = $element[0].querySelector('.scroll');
                if (!c) {
                  return;
                }
                var content = angular.element(c.parentElement);
                if (!content) {
                  return;
                }
                var scrollScope = content.scope();
                scrollScope.scrollCtrl && scrollScope.scrollCtrl.freezeScrollShut(!canScroll);
              },
              getTranslateX: function() {
                return $scope.sideMenuContentTranslateX || 0;
              },
              setTranslateX: ionic.animationFrameThrottle(function(amount) {
                var xTransform = content.offsetX + amount;
                $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';
                $timeout(function() {
                  $scope.sideMenuContentTranslateX = amount;
                });
              }),
              setMarginLeft: ionic.animationFrameThrottle(function(amount) {
                if (amount) {
                  amount = parseInt(amount, 10);
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';
                  $element[0].style.width = ($window.innerWidth - amount) + 'px';
                  content.offsetX = amount;
                } else {
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                  $element[0].style.width = '';
                  content.offsetX = 0;
                }
              }),
              setMarginRight: ionic.animationFrameThrottle(function(amount) {
                if (amount) {
                  amount = parseInt(amount, 10);
                  $element[0].style.width = ($window.innerWidth - amount) + 'px';
                  content.offsetX = amount;
                } else {
                  $element[0].style.width = '';
                  content.offsetX = 0;
                }
                $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
              }),
              setMarginLeftAndRight: ionic.animationFrameThrottle(function(amountLeft, amountRight) {
                amountLeft = amountLeft && parseInt(amountLeft, 10) || 0;
                amountRight = amountRight && parseInt(amountRight, 10) || 0;
                var amount = amountLeft + amountRight;
                if (amount > 0) {
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amountLeft + 'px,0,0)';
                  $element[0].style.width = ($window.innerWidth - amount) + 'px';
                  content.offsetX = amountLeft;
                } else {
                  $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';
                  $element[0].style.width = '';
                  content.offsetX = 0;
                }
              }),
              enableAnimation: function() {
                $scope.animationEnabled = true;
                $element[0].classList.add('menu-animated');
              },
              disableAnimation: function() {
                $scope.animationEnabled = false;
                $element[0].classList.remove('menu-animated');
              },
              offsetX: 0
            };
            sideMenuCtrl.setContent(content);
            var gestureOpts = {stop_browser_behavior: false};
            gestureOpts.prevent_default_directions = ['left', 'right'];
            var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);
            var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);
            var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);
            var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);
            var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);
            var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);
            $scope.$on('$destroy', function() {
              if (content) {
                content.element = null;
                content = null;
              }
              $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);
              $ionicGesture.off(dragRightGesture, 'dragright', onDragX);
              $ionicGesture.off(dragUpGesture, 'dragup', onDragY);
              $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);
              $ionicGesture.off(releaseGesture, 'release', onDragRelease);
              $ionicGesture.off(contentTapGesture, 'tap', onContentTap);
            });
          }
        }
      };
    }]);
    IonicModule.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {
      return {
        restrict: 'ECA',
        controller: '$ionicSideMenus',
        compile: function(element, attr) {
          attr.$set('class', (attr['class'] || '') + ' view');
          return {pre: prelink};
          function prelink($scope, $element, $attrs, ctrl) {
            ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));
            $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {
              if (!$scope.$exposeAside)
                $scope.$exposeAside = {};
              $scope.$exposeAside.active = isAsideExposed;
              $ionicBody.enableClass(isAsideExposed, 'aside-open');
            });
            $scope.$on('$ionicView.beforeEnter', function(ev, d) {
              if (d.historyId) {
                $scope.$activeHistoryId = d.historyId;
              }
            });
            $scope.$on('$destroy', function() {
              $ionicBody.removeClass('menu-open', 'aside-open');
            });
          }
        }
      };
    }]);
    IonicModule.directive('ionSlideBox', ['$animate', '$timeout', '$compile', '$ionicSlideBoxDelegate', '$ionicHistory', '$ionicScrollDelegate', function($animate, $timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {
      return {
        restrict: 'E',
        replace: true,
        transclude: true,
        scope: {
          autoPlay: '=',
          doesContinue: '@',
          slideInterval: '@',
          showPager: '@',
          pagerClick: '&',
          disableScroll: '@',
          onSlideChanged: '&',
          activeSlide: '=?',
          bounce: '@'
        },
        controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {
          var _this = this;
          var continuous = $scope.$eval($scope.doesContinue) === true;
          var bouncing = ($scope.$eval($scope.bounce) !== false);
          var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;
          var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;
          var slider = new ionic.views.Slider({
            el: $element[0],
            auto: slideInterval,
            continuous: continuous,
            startSlide: $scope.activeSlide,
            bouncing: bouncing,
            slidesChanged: function() {
              $scope.currentSlide = slider.currentIndex();
              $timeout(function() {});
            },
            callback: function(slideIndex) {
              $scope.currentSlide = slideIndex;
              $scope.onSlideChanged({
                index: $scope.currentSlide,
                $index: $scope.currentSlide
              });
              $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);
              $scope.activeSlide = slideIndex;
              $timeout(function() {});
            },
            onDrag: function() {
              freezeAllScrolls(true);
            },
            onDragEnd: function() {
              freezeAllScrolls(false);
            }
          });
          function freezeAllScrolls(shouldFreeze) {
            if (shouldFreeze && !_this.isScrollFreeze) {
              $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);
            } else if (!shouldFreeze && _this.isScrollFreeze) {
              $ionicScrollDelegate.freezeAllScrolls(false);
            }
            _this.isScrollFreeze = shouldFreeze;
          }
          slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);
          $scope.$watch('activeSlide', function(nv) {
            if (isDefined(nv)) {
              slider.slide(nv);
            }
          });
          $scope.$on('slideBox.nextSlide', function() {
            slider.next();
          });
          $scope.$on('slideBox.prevSlide', function() {
            slider.prev();
          });
          $scope.$on('slideBox.setSlide', function(e, index) {
            slider.slide(index);
          });
          this.__slider = slider;
          var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(slider, $attrs.delegateHandle, function() {
            return $ionicHistory.isActiveScope($scope);
          });
          $scope.$on('$destroy', function() {
            deregisterInstance();
            slider.kill();
          });
          this.slidesCount = function() {
            return slider.slidesCount();
          };
          this.onPagerClick = function(index) {
            $scope.pagerClick({index: index});
          };
          $timeout(function() {
            slider.load();
          });
        }],
        template: '<div class="slider">' + '<div class="slider-slides" ng-transclude>' + '</div>' + '</div>',
        link: function($scope, $element, $attr) {
          $animate.enabled(false, $element);
          if (!isDefined($attr.showPager)) {
            $scope.showPager = true;
            getPager().toggleClass('hide', !true);
          }
          $attr.$observe('showPager', function(show) {
            if (show === undefined)
              return;
            show = $scope.$eval(show);
            getPager().toggleClass('hide', !show);
          });
          var pager;
          function getPager() {
            if (!pager) {
              var childScope = $scope.$new();
              pager = jqLite('<ion-pager></ion-pager>');
              $element.append(pager);
              pager = $compile(pager)(childScope);
            }
            return pager;
          }
        }
      };
    }]).directive('ionSlide', function() {
      return {
        restrict: 'E',
        require: '?^ionSlideBox',
        compile: function(element) {
          element.addClass('slider-slide');
        }
      };
    }).directive('ionPager', function() {
      return {
        restrict: 'E',
        replace: true,
        require: '^ionSlideBox',
        template: '<div class="slider-pager"><span class="slider-pager-page" ng-repeat="slide in numSlides() track by $index" ng-class="{active: $index == currentSlide}" ng-click="pagerClick($index)"><i class="icon ion-record"></i></span></div>',
        link: function($scope, $element, $attr, slideBox) {
          var selectPage = function(index) {
            var children = $element[0].children;
            var length = children.length;
            for (var i = 0; i < length; i++) {
              if (i == index) {
                children[i].classList.add('active');
              } else {
                children[i].classList.remove('active');
              }
            }
          };
          $scope.pagerClick = function(index) {
            slideBox.onPagerClick(index);
          };
          $scope.numSlides = function() {
            return new Array(slideBox.slidesCount());
          };
          $scope.$watch('currentSlide', function(v) {
            selectPage(v);
          });
        }
      };
    });
    IonicModule.directive('ionSlides', ['$animate', '$timeout', '$compile', function($animate, $timeout, $compile) {
      return {
        restrict: 'E',
        transclude: true,
        scope: {
          options: '=',
          slider: '='
        },
        template: '<div class="swiper-container">' + '<div class="swiper-wrapper" ng-transclude>' + '</div>' + '<div ng-hide="!showPager" class="swiper-pagination"></div>' + '</div>',
        controller: ['$scope', '$element', function($scope, $element) {
          var _this = this;
          this.update = function() {
            $timeout(function() {
              if (!_this.__slider) {
                return;
              }
              _this.__slider.update();
              if (_this._options.loop) {
                _this.__slider.createLoop();
              }
              if (_this.__slider.slides.length > 10) {
                $scope.showPager = false;
              }
            });
          };
          this.rapidUpdate = ionic.debounce(function() {
            _this.update();
          }, 50);
          this.getSlider = function() {
            return _this.__slider;
          };
          var options = $scope.options || {};
          var newOptions = angular.extend({
            pagination: '.swiper-pagination',
            paginationClickable: true,
            lazyLoading: true,
            preloadImages: false
          }, options);
          this._options = newOptions;
          $timeout(function() {
            var slider = new ionic.views.Swiper($element.children()[0], newOptions, $scope, $compile);
            _this.__slider = slider;
            $scope.slider = _this.__slider;
            $scope.$on('$destroy', function() {
              slider.destroy();
            });
          });
        }],
        link: function($scope) {
          $scope.showPager = true;
        }
      };
    }]).directive('ionSlidePage', [function() {
      return {
        restrict: 'E',
        require: '?^ionSlides',
        transclude: true,
        replace: true,
        template: '<div class="swiper-slide" ng-transclude></div>',
        link: function($scope, $element, $attr, ionSlidesCtrl) {
          ionSlidesCtrl.rapidUpdate();
        }
      };
    }]);
    IonicModule.directive('ionSpinner', function() {
      return {
        restrict: 'E',
        controller: '$ionicSpinner',
        link: function($scope, $element, $attrs, ctrl) {
          var spinnerName = ctrl.init();
          $element.addClass('spinner spinner-' + spinnerName);
          $element.on('$destroy', function onDestroy() {
            ctrl.stop();
          });
        }
      };
    });
    IonicModule.directive('ionTab', ['$compile', '$ionicConfig', '$ionicBind', '$ionicViewSwitcher', function($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {
      function attrStr(k, v) {
        return isDefined(v) ? ' ' + k + '="' + v + '"' : '';
      }
      return {
        restrict: 'E',
        require: ['^ionTabs', 'ionTab'],
        controller: '$ionicTab',
        scope: true,
        compile: function(element, attr) {
          var tabNavTemplate = '<ion-tab-nav' + attrStr('ng-click', attr.ngClick) + attrStr('title', attr.title) + attrStr('icon', attr.icon) + attrStr('icon-on', attr.iconOn) + attrStr('icon-off', attr.iconOff) + attrStr('badge', attr.badge) + attrStr('badge-style', attr.badgeStyle) + attrStr('hidden', attr.hidden) + attrStr('disabled', attr.disabled) + attrStr('class', attr['class']) + '></ion-tab-nav>';
          var tabContentEle = document.createElement('div');
          for (var x = 0; x < element[0].children.length; x++) {
            tabContentEle.appendChild(element[0].children[x].cloneNode(true));
          }
          var childElementCount = tabContentEle.childElementCount;
          element.empty();
          var navViewName,
              isNavView;
          if (childElementCount) {
            if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {
              navViewName = tabContentEle.children[0].getAttribute('name');
              tabContentEle.children[0].classList.add('view-container');
              isNavView = true;
            }
            if (childElementCount === 1) {
              tabContentEle = tabContentEle.children[0];
            }
            if (!isNavView)
              tabContentEle.classList.add('pane');
            tabContentEle.classList.add('tab-content');
          }
          return function link($scope, $element, $attr, ctrls) {
            var childScope;
            var childElement;
            var tabsCtrl = ctrls[0];
            var tabCtrl = ctrls[1];
            var isTabContentAttached = false;
            $scope.$tabSelected = false;
            $ionicBind($scope, $attr, {
              onSelect: '&',
              onDeselect: '&',
              title: '@',
              uiSref: '@',
              href: '@'
            });
            tabsCtrl.add($scope);
            $scope.$on('$destroy', function() {
              if (!$scope.$tabsDestroy) {
                tabsCtrl.remove($scope);
              }
              tabNavElement.isolateScope().$destroy();
              tabNavElement.remove();
              tabNavElement = tabContentEle = childElement = null;
            });
            $element[0].removeAttribute('title');
            if (navViewName) {
              tabCtrl.navViewName = $scope.navViewName = navViewName;
            }
            $scope.$on('$stateChangeSuccess', selectIfMatchesState);
            selectIfMatchesState();
            function selectIfMatchesState() {
              if (tabCtrl.tabMatchesState()) {
                tabsCtrl.select($scope, false);
              }
            }
            var tabNavElement = jqLite(tabNavTemplate);
            tabNavElement.data('$ionTabsController', tabsCtrl);
            tabNavElement.data('$ionTabController', tabCtrl);
            tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));
            function tabSelected(isSelected) {
              if (isSelected && childElementCount) {
                if (!isTabContentAttached) {
                  childScope = $scope.$new();
                  childElement = jqLite(tabContentEle);
                  $ionicViewSwitcher.viewEleIsActive(childElement, true);
                  tabsCtrl.$element.append(childElement);
                  $compile(childElement)(childScope);
                  isTabContentAttached = true;
                }
                $ionicViewSwitcher.viewEleIsActive(childElement, true);
              } else if (isTabContentAttached && childElement) {
                if ($ionicConfig.views.maxCache() > 0) {
                  $ionicViewSwitcher.viewEleIsActive(childElement, false);
                } else {
                  destroyTab();
                }
              }
            }
            function destroyTab() {
              childScope && childScope.$destroy();
              isTabContentAttached && childElement && childElement.remove();
              tabContentEle.innerHTML = '';
              isTabContentAttached = childScope = childElement = null;
            }
            $scope.$watch('$tabSelected', tabSelected);
            $scope.$on('$ionicView.afterEnter', function() {
              $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);
            });
            $scope.$on('$ionicView.clearCache', function() {
              if (!$scope.$tabSelected) {
                destroyTab();
              }
            });
          };
        }
      };
    }]);
    IonicModule.directive('ionTabNav', [function() {
      return {
        restrict: 'E',
        replace: true,
        require: ['^ionTabs', '^ionTab'],
        template: '<a ng-class="{\'tab-item-active\': isTabActive(), \'has-badge\':badge, \'tab-hidden\':isHidden()}" ' + ' ng-disabled="disabled()" class="tab-item">' + '<span class="badge {{badgeStyle}}" ng-if="badge">{{badge}}</span>' + '<i class="icon {{getIconOn()}}" ng-if="getIconOn() && isTabActive()"></i>' + '<i class="icon {{getIconOff()}}" ng-if="getIconOff() && !isTabActive()"></i>' + '<span class="tab-title" ng-bind-html="title"></span>' + '</a>',
        scope: {
          title: '@',
          icon: '@',
          iconOn: '@',
          iconOff: '@',
          badge: '=',
          hidden: '@',
          disabled: '&',
          badgeStyle: '@',
          'class': '@'
        },
        link: function($scope, $element, $attrs, ctrls) {
          var tabsCtrl = ctrls[0],
              tabCtrl = ctrls[1];
          $element[0].removeAttribute('title');
          $scope.selectTab = function(e) {
            e.preventDefault();
            tabsCtrl.select(tabCtrl.$scope, true);
          };
          if (!$attrs.ngClick) {
            $element.on('click', function(event) {
              $scope.$apply(function() {
                $scope.selectTab(event);
              });
            });
          }
          $scope.isHidden = function() {
            if ($attrs.hidden === 'true' || $attrs.hidden === true)
              return true;
            return false;
          };
          $scope.getIconOn = function() {
            return $scope.iconOn || $scope.icon;
          };
          $scope.getIconOff = function() {
            return $scope.iconOff || $scope.icon;
          };
          $scope.isTabActive = function() {
            return tabsCtrl.selectedTab() === tabCtrl.$scope;
          };
        }
      };
    }]);
    IonicModule.directive('ionTabs', ['$ionicTabsDelegate', '$ionicConfig', function($ionicTabsDelegate, $ionicConfig) {
      return {
        restrict: 'E',
        scope: true,
        controller: '$ionicTabs',
        compile: function(tElement) {
          var innerElement = jqLite('<div class="tab-nav tabs">');
          innerElement.append(tElement.contents());
          tElement.append(innerElement).addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());
          return {
            pre: prelink,
            post: postLink
          };
          function prelink($scope, $element, $attr, tabsCtrl) {
            var deregisterInstance = $ionicTabsDelegate._registerInstance(tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope);
            tabsCtrl.$scope = $scope;
            tabsCtrl.$element = $element;
            tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));
            $scope.$watch(function() {
              return $element[0].className;
            }, function(value) {
              var isTabsTop = value.indexOf('tabs-top') !== -1;
              var isHidden = value.indexOf('tabs-item-hide') !== -1;
              $scope.$hasTabs = !isTabsTop && !isHidden;
              $scope.$hasTabsTop = isTabsTop && !isHidden;
              $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);
            });
            function emitLifecycleEvent(ev, data) {
              ev.stopPropagation();
              var previousSelectedTab = tabsCtrl.previousSelectedTab();
              if (previousSelectedTab) {
                previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);
              }
            }
            $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);
            $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);
            $scope.$on('$ionicNavView.leave', emitLifecycleEvent);
            $scope.$on('$destroy', function() {
              $scope.$tabsDestroy = true;
              deregisterInstance();
              tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;
              delete $scope.$hasTabs;
              delete $scope.$hasTabsTop;
            });
          }
          function postLink($scope, $element, $attr, tabsCtrl) {
            if (!tabsCtrl.selectedTab()) {
              tabsCtrl.select(0);
            }
          }
        }
      };
    }]);
    IonicModule.directive('ionTitle', [function() {
      return {
        restrict: 'E',
        compile: function(element) {
          element.addClass('title');
        }
      };
    }]);
    IonicModule.directive('ionToggle', ['$timeout', '$ionicConfig', function($timeout, $ionicConfig) {
      return {
        restrict: 'E',
        replace: true,
        require: '?ngModel',
        transclude: true,
        template: '<div class="item item-toggle">' + '<div ng-transclude></div>' + '<label class="toggle">' + '<input type="checkbox">' + '<div class="track">' + '<div class="handle"></div>' + '</div>' + '</label>' + '</div>',
        compile: function(element, attr) {
          var input = element.find('input');
          forEach({
            'name': attr.name,
            'ng-value': attr.ngValue,
            'ng-model': attr.ngModel,
            'ng-checked': attr.ngChecked,
            'ng-disabled': attr.ngDisabled,
            'ng-true-value': attr.ngTrueValue,
            'ng-false-value': attr.ngFalseValue,
            'ng-change': attr.ngChange,
            'ng-required': attr.ngRequired,
            'required': attr.required
          }, function(value, name) {
            if (isDefined(value)) {
              input.attr(name, value);
            }
          });
          if (attr.toggleClass) {
            element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);
          }
          element.addClass('toggle-' + $ionicConfig.form.toggle());
          return function($scope, $element) {
            var el = $element[0].getElementsByTagName('label')[0];
            var checkbox = el.children[0];
            var track = el.children[1];
            var handle = track.children[0];
            var ngModelController = jqLite(checkbox).controller('ngModel');
            $scope.toggle = new ionic.views.Toggle({
              el: el,
              track: track,
              checkbox: checkbox,
              handle: handle,
              onChange: function() {
                if (ngModelController) {
                  ngModelController.$setViewValue(checkbox.checked);
                  $scope.$apply();
                }
              }
            });
            $scope.$on('$destroy', function() {
              $scope.toggle.destroy();
            });
          };
        }
      };
    }]);
    IonicModule.directive('ionView', function() {
      return {
        restrict: 'EA',
        priority: 1000,
        controller: '$ionicView',
        compile: function(tElement) {
          tElement.addClass('pane');
          tElement[0].removeAttribute('title');
          return function link($scope, $element, $attrs, viewCtrl) {
            viewCtrl.init();
          };
        }
      };
    });
  })();
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("modules/tabsModule/defaultTpl.html!github:systemjs/plugin-text@0.0.4.js", [], function() {
  return "<!--\nCreate tabs with an icon and label, using the tabs-positive style.\nEach tab's child <ion-nav-view> directive will have its own\nnavigation history that also transitions its views in and out.\n-->\n<ion-tabs class=\"tabs-icon-top tabs-color-active-positive\">\n\n  <!-- Dashboard Tab -->\n  <ion-tab title=\"{{ i18n['home'] || 'Home' }}\"\n           icon-off=\"ion-home\"\n           icon-on=\"ion-home\"\n           href=\"#/tab/home\">\n    <ion-nav-view name=\"tab-welcome\"></ion-nav-view>\n  </ion-tab>\n\n  <ion-tab\n    title=\"{{ i18n['lost-animals'] || 'Lost Animals' }}\"\n    icon-off=\"ion-sad\"\n    icon-on=\"ion-sad\"\n    href=\"#/tab/lost-animals\">\n    <ion-nav-view name=\"lost-animals\"></ion-nav-view>\n  </ion-tab>\n\n  <ion-tab\n    title=\"{{i18n['found-animals'] || 'Found Animals'}}\"\n    icon-off=\"ion-happy\"\n    icon-on=\"ion-happy\"\n    href=\"#/tab/found-animals\">\n    <ion-nav-view name=\"found-animals\"></ion-nav-view>\n  </ion-tab>\n\n  <!--<ion-tab\n    title=\"{{i18n['found-animals'] || 'Found Animals'}}\"\n    icon-off=\"ion-happy\"\n    icon-on=\"ion-happy\"\n    href=\"#/tab/found-animals\">\n    <ion-nav-view name=\"found-animals\"></ion-nav-view>\n  </ion-tab>-->\n\n\n  <!--<ion-tab\n    title=\"Found Cats\"\n    icon-off=\"ion-ios-chatboxes-outline\"\n    icon-on=\"ion-ios-chatboxes\"\n    href=\"#/tab/found-cats-chats\">\n    <ion-nav-view name=\"found-cats-chats\"></ion-nav-view>\n  </ion-tab>\n\n  <ion-tab\n    title=\"Found Dogs\"\n    icon-off=\"ion-ios-chatboxes-outline\"\n    icon-on=\"ion-ios-chatboxes\"\n    href=\"#/tab/found-dogs-chats\">\n    <ion-nav-view name=\"found-dogs-chats\"></ion-nav-view>\n  </ion-tab>-->\n\n  <!--<ion-tab\n    title=\"Lost Cats\"\n    icon-off=\"ion-ios-chatboxes-outline\"\n    icon-on=\"ion-ios-chatboxes\"\n    href=\"#/tab/lost-animals/cats\">\n    <ion-nav-view name=\"lost-animals-cats\"></ion-nav-view>\n  </ion-tab>\n\n  <ion-tab\n    title=\"Lost Dogs\"\n    icon-off=\"ion-ios-chatboxes-outline\"\n    icon-on=\"ion-ios-chatboxes\"\n    href=\"#/tab/lost-animals/dogs\">\n    <ion-nav-view name=\"lost-animals-dogs\"></ion-nav-view>\n  </ion-tab>-->\n\n\n  <!-- Account Tab -->\n  <ion-tab title=\"Account\"\n           icon-off=\"ion-ios-gear-outline\"\n           icon-on=\"ion-ios-gear\"\n           href=\"#/tab/user\">\n    <ion-nav-view name=\"user\"></ion-nav-view>\n  </ion-tab>\n\n</ion-tabs>\n";
});

_removeDefine();
})();
System.register("modules/tabsModule/tabs.module.js", ["modules/tabsModule/defaultTpl.html!github:systemjs/plugin-text@0.0.4.js"], function (_export) {
  "use strict";

  var tabsTpl;
  return {
    setters: [function (_modulesTabsModuleDefaultTplHtmlGithubSystemjsPluginText004Js) {
      tabsTpl = _modulesTabsModuleDefaultTplHtmlGithubSystemjsPluginText004Js["default"];
    }],
    execute: function () {

      (function () {
        "use strict";
        angular.module("PAW.tabsModule", []).config(function ($stateProvider) {
          $stateProvider.state('tab', { // setup an abstract state for the tabs directive
            url: '/tab',
            abstract: true,
            template: tabsTpl
          }).state('tab.user', {
            url: '/user',
            views: {
              'user': {
                templateUrl: 'templates/formTest.html',
                controller: function controller() {}
              }
            }
          });
        }).directive('markRequired', function ($compile) {
          return {
            restrict: 'A',
            require: "form",
            scope: true,
            link: function link(scope, element, attr, form) {
              var labelBuffer,
                  inputBuffer,
                  formItems = element.find('fieldset');

              angular.forEach(formItems, function ($item, key) {
                labelBuffer = $item.getElementsByTagName('LABEL')[0];
                inputBuffer = $item.getElementsByTagName('INPUT')[0];

                inputBuffer.setAttribute("required", "required");
              });

              $compile(element.contents())(scope);
            }
          };
        });
      })();
    }
  };
});
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("modules/homeModule/defaultTpl.html!github:systemjs/plugin-text@0.0.4.js", [], function() {
  return "<ion-view view-title=\"PAW\">\n  <ion-content class=\"padding\">\n    <h2>Welcome to PAW</h2>\n    <p>\n      This is the Ionic starter for tabs-based apps. For other starters and ready-made templates, check out the <a href=\"http://market.ionic.io/starters\" target=\"_blank\">Ionic Market</a>.\n    </p>\n    <p>\n      To edit the content of each tab, edit the corresponding template file in <code>www/templates/</code>. This template is <code>www/templates/tab-dash.html</code>\n    </p>\n    <p>\n      If you need help with your app, join the Ionic Community on the <a href=\"http://forum.ionicframework.com\" target=\"_blank\">Ionic Forum</a>. Make sure to <a href=\"http://twitter.com/ionicframework\" target=\"_blank\">follow us</a> on Twitter to get important updates and announcements for Ionic developers.\n    </p>\n    <p>\n      For help sending push notifications, join the <a href=\"https://apps.ionic.io/signup\" target=\"_blank\">Ionic Platform</a> and check out <a href=\"http://docs.ionic.io/docs/push-overview\" target=\"_blank\">Ionic Push</a>. We also have other services available.\n    </p>\n  </ion-content>\n</ion-view>\n";
});

_removeDefine();
})();
System.register('modules/homeModule/homeModule.js', ['modules/homeModule/defaultTpl.html!github:systemjs/plugin-text@0.0.4.js'], function (_export) {
  /**
   * Created by milenstanev on 2/11/16.
   */
  'use strict';

  var welcomeModuleTpl;
  return {
    setters: [function (_modulesHomeModuleDefaultTplHtmlGithubSystemjsPluginText004Js) {
      welcomeModuleTpl = _modulesHomeModuleDefaultTplHtmlGithubSystemjsPluginText004Js['default'];
    }],
    execute: function () {

      (function () {
        angular.module("PAW.homeModule", []).config(function ($stateProvider, $urlRouterProvider) {
          $stateProvider.state('tab.home', { // Each tab has its own nav history stack:
            url: '/home',
            views: {
              'tab-welcome': {
                template: welcomeModuleTpl,
                controller: angular.noop
              }
            }
          });

          $urlRouterProvider.otherwise('/tab/welcome');
        });
      })();
    }
  };
});
System.register("modules/lostAnimalsModule/lostAnimals.module.js", ["npm:babel-runtime@5.8.35/helpers/get.js", "npm:babel-runtime@5.8.35/helpers/inherits.js", "npm:babel-runtime@5.8.35/helpers/class-call-check.js", "modules/Shared/AnimalsModule.ES2015/index.js"], function (_export) {
  var _get, _inherits, _classCallCheck, AnimalsModule, LostAnimals;

  return {
    setters: [function (_npmBabelRuntime5835HelpersGetJs) {
      _get = _npmBabelRuntime5835HelpersGetJs["default"];
    }, function (_npmBabelRuntime5835HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5835HelpersInheritsJs["default"];
    }, function (_npmBabelRuntime5835HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheckJs["default"];
    }, function (_modulesSharedAnimalsModuleES2015IndexJs) {
      AnimalsModule = _modulesSharedAnimalsModuleES2015IndexJs["default"];
    }],
    execute: function () {
      /**
       * Created by milenstanev on 2/11/16.
       */
      "use strict";

      LostAnimals = (function (_AnimalsModule) {
        _inherits(LostAnimals, _AnimalsModule);

        function LostAnimals() {
          _classCallCheck(this, LostAnimals);

          _get(Object.getPrototypeOf(LostAnimals.prototype), "constructor", this).call(this);

          this.config = {
            "moduleType": "Lost",
            "mainModule": "lostAnimals",
            "mainState": "lost-animals",
            "categories": [{
              "cat": "cats",
              "title": "lost-cats",
              "categoryDescription": "Lorem ipsum ..."
            }, {
              "cat": "dogs",
              "title": "lost-dogs",
              "categoryDescription": "Lorem ipsum ..."
            } /*,
              {
               "cat": "aa",
               "title": "lost-aa",
               "categoryDescription": "dsfsdfsfdsf"
              }*/
            ]
          };
        }

        return LostAnimals;
      })(AnimalsModule);

      new LostAnimals().init();
    }
  };
});
System.register('modules/Shared/AnimalsModule.ES2015/ModuleGenerator.js', ['npm:babel-runtime@5.8.35/helpers/create-class.js', 'npm:babel-runtime@5.8.35/helpers/class-call-check.js'], function (_export) {
  var _createClass, _classCallCheck, LostCategorysAngularModule;

  return {
    setters: [function (_npmBabelRuntime5835HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5835HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5835HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheckJs['default'];
    }],
    execute: function () {
      /**
       * Created by milenstanev on 2/11/16.
       */
      'use strict';

      LostCategorysAngularModule = (function () {
        function LostCategorysAngularModule() {
          _classCallCheck(this, LostCategorysAngularModule);
        }

        _createClass(LostCategorysAngularModule, [{
          key: 'init',
          //TODO: change it to something generic
          value: function init(config) {
            angular.module('PAW.' + config.mainModule + '.' + config.Category + 'Module', []).config(function ($stateProvider) {
              $stateProvider.state('tab.' + config.mainState + '-' + config.category, {
                url: '/' + config.mainState + '/' + config.category,
                views: (function () {
                  /**
                   views: {
                      ${config.mainState}-${config.category}: {
                        templateUrl: tpl,
                        controller: ctrl'
                      }
                    }
                   */
                  var views = {};
                  views['' + config.mainState] = {};
                  views['' + config.mainState]['templateUrl'] = 'templates/tab-chats.html';
                  views['' + config.mainState]['controller'] = config.mainModule + '.' + config.Category + '.ChatsCtrl as ctrl';

                  return views;
                })()
              }).state('tab.' + config.mainState + '-' + config.category + '-add-new', {
                url: '/' + config.mainState + '/' + config.category + '/add-new',
                views: (function () {
                  /**
                   views: {
                      ${config.mainState}-${config.category}: {
                        templateUrl: tpl,
                        controller: ctrl'
                      }
                    }
                   */
                  var views = {};
                  views['' + config.mainState] = {};
                  views['' + config.mainState]['templateUrl'] = 'templates/add-new-tab-chats.html';
                  views['' + config.mainState]['controller'] = config.mainModule + '.' + config.Category + '.ChatsAddNewCtrl as ctrl';

                  return views;
                })()
              }).state('tab.' + config.mainState + '-' + config.category + '-chat', {
                url: '/' + config.mainState + '/' + config.category + '/:chatId',
                //TODO: could be constructor/class
                views: (function () {
                  /**
                   views: {
                      ${config.mainState}-${config.category}: {
                        templateUrl: tpl,
                        controller: ctrl'
                      }
                    }
                   */
                  var views = {};
                  views['' + config.mainState] = {};
                  views['' + config.mainState]['templateUrl'] = 'templates/chat-detail.html';
                  views['' + config.mainState]['controller'] = config.mainModule + '.' + config.Category + '.ChatDetailCtrl as ctrl';

                  return views;
                })()
              });
            }).factory(config.mainModule + '.' + config.Category + '.factory', function () {}).controller(config.mainModule + '.' + config.Category + '.ChatsCtrl', (function () {
              function _class($scope, $rootScope, $timeout, Chats, UserService) {
                var _this = this;

                _classCallCheck(this, _class);

                this.state = 'initial';
                this.chats = Chats['' + config.mainModule]; // Chats['foundAnimals' or 'foundAnimals']
                this.category = config.category;
                this.user = UserService;
                this.url = config.mainState + '/' + config.category;
                this.viewTtitle = $rootScope.i18n[config.Category] || config.Category; //should be i18n key at the end

                Chats['get_' + config.mainModule](config.category).then(function (data) {
                  /**
                   * The timeout is because the $scope don't make $digest for 'this.state' from time to time and we can't change the state in the template
                   */
                  $timeout(function () {
                    if (!data.length) {
                      _this.state = 'no-data';
                    } else {
                      _this.state = 'ready';
                    }
                  });
                }, function (error) {
                  _this.state = 'error';
                });

                $scope.$on('$destroy', function () {
                  if (_this.chats) _this.chats.shiftAll();
                });

                this.states = {
                  toggleAddNew: false
                };
              }

              return _class;
            })()).controller(config.mainModule + '.' + config.Category + '.ChatsAddNewCtrl', (function () {
              function _class2(Chats) {
                var _this2 = this;

                _classCallCheck(this, _class2);

                //TODO: require authentication
                this.fromData = undefined;

                this.add = function () {
                  Chats['add_' + config.mainModule](config.category, _this2.fromData).success(function (res) {
                    Chats['' + config.mainModule].unshift(res);
                    history.back();
                  }).error(function () {
                    //TODO: implement errors
                  });
                };
              }

              return _class2;
            })()).controller(config.mainModule + '.' + config.Category + '.ChatDetailCtrl', (function () {
              function _class3($stateParams, Chats, $timeout) {
                var _this3 = this;

                _classCallCheck(this, _class3);

                this.state = 'initial';
                this.newMessage = '';
                this.messagesData = Chats.messages;

                Chats.getMessages($stateParams.chatId).then(
                // Success
                function (data) {
                  $timeout(function () {
                    if (!data.length) {
                      _this3.state = 'no-data';
                    } else {
                      _this3.state = 'ready';
                    }
                  });
                },
                // Error
                function (error) {
                  //TODO: implementation
                  _this3.state = 'error';
                });

                //sendMessages
                this.send = function () {
                  if (_this3.newMessage) {
                    Chats.sendMessages($stateParams.chatId, _this3.newMessage, function () {
                      _this3.newMessage = "";
                    });
                  }
                };
              }

              return _class3;
            })());
          }
        }]);

        return LostCategorysAngularModule;
      })();

      _export('default', LostCategorysAngularModule);
    }
  };
});
System.register('modules/Shared/AnimalsModule.ES2015/index.js', ['npm:babel-runtime@5.8.35/helpers/create-class.js', 'npm:babel-runtime@5.8.35/helpers/class-call-check.js', 'modules/Shared/AnimalsModule.ES2015/ModuleGenerator.js'], function (_export) {
  var _createClass, _classCallCheck, ModuleGenerator, Module;

  return {
    setters: [function (_npmBabelRuntime5835HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5835HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5835HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheckJs['default'];
    }, function (_modulesSharedAnimalsModuleES2015ModuleGeneratorJs) {
      ModuleGenerator = _modulesSharedAnimalsModuleES2015ModuleGeneratorJs['default'];
    }],
    execute: function () {
      /**
       * Created by milenstanev on 2/11/16.
       */
      //TODO: change it to generic names

      'use strict';

      Module = (function () {
        function Module() {
          _classCallCheck(this, Module);

          this.config = undefined;
        }

        _createClass(Module, [{
          key: 'init',
          value: function init() {
            var _this = this;

            var moduleConfig = (function () {
              /**
               * because of this we are able to handle object and JSON at same time
               */
              return typeof _this.config === "object" ? _this.config : JSON.parse(_this.config);
            })();
            var modulesStringCollection = [];
            var linksDataCollection = [];
            var mainModule = moduleConfig.mainModule;
            var mainState = moduleConfig.mainState;

            (function () {
              var configChildModules = undefined;
              var categories = moduleConfig.categories;
              var len = moduleConfig.categories.length;

              while (len--) {
                /**
                 * The constructor/class will instantiate angular modules for each category|animal
                 */
                configChildModules = {
                  category: categories[len].cat,
                  Category: categories[len].cat.charAt(0).toUpperCase() + categories[len].cat.slice(1),
                  mainModule: mainModule,
                  mainState: mainState
                };

                //TODO: check whats happened here after latest update
                new ModuleGenerator().init(configChildModules);

                /**
                 * Generate Modules Names in order to be assigned as dependencies on current module "`PAW.${mainModule}Module`"
                 */
                modulesStringCollection.push('PAW.' + mainModule + '.' + configChildModules.Category + 'Module');

                /**
                 * url's assigned to the category link list
                 */
                linksDataCollection.push({
                  title: categories[len].title,
                  description: categories[len].categoryDescription,
                  url: mainState,
                  id: configChildModules.category
                });
              }
            })();

            //region Old way of instantiating modules
            /**
             * Cats Angular Module
             * instantiate "PAW.lostAnimalsModule.lostCatsModule"
             */
            /*new LostAnimal().init({
             animal: "cats",
             Animal: "Cats",
             mainModule: mainModule,
             mainState: mainState
             });*/

            /**
             * Dogs Angular Module
             * instantiate "PAW.lostAnimalsModule.lostCatsModule"
             */
            /*new LostAnimal().init({
             animal: "dogs",
             Animal: "Dogs",
             mainModule: mainModule,
             mainState: mainState
             });*/
            //endregion

            angular.module('PAW.' + mainModule + 'Module', modulesStringCollection /*[
                                                                                   `PAW.${mainModule}.CatsModule`,
                                                                                   `PAW.${mainModule}.DogsModule`
                                                                                   ]*/).config(function ($stateProvider, $urlRouterProvider) {
              $stateProvider.state('tab.' + mainState, {
                url: '/' + mainState,
                views: (function () {
                  var views = {};
                  views['' + mainState] = {};
                  views['' + mainState]['templateUrl'] = 'templates/links-list.html';
                  views['' + mainState]['controller'] = mainModule + 'Ctrl as ctrl';

                  return views;
                })()
              });

              $urlRouterProvider.otherwise('/tab/' + mainState);
            }).controller(mainModule + 'Ctrl', (function () {
              function _class($rootScope) {
                _classCallCheck(this, _class);

                this.viewTtitle = $rootScope.i18n[mainState] || mainState;
                this.links = linksDataCollection;
              }

              return _class;
            })());
          }
        }]);

        return Module;
      })();

      _export('default', Module);
    }
  };
});
System.register("modules/foundAnimalsModule/foundAnimals.module.js", ["npm:babel-runtime@5.8.35/helpers/get.js", "npm:babel-runtime@5.8.35/helpers/inherits.js", "npm:babel-runtime@5.8.35/helpers/class-call-check.js", "modules/Shared/AnimalsModule.ES2015/index.js"], function (_export) {
  var _get, _inherits, _classCallCheck, AnimalsModule, FoundAnimals;

  return {
    setters: [function (_npmBabelRuntime5835HelpersGetJs) {
      _get = _npmBabelRuntime5835HelpersGetJs["default"];
    }, function (_npmBabelRuntime5835HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5835HelpersInheritsJs["default"];
    }, function (_npmBabelRuntime5835HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheckJs["default"];
    }, function (_modulesSharedAnimalsModuleES2015IndexJs) {
      AnimalsModule = _modulesSharedAnimalsModuleES2015IndexJs["default"];
    }],
    execute: function () {
      /**
       * Created by milenstanev on 2/11/16.
       */
      "use strict";

      FoundAnimals = (function (_AnimalsModule) {
        _inherits(FoundAnimals, _AnimalsModule);

        function FoundAnimals() {
          _classCallCheck(this, FoundAnimals);

          _get(Object.getPrototypeOf(FoundAnimals.prototype), "constructor", this).call(this);

          this.config = {
            "moduleType": "Found",
            "mainModule": "foundAnimals",
            "mainState": "found-animals",
            "categories": [{
              "cat": "cats",
              "title": "found-cats",
              "categoryDescription": "Lorem ipsum ..."
            }, {
              "cat": "dogs",
              "title": "found-dogs",
              "categoryDescription": "Lorem ipsum ..."
            } /*,
              {
               "cat": "aa",
               "title": "found-aa",
               "categoryDescription": "dsfsdfsfdsf"
              }*/
            ]
          };
        }

        return FoundAnimals;
      })(AnimalsModule);

      new FoundAnimals().init();
    }
  };
});
System.register("services/User.js", ["npm:babel-runtime@5.8.35/helpers/create-class.js", "npm:babel-runtime@5.8.35/helpers/class-call-check.js"], function (_export) {
    var _createClass, _classCallCheck, User;

    return {
        setters: [function (_npmBabelRuntime5835HelpersCreateClassJs) {
            _createClass = _npmBabelRuntime5835HelpersCreateClassJs["default"];
        }, function (_npmBabelRuntime5835HelpersClassCallCheckJs) {
            _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheckJs["default"];
        }],
        execute: function () {
            "use strict";

            User = (function () {
                function User($timeout) {
                    _classCallCheck(this, User);

                    this.$timeout = $timeout;

                    this.userId = 0;
                    this.nickname = "";
                    this.userName = {
                        surname: "",
                        givenName: ""
                    };
                    this.userLanguage = "";
                    this.token = "asd";
                    this.isLoggedIn = false;

                    this.checkIsLoggedIn();
                }

                _createClass(User, [{
                    key: "checkIsLoggedIn",
                    value: function checkIsLoggedIn() {
                        var self = this;

                        function applayChange(booleanParam) {
                            self.$timeout(function () {
                                self.isLoggedIn = booleanParam;

                                return booleanParam;
                            });
                        }

                        if (this.token) {
                            if (!this.isLoggedIn) {
                                applayChange(true);
                            }
                        } else {
                            if (this.isLoggedIn) {
                                applayChange(false);
                            }
                        }
                    }
                }]);

                return User;
            })();

            _export("default", User);
        }
    };
});
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
(function(f) {
  if (typeof exports === "object" && typeof module !== "undefined") {
    module.exports = f();
  } else if (typeof define === "function" && define.amd) {
    define("lib/socket.io-client/socket.io.js", [], f);
  } else {
    var g;
    if (typeof window !== "undefined") {
      g = window;
    } else if (typeof global !== "undefined") {
      g = global;
    } else if (typeof self !== "undefined") {
      g = self;
    } else {
      g = this;
    }
    g.io = f();
  }
})(function() {
  var define,
      module,
      exports;
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a)
            return a(o, !0);
          if (i)
            return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }
        var l = n[o] = {exports: {}};
        t[o][0].call(l.exports, function(e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }
      return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++)
      s(r[o]);
    return s;
  })({
    1: [function(_dereq_, module, exports) {
      module.exports = _dereq_('./lib/');
    }, {"./lib/": 2}],
    2: [function(_dereq_, module, exports) {
      module.exports = _dereq_('./socket');
      module.exports.parser = _dereq_('engine.io-parser');
    }, {
      "./socket": 3,
      "engine.io-parser": 19
    }],
    3: [function(_dereq_, module, exports) {
      (function(global) {
        var transports = _dereq_('./transports');
        var Emitter = _dereq_('component-emitter');
        var debug = _dereq_('debug')('engine.io-client:socket');
        var index = _dereq_('indexof');
        var parser = _dereq_('engine.io-parser');
        var parseuri = _dereq_('parseuri');
        var parsejson = _dereq_('parsejson');
        var parseqs = _dereq_('parseqs');
        module.exports = Socket;
        function noop() {}
        function Socket(uri, opts) {
          if (!(this instanceof Socket))
            return new Socket(uri, opts);
          opts = opts || {};
          if (uri && 'object' == typeof uri) {
            opts = uri;
            uri = null;
          }
          if (uri) {
            uri = parseuri(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
            opts.port = uri.port;
            if (uri.query)
              opts.query = uri.query;
          } else if (opts.host) {
            opts.hostname = parseuri(opts.host).host;
          }
          this.secure = null != opts.secure ? opts.secure : (global.location && 'https:' == location.protocol);
          if (opts.hostname && !opts.port) {
            opts.port = this.secure ? '443' : '80';
          }
          this.agent = opts.agent || false;
          this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
          this.port = opts.port || (global.location && location.port ? location.port : (this.secure ? 443 : 80));
          this.query = opts.query || {};
          if ('string' == typeof this.query)
            this.query = parseqs.decode(this.query);
          this.upgrade = false !== opts.upgrade;
          this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
          this.forceJSONP = !!opts.forceJSONP;
          this.jsonp = false !== opts.jsonp;
          this.forceBase64 = !!opts.forceBase64;
          this.enablesXDR = !!opts.enablesXDR;
          this.timestampParam = opts.timestampParam || 't';
          this.timestampRequests = opts.timestampRequests;
          this.transports = opts.transports || ['polling', 'websocket'];
          this.readyState = '';
          this.writeBuffer = [];
          this.policyPort = opts.policyPort || 843;
          this.rememberUpgrade = opts.rememberUpgrade || false;
          this.binaryType = null;
          this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
          this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;
          if (true === this.perMessageDeflate)
            this.perMessageDeflate = {};
          if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
            this.perMessageDeflate.threshold = 1024;
          }
          this.pfx = opts.pfx || null;
          this.key = opts.key || null;
          this.passphrase = opts.passphrase || null;
          this.cert = opts.cert || null;
          this.ca = opts.ca || null;
          this.ciphers = opts.ciphers || null;
          this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
          var freeGlobal = typeof global == 'object' && global;
          if (freeGlobal.global === freeGlobal) {
            if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
              this.extraHeaders = opts.extraHeaders;
            }
          }
          this.open();
        }
        Socket.priorWebsocketSuccess = false;
        Emitter(Socket.prototype);
        Socket.protocol = parser.protocol;
        Socket.Socket = Socket;
        Socket.Transport = _dereq_('./transport');
        Socket.transports = _dereq_('./transports');
        Socket.parser = _dereq_('engine.io-parser');
        Socket.prototype.createTransport = function(name) {
          debug('creating transport "%s"', name);
          var query = clone(this.query);
          query.EIO = parser.protocol;
          query.transport = name;
          if (this.id)
            query.sid = this.id;
          var transport = new transports[name]({
            agent: this.agent,
            hostname: this.hostname,
            port: this.port,
            secure: this.secure,
            path: this.path,
            query: query,
            forceJSONP: this.forceJSONP,
            jsonp: this.jsonp,
            forceBase64: this.forceBase64,
            enablesXDR: this.enablesXDR,
            timestampRequests: this.timestampRequests,
            timestampParam: this.timestampParam,
            policyPort: this.policyPort,
            socket: this,
            pfx: this.pfx,
            key: this.key,
            passphrase: this.passphrase,
            cert: this.cert,
            ca: this.ca,
            ciphers: this.ciphers,
            rejectUnauthorized: this.rejectUnauthorized,
            perMessageDeflate: this.perMessageDeflate,
            extraHeaders: this.extraHeaders
          });
          return transport;
        };
        function clone(obj) {
          var o = {};
          for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
              o[i] = obj[i];
            }
          }
          return o;
        }
        Socket.prototype.open = function() {
          var transport;
          if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
            transport = 'websocket';
          } else if (0 === this.transports.length) {
            var self = this;
            setTimeout(function() {
              self.emit('error', 'No transports available');
            }, 0);
            return;
          } else {
            transport = this.transports[0];
          }
          this.readyState = 'opening';
          try {
            transport = this.createTransport(transport);
          } catch (e) {
            this.transports.shift();
            this.open();
            return;
          }
          transport.open();
          this.setTransport(transport);
        };
        Socket.prototype.setTransport = function(transport) {
          debug('setting transport %s', transport.name);
          var self = this;
          if (this.transport) {
            debug('clearing existing transport %s', this.transport.name);
            this.transport.removeAllListeners();
          }
          this.transport = transport;
          transport.on('drain', function() {
            self.onDrain();
          }).on('packet', function(packet) {
            self.onPacket(packet);
          }).on('error', function(e) {
            self.onError(e);
          }).on('close', function() {
            self.onClose('transport close');
          });
        };
        Socket.prototype.probe = function(name) {
          debug('probing transport "%s"', name);
          var transport = this.createTransport(name, {probe: 1}),
              failed = false,
              self = this;
          Socket.priorWebsocketSuccess = false;
          function onTransportOpen() {
            if (self.onlyBinaryUpgrades) {
              var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
              failed = failed || upgradeLosesBinary;
            }
            if (failed)
              return;
            debug('probe transport "%s" opened', name);
            transport.send([{
              type: 'ping',
              data: 'probe'
            }]);
            transport.once('packet', function(msg) {
              if (failed)
                return;
              if ('pong' == msg.type && 'probe' == msg.data) {
                debug('probe transport "%s" pong', name);
                self.upgrading = true;
                self.emit('upgrading', transport);
                if (!transport)
                  return;
                Socket.priorWebsocketSuccess = 'websocket' == transport.name;
                debug('pausing current transport "%s"', self.transport.name);
                self.transport.pause(function() {
                  if (failed)
                    return;
                  if ('closed' == self.readyState)
                    return;
                  debug('changing transport and sending upgrade packet');
                  cleanup();
                  self.setTransport(transport);
                  transport.send([{type: 'upgrade'}]);
                  self.emit('upgrade', transport);
                  transport = null;
                  self.upgrading = false;
                  self.flush();
                });
              } else {
                debug('probe transport "%s" failed', name);
                var err = new Error('probe error');
                err.transport = transport.name;
                self.emit('upgradeError', err);
              }
            });
          }
          function freezeTransport() {
            if (failed)
              return;
            failed = true;
            cleanup();
            transport.close();
            transport = null;
          }
          function onerror(err) {
            var error = new Error('probe error: ' + err);
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            self.emit('upgradeError', error);
          }
          function onTransportClose() {
            onerror("transport closed");
          }
          function onclose() {
            onerror("socket closed");
          }
          function onupgrade(to) {
            if (transport && to.name != transport.name) {
              debug('"%s" works - aborting "%s"', to.name, transport.name);
              freezeTransport();
            }
          }
          function cleanup() {
            transport.removeListener('open', onTransportOpen);
            transport.removeListener('error', onerror);
            transport.removeListener('close', onTransportClose);
            self.removeListener('close', onclose);
            self.removeListener('upgrading', onupgrade);
          }
          transport.once('open', onTransportOpen);
          transport.once('error', onerror);
          transport.once('close', onTransportClose);
          this.once('close', onclose);
          this.once('upgrading', onupgrade);
          transport.open();
        };
        Socket.prototype.onOpen = function() {
          debug('socket open');
          this.readyState = 'open';
          Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
          this.emit('open');
          this.flush();
          if ('open' == this.readyState && this.upgrade && this.transport.pause) {
            debug('starting upgrade probes');
            for (var i = 0,
                l = this.upgrades.length; i < l; i++) {
              this.probe(this.upgrades[i]);
            }
          }
        };
        Socket.prototype.onPacket = function(packet) {
          if ('opening' == this.readyState || 'open' == this.readyState) {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emit('packet', packet);
            this.emit('heartbeat');
            switch (packet.type) {
              case 'open':
                this.onHandshake(parsejson(packet.data));
                break;
              case 'pong':
                this.setPing();
                this.emit('pong');
                break;
              case 'error':
                var err = new Error('server error');
                err.code = packet.data;
                this.onError(err);
                break;
              case 'message':
                this.emit('data', packet.data);
                this.emit('message', packet.data);
                break;
            }
          } else {
            debug('packet received with socket readyState "%s"', this.readyState);
          }
        };
        Socket.prototype.onHandshake = function(data) {
          this.emit('handshake', data);
          this.id = data.sid;
          this.transport.query.sid = data.sid;
          this.upgrades = this.filterUpgrades(data.upgrades);
          this.pingInterval = data.pingInterval;
          this.pingTimeout = data.pingTimeout;
          this.onOpen();
          if ('closed' == this.readyState)
            return;
          this.setPing();
          this.removeListener('heartbeat', this.onHeartbeat);
          this.on('heartbeat', this.onHeartbeat);
        };
        Socket.prototype.onHeartbeat = function(timeout) {
          clearTimeout(this.pingTimeoutTimer);
          var self = this;
          self.pingTimeoutTimer = setTimeout(function() {
            if ('closed' == self.readyState)
              return;
            self.onClose('ping timeout');
          }, timeout || (self.pingInterval + self.pingTimeout));
        };
        Socket.prototype.setPing = function() {
          var self = this;
          clearTimeout(self.pingIntervalTimer);
          self.pingIntervalTimer = setTimeout(function() {
            debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
            self.ping();
            self.onHeartbeat(self.pingTimeout);
          }, self.pingInterval);
        };
        Socket.prototype.ping = function() {
          var self = this;
          this.sendPacket('ping', function() {
            self.emit('ping');
          });
        };
        Socket.prototype.onDrain = function() {
          this.writeBuffer.splice(0, this.prevBufferLen);
          this.prevBufferLen = 0;
          if (0 === this.writeBuffer.length) {
            this.emit('drain');
          } else {
            this.flush();
          }
        };
        Socket.prototype.flush = function() {
          if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            debug('flushing %d packets in socket', this.writeBuffer.length);
            this.transport.send(this.writeBuffer);
            this.prevBufferLen = this.writeBuffer.length;
            this.emit('flush');
          }
        };
        Socket.prototype.write = Socket.prototype.send = function(msg, options, fn) {
          this.sendPacket('message', msg, options, fn);
          return this;
        };
        Socket.prototype.sendPacket = function(type, data, options, fn) {
          if ('function' == typeof data) {
            fn = data;
            data = undefined;
          }
          if ('function' == typeof options) {
            fn = options;
            options = null;
          }
          if ('closing' == this.readyState || 'closed' == this.readyState) {
            return;
          }
          options = options || {};
          options.compress = false !== options.compress;
          var packet = {
            type: type,
            data: data,
            options: options
          };
          this.emit('packetCreate', packet);
          this.writeBuffer.push(packet);
          if (fn)
            this.once('flush', fn);
          this.flush();
        };
        Socket.prototype.close = function() {
          if ('opening' == this.readyState || 'open' == this.readyState) {
            this.readyState = 'closing';
            var self = this;
            if (this.writeBuffer.length) {
              this.once('drain', function() {
                if (this.upgrading) {
                  waitForUpgrade();
                } else {
                  close();
                }
              });
            } else if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          }
          function close() {
            self.onClose('forced close');
            debug('socket closing - telling transport to close');
            self.transport.close();
          }
          function cleanupAndClose() {
            self.removeListener('upgrade', cleanupAndClose);
            self.removeListener('upgradeError', cleanupAndClose);
            close();
          }
          function waitForUpgrade() {
            self.once('upgrade', cleanupAndClose);
            self.once('upgradeError', cleanupAndClose);
          }
          return this;
        };
        Socket.prototype.onError = function(err) {
          debug('socket error %j', err);
          Socket.priorWebsocketSuccess = false;
          this.emit('error', err);
          this.onClose('transport error', err);
        };
        Socket.prototype.onClose = function(reason, desc) {
          if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
            debug('socket close with reason: "%s"', reason);
            var self = this;
            clearTimeout(this.pingIntervalTimer);
            clearTimeout(this.pingTimeoutTimer);
            this.transport.removeAllListeners('close');
            this.transport.close();
            this.transport.removeAllListeners();
            this.readyState = 'closed';
            this.id = null;
            this.emit('close', reason, desc);
            self.writeBuffer = [];
            self.prevBufferLen = 0;
          }
        };
        Socket.prototype.filterUpgrades = function(upgrades) {
          var filteredUpgrades = [];
          for (var i = 0,
              j = upgrades.length; i < j; i++) {
            if (~index(this.transports, upgrades[i]))
              filteredUpgrades.push(upgrades[i]);
          }
          return filteredUpgrades;
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "./transport": 4,
      "./transports": 5,
      "component-emitter": 15,
      "debug": 17,
      "engine.io-parser": 19,
      "indexof": 23,
      "parsejson": 26,
      "parseqs": 27,
      "parseuri": 28
    }],
    4: [function(_dereq_, module, exports) {
      var parser = _dereq_('engine.io-parser');
      var Emitter = _dereq_('component-emitter');
      module.exports = Transport;
      function Transport(opts) {
        this.path = opts.path;
        this.hostname = opts.hostname;
        this.port = opts.port;
        this.secure = opts.secure;
        this.query = opts.query;
        this.timestampParam = opts.timestampParam;
        this.timestampRequests = opts.timestampRequests;
        this.readyState = '';
        this.agent = opts.agent || false;
        this.socket = opts.socket;
        this.enablesXDR = opts.enablesXDR;
        this.pfx = opts.pfx;
        this.key = opts.key;
        this.passphrase = opts.passphrase;
        this.cert = opts.cert;
        this.ca = opts.ca;
        this.ciphers = opts.ciphers;
        this.rejectUnauthorized = opts.rejectUnauthorized;
        this.extraHeaders = opts.extraHeaders;
      }
      Emitter(Transport.prototype);
      Transport.prototype.onError = function(msg, desc) {
        var err = new Error(msg);
        err.type = 'TransportError';
        err.description = desc;
        this.emit('error', err);
        return this;
      };
      Transport.prototype.open = function() {
        if ('closed' == this.readyState || '' == this.readyState) {
          this.readyState = 'opening';
          this.doOpen();
        }
        return this;
      };
      Transport.prototype.close = function() {
        if ('opening' == this.readyState || 'open' == this.readyState) {
          this.doClose();
          this.onClose();
        }
        return this;
      };
      Transport.prototype.send = function(packets) {
        if ('open' == this.readyState) {
          this.write(packets);
        } else {
          throw new Error('Transport not open');
        }
      };
      Transport.prototype.onOpen = function() {
        this.readyState = 'open';
        this.writable = true;
        this.emit('open');
      };
      Transport.prototype.onData = function(data) {
        var packet = parser.decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
      };
      Transport.prototype.onPacket = function(packet) {
        this.emit('packet', packet);
      };
      Transport.prototype.onClose = function() {
        this.readyState = 'closed';
        this.emit('close');
      };
    }, {
      "component-emitter": 15,
      "engine.io-parser": 19
    }],
    5: [function(_dereq_, module, exports) {
      (function(global) {
        var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
        var XHR = _dereq_('./polling-xhr');
        var JSONP = _dereq_('./polling-jsonp');
        var websocket = _dereq_('./websocket');
        exports.polling = polling;
        exports.websocket = websocket;
        function polling(opts) {
          var xhr;
          var xd = false;
          var xs = false;
          var jsonp = false !== opts.jsonp;
          if (global.location) {
            var isSSL = 'https:' == location.protocol;
            var port = location.port;
            if (!port) {
              port = isSSL ? 443 : 80;
            }
            xd = opts.hostname != location.hostname || port != opts.port;
            xs = opts.secure != isSSL;
          }
          opts.xdomain = xd;
          opts.xscheme = xs;
          xhr = new XMLHttpRequest(opts);
          if ('open' in xhr && !opts.forceJSONP) {
            return new XHR(opts);
          } else {
            if (!jsonp)
              throw new Error('JSONP disabled');
            return new JSONP(opts);
          }
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "./polling-jsonp": 6,
      "./polling-xhr": 7,
      "./websocket": 9,
      "xmlhttprequest-ssl": 10
    }],
    6: [function(_dereq_, module, exports) {
      (function(global) {
        var Polling = _dereq_('./polling');
        var inherit = _dereq_('component-inherit');
        module.exports = JSONPPolling;
        var rNewline = /\n/g;
        var rEscapedNewline = /\\n/g;
        var callbacks;
        var index = 0;
        function empty() {}
        function JSONPPolling(opts) {
          Polling.call(this, opts);
          this.query = this.query || {};
          if (!callbacks) {
            if (!global.___eio)
              global.___eio = [];
            callbacks = global.___eio;
          }
          this.index = callbacks.length;
          var self = this;
          callbacks.push(function(msg) {
            self.onData(msg);
          });
          this.query.j = this.index;
          if (global.document && global.addEventListener) {
            global.addEventListener('beforeunload', function() {
              if (self.script)
                self.script.onerror = empty;
            }, false);
          }
        }
        inherit(JSONPPolling, Polling);
        JSONPPolling.prototype.supportsBinary = false;
        JSONPPolling.prototype.doClose = function() {
          if (this.script) {
            this.script.parentNode.removeChild(this.script);
            this.script = null;
          }
          if (this.form) {
            this.form.parentNode.removeChild(this.form);
            this.form = null;
            this.iframe = null;
          }
          Polling.prototype.doClose.call(this);
        };
        JSONPPolling.prototype.doPoll = function() {
          var self = this;
          var script = document.createElement('script');
          if (this.script) {
            this.script.parentNode.removeChild(this.script);
            this.script = null;
          }
          script.async = true;
          script.src = this.uri();
          script.onerror = function(e) {
            self.onError('jsonp poll error', e);
          };
          var insertAt = document.getElementsByTagName('script')[0];
          if (insertAt) {
            insertAt.parentNode.insertBefore(script, insertAt);
          } else {
            (document.head || document.body).appendChild(script);
          }
          this.script = script;
          var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
          if (isUAgecko) {
            setTimeout(function() {
              var iframe = document.createElement('iframe');
              document.body.appendChild(iframe);
              document.body.removeChild(iframe);
            }, 100);
          }
        };
        JSONPPolling.prototype.doWrite = function(data, fn) {
          var self = this;
          if (!this.form) {
            var form = document.createElement('form');
            var area = document.createElement('textarea');
            var id = this.iframeId = 'eio_iframe_' + this.index;
            var iframe;
            form.className = 'socketio';
            form.style.position = 'absolute';
            form.style.top = '-1000px';
            form.style.left = '-1000px';
            form.target = id;
            form.method = 'POST';
            form.setAttribute('accept-charset', 'utf-8');
            area.name = 'd';
            form.appendChild(area);
            document.body.appendChild(form);
            this.form = form;
            this.area = area;
          }
          this.form.action = this.uri();
          function complete() {
            initIframe();
            fn();
          }
          function initIframe() {
            if (self.iframe) {
              try {
                self.form.removeChild(self.iframe);
              } catch (e) {
                self.onError('jsonp polling iframe removal error', e);
              }
            }
            try {
              var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
              iframe = document.createElement(html);
            } catch (e) {
              iframe = document.createElement('iframe');
              iframe.name = self.iframeId;
              iframe.src = 'javascript:0';
            }
            iframe.id = self.iframeId;
            self.form.appendChild(iframe);
            self.iframe = iframe;
          }
          initIframe();
          data = data.replace(rEscapedNewline, '\\\n');
          this.area.value = data.replace(rNewline, '\\n');
          try {
            this.form.submit();
          } catch (e) {}
          if (this.iframe.attachEvent) {
            this.iframe.onreadystatechange = function() {
              if (self.iframe.readyState == 'complete') {
                complete();
              }
            };
          } else {
            this.iframe.onload = complete;
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "./polling": 8,
      "component-inherit": 16
    }],
    7: [function(_dereq_, module, exports) {
      (function(global) {
        var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
        var Polling = _dereq_('./polling');
        var Emitter = _dereq_('component-emitter');
        var inherit = _dereq_('component-inherit');
        var debug = _dereq_('debug')('engine.io-client:polling-xhr');
        module.exports = XHR;
        module.exports.Request = Request;
        function empty() {}
        function XHR(opts) {
          Polling.call(this, opts);
          if (global.location) {
            var isSSL = 'https:' == location.protocol;
            var port = location.port;
            if (!port) {
              port = isSSL ? 443 : 80;
            }
            this.xd = opts.hostname != global.location.hostname || port != opts.port;
            this.xs = opts.secure != isSSL;
          } else {
            this.extraHeaders = opts.extraHeaders;
          }
        }
        inherit(XHR, Polling);
        XHR.prototype.supportsBinary = true;
        XHR.prototype.request = function(opts) {
          opts = opts || {};
          opts.uri = this.uri();
          opts.xd = this.xd;
          opts.xs = this.xs;
          opts.agent = this.agent || false;
          opts.supportsBinary = this.supportsBinary;
          opts.enablesXDR = this.enablesXDR;
          opts.pfx = this.pfx;
          opts.key = this.key;
          opts.passphrase = this.passphrase;
          opts.cert = this.cert;
          opts.ca = this.ca;
          opts.ciphers = this.ciphers;
          opts.rejectUnauthorized = this.rejectUnauthorized;
          opts.extraHeaders = this.extraHeaders;
          return new Request(opts);
        };
        XHR.prototype.doWrite = function(data, fn) {
          var isBinary = typeof data !== 'string' && data !== undefined;
          var req = this.request({
            method: 'POST',
            data: data,
            isBinary: isBinary
          });
          var self = this;
          req.on('success', fn);
          req.on('error', function(err) {
            self.onError('xhr post error', err);
          });
          this.sendXhr = req;
        };
        XHR.prototype.doPoll = function() {
          debug('xhr poll');
          var req = this.request();
          var self = this;
          req.on('data', function(data) {
            self.onData(data);
          });
          req.on('error', function(err) {
            self.onError('xhr poll error', err);
          });
          this.pollXhr = req;
        };
        function Request(opts) {
          this.method = opts.method || 'GET';
          this.uri = opts.uri;
          this.xd = !!opts.xd;
          this.xs = !!opts.xs;
          this.async = false !== opts.async;
          this.data = undefined != opts.data ? opts.data : null;
          this.agent = opts.agent;
          this.isBinary = opts.isBinary;
          this.supportsBinary = opts.supportsBinary;
          this.enablesXDR = opts.enablesXDR;
          this.pfx = opts.pfx;
          this.key = opts.key;
          this.passphrase = opts.passphrase;
          this.cert = opts.cert;
          this.ca = opts.ca;
          this.ciphers = opts.ciphers;
          this.rejectUnauthorized = opts.rejectUnauthorized;
          this.extraHeaders = opts.extraHeaders;
          this.create();
        }
        Emitter(Request.prototype);
        Request.prototype.create = function() {
          var opts = {
            agent: this.agent,
            xdomain: this.xd,
            xscheme: this.xs,
            enablesXDR: this.enablesXDR
          };
          opts.pfx = this.pfx;
          opts.key = this.key;
          opts.passphrase = this.passphrase;
          opts.cert = this.cert;
          opts.ca = this.ca;
          opts.ciphers = this.ciphers;
          opts.rejectUnauthorized = this.rejectUnauthorized;
          var xhr = this.xhr = new XMLHttpRequest(opts);
          var self = this;
          try {
            debug('xhr open %s: %s', this.method, this.uri);
            xhr.open(this.method, this.uri, this.async);
            try {
              if (this.extraHeaders) {
                xhr.setDisableHeaderCheck(true);
                for (var i in this.extraHeaders) {
                  if (this.extraHeaders.hasOwnProperty(i)) {
                    xhr.setRequestHeader(i, this.extraHeaders[i]);
                  }
                }
              }
            } catch (e) {}
            if (this.supportsBinary) {
              xhr.responseType = 'arraybuffer';
            }
            if ('POST' == this.method) {
              try {
                if (this.isBinary) {
                  xhr.setRequestHeader('Content-type', 'application/octet-stream');
                } else {
                  xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
                }
              } catch (e) {}
            }
            if ('withCredentials' in xhr) {
              xhr.withCredentials = true;
            }
            if (this.hasXDR()) {
              xhr.onload = function() {
                self.onLoad();
              };
              xhr.onerror = function() {
                self.onError(xhr.responseText);
              };
            } else {
              xhr.onreadystatechange = function() {
                if (4 != xhr.readyState)
                  return;
                if (200 == xhr.status || 1223 == xhr.status) {
                  self.onLoad();
                } else {
                  setTimeout(function() {
                    self.onError(xhr.status);
                  }, 0);
                }
              };
            }
            debug('xhr data %s', this.data);
            xhr.send(this.data);
          } catch (e) {
            setTimeout(function() {
              self.onError(e);
            }, 0);
            return;
          }
          if (global.document) {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
          }
        };
        Request.prototype.onSuccess = function() {
          this.emit('success');
          this.cleanup();
        };
        Request.prototype.onData = function(data) {
          this.emit('data', data);
          this.onSuccess();
        };
        Request.prototype.onError = function(err) {
          this.emit('error', err);
          this.cleanup(true);
        };
        Request.prototype.cleanup = function(fromError) {
          if ('undefined' == typeof this.xhr || null === this.xhr) {
            return;
          }
          if (this.hasXDR()) {
            this.xhr.onload = this.xhr.onerror = empty;
          } else {
            this.xhr.onreadystatechange = empty;
          }
          if (fromError) {
            try {
              this.xhr.abort();
            } catch (e) {}
          }
          if (global.document) {
            delete Request.requests[this.index];
          }
          this.xhr = null;
        };
        Request.prototype.onLoad = function() {
          var data;
          try {
            var contentType;
            try {
              contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
            } catch (e) {}
            if (contentType === 'application/octet-stream') {
              data = this.xhr.response;
            } else {
              if (!this.supportsBinary) {
                data = this.xhr.responseText;
              } else {
                try {
                  data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
                } catch (e) {
                  var ui8Arr = new Uint8Array(this.xhr.response);
                  var dataArray = [];
                  for (var idx = 0,
                      length = ui8Arr.length; idx < length; idx++) {
                    dataArray.push(ui8Arr[idx]);
                  }
                  data = String.fromCharCode.apply(null, dataArray);
                }
              }
            }
          } catch (e) {
            this.onError(e);
          }
          if (null != data) {
            this.onData(data);
          }
        };
        Request.prototype.hasXDR = function() {
          return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
        };
        Request.prototype.abort = function() {
          this.cleanup();
        };
        if (global.document) {
          Request.requestsCount = 0;
          Request.requests = {};
          if (global.attachEvent) {
            global.attachEvent('onunload', unloadHandler);
          } else if (global.addEventListener) {
            global.addEventListener('beforeunload', unloadHandler, false);
          }
        }
        function unloadHandler() {
          for (var i in Request.requests) {
            if (Request.requests.hasOwnProperty(i)) {
              Request.requests[i].abort();
            }
          }
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "./polling": 8,
      "component-emitter": 15,
      "component-inherit": 16,
      "debug": 17,
      "xmlhttprequest-ssl": 10
    }],
    8: [function(_dereq_, module, exports) {
      var Transport = _dereq_('../transport');
      var parseqs = _dereq_('parseqs');
      var parser = _dereq_('engine.io-parser');
      var inherit = _dereq_('component-inherit');
      var yeast = _dereq_('yeast');
      var debug = _dereq_('debug')('engine.io-client:polling');
      module.exports = Polling;
      var hasXHR2 = (function() {
        var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
        var xhr = new XMLHttpRequest({xdomain: false});
        return null != xhr.responseType;
      })();
      function Polling(opts) {
        var forceBase64 = (opts && opts.forceBase64);
        if (!hasXHR2 || forceBase64) {
          this.supportsBinary = false;
        }
        Transport.call(this, opts);
      }
      inherit(Polling, Transport);
      Polling.prototype.name = 'polling';
      Polling.prototype.doOpen = function() {
        this.poll();
      };
      Polling.prototype.pause = function(onPause) {
        var pending = 0;
        var self = this;
        this.readyState = 'pausing';
        function pause() {
          debug('paused');
          self.readyState = 'paused';
          onPause();
        }
        if (this.polling || !this.writable) {
          var total = 0;
          if (this.polling) {
            debug('we are currently polling - waiting to pause');
            total++;
            this.once('pollComplete', function() {
              debug('pre-pause polling complete');
              --total || pause();
            });
          }
          if (!this.writable) {
            debug('we are currently writing - waiting to pause');
            total++;
            this.once('drain', function() {
              debug('pre-pause writing complete');
              --total || pause();
            });
          }
        } else {
          pause();
        }
      };
      Polling.prototype.poll = function() {
        debug('polling');
        this.polling = true;
        this.doPoll();
        this.emit('poll');
      };
      Polling.prototype.onData = function(data) {
        var self = this;
        debug('polling got data %s', data);
        var callback = function(packet, index, total) {
          if ('opening' == self.readyState) {
            self.onOpen();
          }
          if ('close' == packet.type) {
            self.onClose();
            return false;
          }
          self.onPacket(packet);
        };
        parser.decodePayload(data, this.socket.binaryType, callback);
        if ('closed' != this.readyState) {
          this.polling = false;
          this.emit('pollComplete');
          if ('open' == this.readyState) {
            this.poll();
          } else {
            debug('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      };
      Polling.prototype.doClose = function() {
        var self = this;
        function close() {
          debug('writing close packet');
          self.write([{type: 'close'}]);
        }
        if ('open' == this.readyState) {
          debug('transport open - closing');
          close();
        } else {
          debug('transport not open - deferring close');
          this.once('open', close);
        }
      };
      Polling.prototype.write = function(packets) {
        var self = this;
        this.writable = false;
        var callbackfn = function() {
          self.writable = true;
          self.emit('drain');
        };
        var self = this;
        parser.encodePayload(packets, this.supportsBinary, function(data) {
          self.doWrite(data, callbackfn);
        });
      };
      Polling.prototype.uri = function() {
        var query = this.query || {};
        var schema = this.secure ? 'https' : 'http';
        var port = '';
        if (false !== this.timestampRequests) {
          query[this.timestampParam] = yeast();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        query = parseqs.encode(query);
        if (this.port && (('https' == schema && this.port != 443) || ('http' == schema && this.port != 80))) {
          port = ':' + this.port;
        }
        if (query.length) {
          query = '?' + query;
        }
        var ipv6 = this.hostname.indexOf(':') !== -1;
        return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
      };
    }, {
      "../transport": 4,
      "component-inherit": 16,
      "debug": 17,
      "engine.io-parser": 19,
      "parseqs": 27,
      "xmlhttprequest-ssl": 10,
      "yeast": 30
    }],
    9: [function(_dereq_, module, exports) {
      (function(global) {
        var Transport = _dereq_('../transport');
        var parser = _dereq_('engine.io-parser');
        var parseqs = _dereq_('parseqs');
        var inherit = _dereq_('component-inherit');
        var yeast = _dereq_('yeast');
        var debug = _dereq_('debug')('engine.io-client:websocket');
        var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
        var WebSocket = BrowserWebSocket;
        if (!WebSocket && typeof window === 'undefined') {
          try {
            WebSocket = _dereq_('ws');
          } catch (e) {}
        }
        module.exports = WS;
        function WS(opts) {
          var forceBase64 = (opts && opts.forceBase64);
          if (forceBase64) {
            this.supportsBinary = false;
          }
          this.perMessageDeflate = opts.perMessageDeflate;
          Transport.call(this, opts);
        }
        inherit(WS, Transport);
        WS.prototype.name = 'websocket';
        WS.prototype.supportsBinary = true;
        WS.prototype.doOpen = function() {
          if (!this.check()) {
            return;
          }
          var self = this;
          var uri = this.uri();
          var protocols = void(0);
          var opts = {
            agent: this.agent,
            perMessageDeflate: this.perMessageDeflate
          };
          opts.pfx = this.pfx;
          opts.key = this.key;
          opts.passphrase = this.passphrase;
          opts.cert = this.cert;
          opts.ca = this.ca;
          opts.ciphers = this.ciphers;
          opts.rejectUnauthorized = this.rejectUnauthorized;
          if (this.extraHeaders) {
            opts.headers = this.extraHeaders;
          }
          this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
          if (this.ws.binaryType === undefined) {
            this.supportsBinary = false;
          }
          if (this.ws.supports && this.ws.supports.binary) {
            this.supportsBinary = true;
            this.ws.binaryType = 'buffer';
          } else {
            this.ws.binaryType = 'arraybuffer';
          }
          this.addEventListeners();
        };
        WS.prototype.addEventListeners = function() {
          var self = this;
          this.ws.onopen = function() {
            self.onOpen();
          };
          this.ws.onclose = function() {
            self.onClose();
          };
          this.ws.onmessage = function(ev) {
            self.onData(ev.data);
          };
          this.ws.onerror = function(e) {
            self.onError('websocket error', e);
          };
        };
        if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
          WS.prototype.onData = function(data) {
            var self = this;
            setTimeout(function() {
              Transport.prototype.onData.call(self, data);
            }, 0);
          };
        }
        WS.prototype.write = function(packets) {
          var self = this;
          this.writable = false;
          var total = packets.length;
          for (var i = 0,
              l = total; i < l; i++) {
            (function(packet) {
              parser.encodePacket(packet, self.supportsBinary, function(data) {
                if (!BrowserWebSocket) {
                  var opts = {};
                  if (packet.options) {
                    opts.compress = packet.options.compress;
                  }
                  if (self.perMessageDeflate) {
                    var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
                    if (len < self.perMessageDeflate.threshold) {
                      opts.compress = false;
                    }
                  }
                }
                try {
                  if (BrowserWebSocket) {
                    self.ws.send(data);
                  } else {
                    self.ws.send(data, opts);
                  }
                } catch (e) {
                  debug('websocket closed before onclose event');
                }
                --total || done();
              });
            })(packets[i]);
          }
          function done() {
            self.emit('flush');
            setTimeout(function() {
              self.writable = true;
              self.emit('drain');
            }, 0);
          }
        };
        WS.prototype.onClose = function() {
          Transport.prototype.onClose.call(this);
        };
        WS.prototype.doClose = function() {
          if (typeof this.ws !== 'undefined') {
            this.ws.close();
          }
        };
        WS.prototype.uri = function() {
          var query = this.query || {};
          var schema = this.secure ? 'wss' : 'ws';
          var port = '';
          if (this.port && (('wss' == schema && this.port != 443) || ('ws' == schema && this.port != 80))) {
            port = ':' + this.port;
          }
          if (this.timestampRequests) {
            query[this.timestampParam] = yeast();
          }
          if (!this.supportsBinary) {
            query.b64 = 1;
          }
          query = parseqs.encode(query);
          if (query.length) {
            query = '?' + query;
          }
          var ipv6 = this.hostname.indexOf(':') !== -1;
          return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
        };
        WS.prototype.check = function() {
          return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "../transport": 4,
      "component-inherit": 16,
      "debug": 17,
      "engine.io-parser": 19,
      "parseqs": 27,
      "ws": undefined,
      "yeast": 30
    }],
    10: [function(_dereq_, module, exports) {
      var hasCORS = _dereq_('has-cors');
      module.exports = function(opts) {
        var xdomain = opts.xdomain;
        var xscheme = opts.xscheme;
        var enablesXDR = opts.enablesXDR;
        try {
          if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}
        try {
          if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {}
        if (!xdomain) {
          try {
            return new ActiveXObject('Microsoft.XMLHTTP');
          } catch (e) {}
        }
      };
    }, {"has-cors": 22}],
    11: [function(_dereq_, module, exports) {
      module.exports = after;
      function after(count, callback, err_cb) {
        var bail = false;
        err_cb = err_cb || noop;
        proxy.count = count;
        return (count === 0) ? callback() : proxy;
        function proxy(err, result) {
          if (proxy.count <= 0) {
            throw new Error('after called too many times');
          }
          --proxy.count;
          if (err) {
            bail = true;
            callback(err);
            callback = err_cb;
          } else if (proxy.count === 0 && !bail) {
            callback(null, result);
          }
        }
      }
      function noop() {}
    }, {}],
    12: [function(_dereq_, module, exports) {
      module.exports = function(arraybuffer, start, end) {
        var bytes = arraybuffer.byteLength;
        start = start || 0;
        end = end || bytes;
        if (arraybuffer.slice) {
          return arraybuffer.slice(start, end);
        }
        if (start < 0) {
          start += bytes;
        }
        if (end < 0) {
          end += bytes;
        }
        if (end > bytes) {
          end = bytes;
        }
        if (start >= bytes || start >= end || bytes === 0) {
          return new ArrayBuffer(0);
        }
        var abv = new Uint8Array(arraybuffer);
        var result = new Uint8Array(end - start);
        for (var i = start,
            ii = 0; i < end; i++, ii++) {
          result[ii] = abv[i];
        }
        return result.buffer;
      };
    }, {}],
    13: [function(_dereq_, module, exports) {
      (function(chars) {
        "use strict";
        exports.encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer),
              i,
              len = bytes.length,
              base64 = "";
          for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
            base64 += chars[bytes[i + 2] & 63];
          }
          if ((len % 3) === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        exports.decode = function(base64) {
          var bufferLength = base64.length * 0.75,
              len = base64.length,
              i,
              p = 0,
              encoded1,
              encoded2,
              encoded3,
              encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength),
              bytes = new Uint8Array(arraybuffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i + 1]);
            encoded3 = chars.indexOf(base64[i + 2]);
            encoded4 = chars.indexOf(base64[i + 3]);
            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
          }
          return arraybuffer;
        };
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    }, {}],
    14: [function(_dereq_, module, exports) {
      (function(global) {
        var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;
        var blobSupported = (function() {
          try {
            var a = new Blob(['hi']);
            return a.size === 2;
          } catch (e) {
            return false;
          }
        })();
        var blobSupportsArrayBufferView = blobSupported && (function() {
          try {
            var b = new Blob([new Uint8Array([1, 2])]);
            return b.size === 2;
          } catch (e) {
            return false;
          }
        })();
        var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
        function mapArrayBufferViews(ary) {
          for (var i = 0; i < ary.length; i++) {
            var chunk = ary[i];
            if (chunk.buffer instanceof ArrayBuffer) {
              var buf = chunk.buffer;
              if (chunk.byteLength !== buf.byteLength) {
                var copy = new Uint8Array(chunk.byteLength);
                copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
                buf = copy.buffer;
              }
              ary[i] = buf;
            }
          }
        }
        function BlobBuilderConstructor(ary, options) {
          options = options || {};
          var bb = new BlobBuilder();
          mapArrayBufferViews(ary);
          for (var i = 0; i < ary.length; i++) {
            bb.append(ary[i]);
          }
          return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
        }
        ;
        function BlobConstructor(ary, options) {
          mapArrayBufferViews(ary);
          return new Blob(ary, options || {});
        }
        ;
        module.exports = (function() {
          if (blobSupported) {
            return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
          } else if (blobBuilderSupported) {
            return BlobBuilderConstructor;
          } else {
            return undefined;
          }
        })();
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}],
    15: [function(_dereq_, module, exports) {
      module.exports = Emitter;
      function Emitter(obj) {
        if (obj)
          return mixin(obj);
      }
      ;
      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks[event] = this._callbacks[event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        var self = this;
        this._callbacks = this._callbacks || {};
        function on() {
          self.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks[event];
        if (!callbacks)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks[event];
          return this;
        }
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this._callbacks[event];
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0,
              len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks[event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    }, {}],
    16: [function(_dereq_, module, exports) {
      module.exports = function(a, b) {
        var fn = function() {};
        fn.prototype = b.prototype;
        a.prototype = new fn;
        a.prototype.constructor = a;
      };
    }, {}],
    17: [function(_dereq_, module, exports) {
      exports = module.exports = _dereq_('./debug');
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();
      exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];
      function useColors() {
        return ('WebkitAppearance' in document.documentElement.style) || (window.console && (console.firebug || (console.exception && console.table))) || (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
      }
      exports.formatters.j = function(v) {
        return JSON.stringify(v);
      };
      function formatArgs() {
        var args = arguments;
        var useColors = this.useColors;
        args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);
        if (!useColors)
          return args;
        var c = 'color: ' + this.color;
        args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-z%]/g, function(match) {
          if ('%%' === match)
            return;
          index++;
          if ('%c' === match) {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
        return args;
      }
      function log() {
        return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
      }
      function save(namespaces) {
        try {
          if (null == namespaces) {
            exports.storage.removeItem('debug');
          } else {
            exports.storage.debug = namespaces;
          }
        } catch (e) {}
      }
      function load() {
        var r;
        try {
          r = exports.storage.debug;
        } catch (e) {}
        return r;
      }
      exports.enable(load());
      function localstorage() {
        try {
          return window.localStorage;
        } catch (e) {}
      }
    }, {"./debug": 18}],
    18: [function(_dereq_, module, exports) {
      exports = module.exports = debug;
      exports.coerce = coerce;
      exports.disable = disable;
      exports.enable = enable;
      exports.enabled = enabled;
      exports.humanize = _dereq_('ms');
      exports.names = [];
      exports.skips = [];
      exports.formatters = {};
      var prevColor = 0;
      var prevTime;
      function selectColor() {
        return exports.colors[prevColor++ % exports.colors.length];
      }
      function debug(namespace) {
        function disabled() {}
        disabled.enabled = false;
        function enabled() {
          var self = enabled;
          var curr = +new Date();
          var ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          if (null == self.useColors)
            self.useColors = exports.useColors();
          if (null == self.color && self.useColors)
            self.color = selectColor();
          var args = Array.prototype.slice.call(arguments);
          args[0] = exports.coerce(args[0]);
          if ('string' !== typeof args[0]) {
            args = ['%o'].concat(args);
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
            if (match === '%%')
              return match;
            index++;
            var formatter = exports.formatters[format];
            if ('function' === typeof formatter) {
              var val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          if ('function' === typeof exports.formatArgs) {
            args = exports.formatArgs.apply(self, args);
          }
          var logFn = enabled.log || exports.log || console.log.bind(console);
          logFn.apply(self, args);
        }
        enabled.enabled = true;
        var fn = exports.enabled(namespace) ? enabled : disabled;
        fn.namespace = namespace;
        return fn;
      }
      function enable(namespaces) {
        exports.save(namespaces);
        var split = (namespaces || '').split(/[\s,]+/);
        var len = split.length;
        for (var i = 0; i < len; i++) {
          if (!split[i])
            continue;
          namespaces = split[i].replace(/\*/g, '.*?');
          if (namespaces[0] === '-') {
            exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
          } else {
            exports.names.push(new RegExp('^' + namespaces + '$'));
          }
        }
      }
      function disable() {
        exports.enable('');
      }
      function enabled(name) {
        var i,
            len;
        for (i = 0, len = exports.skips.length; i < len; i++) {
          if (exports.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = exports.names.length; i < len; i++) {
          if (exports.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error)
          return val.stack || val.message;
        return val;
      }
    }, {"ms": 25}],
    19: [function(_dereq_, module, exports) {
      (function(global) {
        var keys = _dereq_('./keys');
        var hasBinary = _dereq_('has-binary');
        var sliceBuffer = _dereq_('arraybuffer.slice');
        var base64encoder = _dereq_('base64-arraybuffer');
        var after = _dereq_('after');
        var utf8 = _dereq_('utf8');
        var isAndroid = navigator.userAgent.match(/Android/i);
        var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);
        var dontSendBlobs = isAndroid || isPhantomJS;
        exports.protocol = 3;
        var packets = exports.packets = {
          open: 0,
          close: 1,
          ping: 2,
          pong: 3,
          message: 4,
          upgrade: 5,
          noop: 6
        };
        var packetslist = keys(packets);
        var err = {
          type: 'error',
          data: 'parser error'
        };
        var Blob = _dereq_('blob');
        exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
          if ('function' == typeof supportsBinary) {
            callback = supportsBinary;
            supportsBinary = false;
          }
          if ('function' == typeof utf8encode) {
            callback = utf8encode;
            utf8encode = null;
          }
          var data = (packet.data === undefined) ? undefined : packet.data.buffer || packet.data;
          if (global.ArrayBuffer && data instanceof ArrayBuffer) {
            return encodeArrayBuffer(packet, supportsBinary, callback);
          } else if (Blob && data instanceof global.Blob) {
            return encodeBlob(packet, supportsBinary, callback);
          }
          if (data && data.base64) {
            return encodeBase64Object(packet, callback);
          }
          var encoded = packets[packet.type];
          if (undefined !== packet.data) {
            encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
          }
          return callback('' + encoded);
        };
        function encodeBase64Object(packet, callback) {
          var message = 'b' + exports.packets[packet.type] + packet.data.data;
          return callback(message);
        }
        function encodeArrayBuffer(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }
          var data = packet.data;
          var contentArray = new Uint8Array(data);
          var resultBuffer = new Uint8Array(1 + data.byteLength);
          resultBuffer[0] = packets[packet.type];
          for (var i = 0; i < contentArray.length; i++) {
            resultBuffer[i + 1] = contentArray[i];
          }
          return callback(resultBuffer.buffer);
        }
        function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }
          var fr = new FileReader();
          fr.onload = function() {
            packet.data = fr.result;
            exports.encodePacket(packet, supportsBinary, true, callback);
          };
          return fr.readAsArrayBuffer(packet.data);
        }
        function encodeBlob(packet, supportsBinary, callback) {
          if (!supportsBinary) {
            return exports.encodeBase64Packet(packet, callback);
          }
          if (dontSendBlobs) {
            return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
          }
          var length = new Uint8Array(1);
          length[0] = packets[packet.type];
          var blob = new Blob([length.buffer, packet.data]);
          return callback(blob);
        }
        exports.encodeBase64Packet = function(packet, callback) {
          var message = 'b' + exports.packets[packet.type];
          if (Blob && packet.data instanceof global.Blob) {
            var fr = new FileReader();
            fr.onload = function() {
              var b64 = fr.result.split(',')[1];
              callback(message + b64);
            };
            return fr.readAsDataURL(packet.data);
          }
          var b64data;
          try {
            b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
          } catch (e) {
            var typed = new Uint8Array(packet.data);
            var basic = new Array(typed.length);
            for (var i = 0; i < typed.length; i++) {
              basic[i] = typed[i];
            }
            b64data = String.fromCharCode.apply(null, basic);
          }
          message += global.btoa(b64data);
          return callback(message);
        };
        exports.decodePacket = function(data, binaryType, utf8decode) {
          if (typeof data == 'string' || data === undefined) {
            if (data.charAt(0) == 'b') {
              return exports.decodeBase64Packet(data.substr(1), binaryType);
            }
            if (utf8decode) {
              try {
                data = utf8.decode(data);
              } catch (e) {
                return err;
              }
            }
            var type = data.charAt(0);
            if (Number(type) != type || !packetslist[type]) {
              return err;
            }
            if (data.length > 1) {
              return {
                type: packetslist[type],
                data: data.substring(1)
              };
            } else {
              return {type: packetslist[type]};
            }
          }
          var asArray = new Uint8Array(data);
          var type = asArray[0];
          var rest = sliceBuffer(data, 1);
          if (Blob && binaryType === 'blob') {
            rest = new Blob([rest]);
          }
          return {
            type: packetslist[type],
            data: rest
          };
        };
        exports.decodeBase64Packet = function(msg, binaryType) {
          var type = packetslist[msg.charAt(0)];
          if (!global.ArrayBuffer) {
            return {
              type: type,
              data: {
                base64: true,
                data: msg.substr(1)
              }
            };
          }
          var data = base64encoder.decode(msg.substr(1));
          if (binaryType === 'blob' && Blob) {
            data = new Blob([data]);
          }
          return {
            type: type,
            data: data
          };
        };
        exports.encodePayload = function(packets, supportsBinary, callback) {
          if (typeof supportsBinary == 'function') {
            callback = supportsBinary;
            supportsBinary = null;
          }
          var isBinary = hasBinary(packets);
          if (supportsBinary && isBinary) {
            if (Blob && !dontSendBlobs) {
              return exports.encodePayloadAsBlob(packets, callback);
            }
            return exports.encodePayloadAsArrayBuffer(packets, callback);
          }
          if (!packets.length) {
            return callback('0:');
          }
          function setLengthHeader(message) {
            return message.length + ':' + message;
          }
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
              doneCallback(null, setLengthHeader(message));
            });
          }
          map(packets, encodeOne, function(err, results) {
            return callback(results.join(''));
          });
        };
        function map(ary, each, done) {
          var result = new Array(ary.length);
          var next = after(ary.length, done);
          var eachWithIndex = function(i, el, cb) {
            each(el, function(error, msg) {
              result[i] = msg;
              cb(error, result);
            });
          };
          for (var i = 0; i < ary.length; i++) {
            eachWithIndex(i, ary[i], next);
          }
        }
        exports.decodePayload = function(data, binaryType, callback) {
          if (typeof data != 'string') {
            return exports.decodePayloadAsBinary(data, binaryType, callback);
          }
          if (typeof binaryType === 'function') {
            callback = binaryType;
            binaryType = null;
          }
          var packet;
          if (data == '') {
            return callback(err, 0, 1);
          }
          var length = '',
              n,
              msg;
          for (var i = 0,
              l = data.length; i < l; i++) {
            var chr = data.charAt(i);
            if (':' != chr) {
              length += chr;
            } else {
              if ('' == length || (length != (n = Number(length)))) {
                return callback(err, 0, 1);
              }
              msg = data.substr(i + 1, n);
              if (length != msg.length) {
                return callback(err, 0, 1);
              }
              if (msg.length) {
                packet = exports.decodePacket(msg, binaryType, true);
                if (err.type == packet.type && err.data == packet.data) {
                  return callback(err, 0, 1);
                }
                var ret = callback(packet, i + n, l);
                if (false === ret)
                  return;
              }
              i += n;
              length = '';
            }
          }
          if (length != '') {
            return callback(err, 0, 1);
          }
        };
        exports.encodePayloadAsArrayBuffer = function(packets, callback) {
          if (!packets.length) {
            return callback(new ArrayBuffer(0));
          }
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, true, true, function(data) {
              return doneCallback(null, data);
            });
          }
          map(packets, encodeOne, function(err, encodedPackets) {
            var totalLength = encodedPackets.reduce(function(acc, p) {
              var len;
              if (typeof p === 'string') {
                len = p.length;
              } else {
                len = p.byteLength;
              }
              return acc + len.toString().length + len + 2;
            }, 0);
            var resultArray = new Uint8Array(totalLength);
            var bufferIndex = 0;
            encodedPackets.forEach(function(p) {
              var isString = typeof p === 'string';
              var ab = p;
              if (isString) {
                var view = new Uint8Array(p.length);
                for (var i = 0; i < p.length; i++) {
                  view[i] = p.charCodeAt(i);
                }
                ab = view.buffer;
              }
              if (isString) {
                resultArray[bufferIndex++] = 0;
              } else {
                resultArray[bufferIndex++] = 1;
              }
              var lenStr = ab.byteLength.toString();
              for (var i = 0; i < lenStr.length; i++) {
                resultArray[bufferIndex++] = parseInt(lenStr[i]);
              }
              resultArray[bufferIndex++] = 255;
              var view = new Uint8Array(ab);
              for (var i = 0; i < view.length; i++) {
                resultArray[bufferIndex++] = view[i];
              }
            });
            return callback(resultArray.buffer);
          });
        };
        exports.encodePayloadAsBlob = function(packets, callback) {
          function encodeOne(packet, doneCallback) {
            exports.encodePacket(packet, true, true, function(encoded) {
              var binaryIdentifier = new Uint8Array(1);
              binaryIdentifier[0] = 1;
              if (typeof encoded === 'string') {
                var view = new Uint8Array(encoded.length);
                for (var i = 0; i < encoded.length; i++) {
                  view[i] = encoded.charCodeAt(i);
                }
                encoded = view.buffer;
                binaryIdentifier[0] = 0;
              }
              var len = (encoded instanceof ArrayBuffer) ? encoded.byteLength : encoded.size;
              var lenStr = len.toString();
              var lengthAry = new Uint8Array(lenStr.length + 1);
              for (var i = 0; i < lenStr.length; i++) {
                lengthAry[i] = parseInt(lenStr[i]);
              }
              lengthAry[lenStr.length] = 255;
              if (Blob) {
                var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
                doneCallback(null, blob);
              }
            });
          }
          map(packets, encodeOne, function(err, results) {
            return callback(new Blob(results));
          });
        };
        exports.decodePayloadAsBinary = function(data, binaryType, callback) {
          if (typeof binaryType === 'function') {
            callback = binaryType;
            binaryType = null;
          }
          var bufferTail = data;
          var buffers = [];
          var numberTooLong = false;
          while (bufferTail.byteLength > 0) {
            var tailArray = new Uint8Array(bufferTail);
            var isString = tailArray[0] === 0;
            var msgLength = '';
            for (var i = 1; ; i++) {
              if (tailArray[i] == 255)
                break;
              if (msgLength.length > 310) {
                numberTooLong = true;
                break;
              }
              msgLength += tailArray[i];
            }
            if (numberTooLong)
              return callback(err, 0, 1);
            bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
            msgLength = parseInt(msgLength);
            var msg = sliceBuffer(bufferTail, 0, msgLength);
            if (isString) {
              try {
                msg = String.fromCharCode.apply(null, new Uint8Array(msg));
              } catch (e) {
                var typed = new Uint8Array(msg);
                msg = '';
                for (var i = 0; i < typed.length; i++) {
                  msg += String.fromCharCode(typed[i]);
                }
              }
            }
            buffers.push(msg);
            bufferTail = sliceBuffer(bufferTail, msgLength);
          }
          var total = buffers.length;
          buffers.forEach(function(buffer, i) {
            callback(exports.decodePacket(buffer, binaryType, true), i, total);
          });
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "./keys": 20,
      "after": 11,
      "arraybuffer.slice": 12,
      "base64-arraybuffer": 13,
      "blob": 14,
      "has-binary": 21,
      "utf8": 29
    }],
    20: [function(_dereq_, module, exports) {
      module.exports = Object.keys || function keys(obj) {
        var arr = [];
        var has = Object.prototype.hasOwnProperty;
        for (var i in obj) {
          if (has.call(obj, i)) {
            arr.push(i);
          }
        }
        return arr;
      };
    }, {}],
    21: [function(_dereq_, module, exports) {
      (function(global) {
        var isArray = _dereq_('isarray');
        module.exports = hasBinary;
        function hasBinary(data) {
          function _hasBinary(obj) {
            if (!obj)
              return false;
            if ((global.Buffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer) || (global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
              return true;
            }
            if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                if (_hasBinary(obj[i])) {
                  return true;
                }
              }
            } else if (obj && 'object' == typeof obj) {
              if (obj.toJSON) {
                obj = obj.toJSON();
              }
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                  return true;
                }
              }
            }
            return false;
          }
          return _hasBinary(data);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {"isarray": 24}],
    22: [function(_dereq_, module, exports) {
      try {
        module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
      } catch (err) {
        module.exports = false;
      }
    }, {}],
    23: [function(_dereq_, module, exports) {
      var indexOf = [].indexOf;
      module.exports = function(arr, obj) {
        if (indexOf)
          return arr.indexOf(obj);
        for (var i = 0; i < arr.length; ++i) {
          if (arr[i] === obj)
            return i;
        }
        return -1;
      };
    }, {}],
    24: [function(_dereq_, module, exports) {
      module.exports = Array.isArray || function(arr) {
        return Object.prototype.toString.call(arr) == '[object Array]';
      };
    }, {}],
    25: [function(_dereq_, module, exports) {
      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        if ('string' == typeof val)
          return parse(val);
        return options.long ? long(val) : short(val);
      };
      function parse(str) {
        str = '' + str;
        if (str.length > 10000)
          return;
        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
        if (!match)
          return;
        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();
        switch (type) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;
          case 'days':
          case 'day':
          case 'd':
            return n * d;
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;
        }
      }
      function short(ms) {
        if (ms >= d)
          return Math.round(ms / d) + 'd';
        if (ms >= h)
          return Math.round(ms / h) + 'h';
        if (ms >= m)
          return Math.round(ms / m) + 'm';
        if (ms >= s)
          return Math.round(ms / s) + 's';
        return ms + 'ms';
      }
      function long(ms) {
        return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
      }
      function plural(ms, n, name) {
        if (ms < n)
          return;
        if (ms < n * 1.5)
          return Math.floor(ms / n) + ' ' + name;
        return Math.ceil(ms / n) + ' ' + name + 's';
      }
    }, {}],
    26: [function(_dereq_, module, exports) {
      (function(global) {
        var rvalidchars = /^[\],:{}\s]*$/;
        var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
        var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
        var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
        var rtrimLeft = /^\s+/;
        var rtrimRight = /\s+$/;
        module.exports = function parsejson(data) {
          if ('string' != typeof data || !data) {
            return null;
          }
          data = data.replace(rtrimLeft, '').replace(rtrimRight, '');
          if (global.JSON && JSON.parse) {
            return JSON.parse(data);
          }
          if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
            return (new Function('return ' + data))();
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}],
    27: [function(_dereq_, module, exports) {
      exports.encode = function(obj) {
        var str = '';
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (str.length)
              str += '&';
            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
          }
        }
        return str;
      };
      exports.decode = function(qs) {
        var qry = {};
        var pairs = qs.split('&');
        for (var i = 0,
            l = pairs.length; i < l; i++) {
          var pair = pairs[i].split('=');
          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return qry;
      };
    }, {}],
    28: [function(_dereq_, module, exports) {
      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
      module.exports = function parseuri(str) {
        var src = str,
            b = str.indexOf('['),
            e = str.indexOf(']');
        if (b != -1 && e != -1) {
          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
        }
        var m = re.exec(str || ''),
            uri = {},
            i = 14;
        while (i--) {
          uri[parts[i]] = m[i] || '';
        }
        if (b != -1 && e != -1) {
          uri.source = src;
          uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
          uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
          uri.ipv6uri = true;
        }
        return uri;
      };
    }, {}],
    29: [function(_dereq_, module, exports) {
      (function(global) {
        ;
        (function(root) {
          var freeExports = typeof exports == 'object' && exports;
          var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;
          var freeGlobal = typeof global == 'object' && global;
          if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
            root = freeGlobal;
          }
          var stringFromCharCode = String.fromCharCode;
          function ucs2decode(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            var value;
            var extra;
            while (counter < length) {
              value = string.charCodeAt(counter++);
              if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) {
                  output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                } else {
                  output.push(value);
                  counter--;
                }
              } else {
                output.push(value);
              }
            }
            return output;
          }
          function ucs2encode(array) {
            var length = array.length;
            var index = -1;
            var value;
            var output = '';
            while (++index < length) {
              value = array[index];
              if (value > 0xFFFF) {
                value -= 0x10000;
                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                value = 0xDC00 | value & 0x3FF;
              }
              output += stringFromCharCode(value);
            }
            return output;
          }
          function checkScalarValue(codePoint) {
            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
              throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
            }
          }
          function createByte(codePoint, shift) {
            return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
          }
          function encodeCodePoint(codePoint) {
            if ((codePoint & 0xFFFFFF80) == 0) {
              return stringFromCharCode(codePoint);
            }
            var symbol = '';
            if ((codePoint & 0xFFFFF800) == 0) {
              symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
            } else if ((codePoint & 0xFFFF0000) == 0) {
              checkScalarValue(codePoint);
              symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
              symbol += createByte(codePoint, 6);
            } else if ((codePoint & 0xFFE00000) == 0) {
              symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
              symbol += createByte(codePoint, 12);
              symbol += createByte(codePoint, 6);
            }
            symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
            return symbol;
          }
          function utf8encode(string) {
            var codePoints = ucs2decode(string);
            var length = codePoints.length;
            var index = -1;
            var codePoint;
            var byteString = '';
            while (++index < length) {
              codePoint = codePoints[index];
              byteString += encodeCodePoint(codePoint);
            }
            return byteString;
          }
          function readContinuationByte() {
            if (byteIndex >= byteCount) {
              throw Error('Invalid byte index');
            }
            var continuationByte = byteArray[byteIndex] & 0xFF;
            byteIndex++;
            if ((continuationByte & 0xC0) == 0x80) {
              return continuationByte & 0x3F;
            }
            throw Error('Invalid continuation byte');
          }
          function decodeSymbol() {
            var byte1;
            var byte2;
            var byte3;
            var byte4;
            var codePoint;
            if (byteIndex > byteCount) {
              throw Error('Invalid byte index');
            }
            if (byteIndex == byteCount) {
              return false;
            }
            byte1 = byteArray[byteIndex] & 0xFF;
            byteIndex++;
            if ((byte1 & 0x80) == 0) {
              return byte1;
            }
            if ((byte1 & 0xE0) == 0xC0) {
              var byte2 = readContinuationByte();
              codePoint = ((byte1 & 0x1F) << 6) | byte2;
              if (codePoint >= 0x80) {
                return codePoint;
              } else {
                throw Error('Invalid continuation byte');
              }
            }
            if ((byte1 & 0xF0) == 0xE0) {
              byte2 = readContinuationByte();
              byte3 = readContinuationByte();
              codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
              if (codePoint >= 0x0800) {
                checkScalarValue(codePoint);
                return codePoint;
              } else {
                throw Error('Invalid continuation byte');
              }
            }
            if ((byte1 & 0xF8) == 0xF0) {
              byte2 = readContinuationByte();
              byte3 = readContinuationByte();
              byte4 = readContinuationByte();
              codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) | (byte3 << 0x06) | byte4;
              if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
                return codePoint;
              }
            }
            throw Error('Invalid UTF-8 detected');
          }
          var byteArray;
          var byteCount;
          var byteIndex;
          function utf8decode(byteString) {
            byteArray = ucs2decode(byteString);
            byteCount = byteArray.length;
            byteIndex = 0;
            var codePoints = [];
            var tmp;
            while ((tmp = decodeSymbol()) !== false) {
              codePoints.push(tmp);
            }
            return ucs2encode(codePoints);
          }
          var utf8 = {
            'version': '2.0.0',
            'encode': utf8encode,
            'decode': utf8decode
          };
          if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
            define(function() {
              return utf8;
            });
          } else if (freeExports && !freeExports.nodeType) {
            if (freeModule) {
              freeModule.exports = utf8;
            } else {
              var object = {};
              var hasOwnProperty = object.hasOwnProperty;
              for (var key in utf8) {
                hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
              }
            }
          } else {
            root.utf8 = utf8;
          }
        }(this));
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}],
    30: [function(_dereq_, module, exports) {
      'use strict';
      var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
          length = 64,
          map = {},
          seed = 0,
          i = 0,
          prev;
      function encode(num) {
        var encoded = '';
        do {
          encoded = alphabet[num % length] + encoded;
          num = Math.floor(num / length);
        } while (num > 0);
        return encoded;
      }
      function decode(str) {
        var decoded = 0;
        for (i = 0; i < str.length; i++) {
          decoded = decoded * length + map[str.charAt(i)];
        }
        return decoded;
      }
      function yeast() {
        var now = encode(+new Date());
        if (now !== prev)
          return seed = 0, prev = now;
        return now + '.' + encode(seed++);
      }
      for (; i < length; i++)
        map[alphabet[i]] = i;
      yeast.encode = encode;
      yeast.decode = decode;
      module.exports = yeast;
    }, {}],
    31: [function(_dereq_, module, exports) {
      var url = _dereq_('./url');
      var parser = _dereq_('socket.io-parser');
      var Manager = _dereq_('./manager');
      var debug = _dereq_('debug')('socket.io-client');
      module.exports = exports = lookup;
      var cache = exports.managers = {};
      function lookup(uri, opts) {
        if (typeof uri == 'object') {
          opts = uri;
          uri = undefined;
        }
        opts = opts || {};
        var parsed = url(uri);
        var source = parsed.source;
        var id = parsed.id;
        var path = parsed.path;
        var sameNamespace = cache[id] && path in cache[id].nsps;
        var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;
        var io;
        if (newConnection) {
          debug('ignoring socket cache for %s', source);
          io = Manager(source, opts);
        } else {
          if (!cache[id]) {
            debug('new io instance for %s', source);
            cache[id] = Manager(source, opts);
          }
          io = cache[id];
        }
        return io.socket(parsed.path);
      }
      exports.protocol = parser.protocol;
      exports.connect = lookup;
      exports.Manager = _dereq_('./manager');
      exports.Socket = _dereq_('./socket');
    }, {
      "./manager": 32,
      "./socket": 34,
      "./url": 35,
      "debug": 39,
      "socket.io-parser": 47
    }],
    32: [function(_dereq_, module, exports) {
      var eio = _dereq_('engine.io-client');
      var Socket = _dereq_('./socket');
      var Emitter = _dereq_('component-emitter');
      var parser = _dereq_('socket.io-parser');
      var on = _dereq_('./on');
      var bind = _dereq_('component-bind');
      var debug = _dereq_('debug')('socket.io-client:manager');
      var indexOf = _dereq_('indexof');
      var Backoff = _dereq_('backo2');
      var has = Object.prototype.hasOwnProperty;
      module.exports = Manager;
      function Manager(uri, opts) {
        if (!(this instanceof Manager))
          return new Manager(uri, opts);
        if (uri && ('object' == typeof uri)) {
          opts = uri;
          uri = undefined;
        }
        opts = opts || {};
        opts.path = opts.path || '/socket.io';
        this.nsps = {};
        this.subs = [];
        this.opts = opts;
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1000);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
        this.randomizationFactor(opts.randomizationFactor || 0.5);
        this.backoff = new Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
        this.readyState = 'closed';
        this.uri = uri;
        this.connecting = [];
        this.lastPing = null;
        this.encoding = false;
        this.packetBuffer = [];
        this.encoder = new parser.Encoder();
        this.decoder = new parser.Decoder();
        this.autoConnect = opts.autoConnect !== false;
        if (this.autoConnect)
          this.open();
      }
      Manager.prototype.emitAll = function() {
        this.emit.apply(this, arguments);
        for (var nsp in this.nsps) {
          if (has.call(this.nsps, nsp)) {
            this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
          }
        }
      };
      Manager.prototype.updateSocketIds = function() {
        for (var nsp in this.nsps) {
          if (has.call(this.nsps, nsp)) {
            this.nsps[nsp].id = this.engine.id;
          }
        }
      };
      Emitter(Manager.prototype);
      Manager.prototype.reconnection = function(v) {
        if (!arguments.length)
          return this._reconnection;
        this._reconnection = !!v;
        return this;
      };
      Manager.prototype.reconnectionAttempts = function(v) {
        if (!arguments.length)
          return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      };
      Manager.prototype.reconnectionDelay = function(v) {
        if (!arguments.length)
          return this._reconnectionDelay;
        this._reconnectionDelay = v;
        this.backoff && this.backoff.setMin(v);
        return this;
      };
      Manager.prototype.randomizationFactor = function(v) {
        if (!arguments.length)
          return this._randomizationFactor;
        this._randomizationFactor = v;
        this.backoff && this.backoff.setJitter(v);
        return this;
      };
      Manager.prototype.reconnectionDelayMax = function(v) {
        if (!arguments.length)
          return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        this.backoff && this.backoff.setMax(v);
        return this;
      };
      Manager.prototype.timeout = function(v) {
        if (!arguments.length)
          return this._timeout;
        this._timeout = v;
        return this;
      };
      Manager.prototype.maybeReconnectOnOpen = function() {
        if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      };
      Manager.prototype.open = Manager.prototype.connect = function(fn) {
        debug('readyState %s', this.readyState);
        if (~this.readyState.indexOf('open'))
          return this;
        debug('opening %s', this.uri);
        this.engine = eio(this.uri, this.opts);
        var socket = this.engine;
        var self = this;
        this.readyState = 'opening';
        this.skipReconnect = false;
        var openSub = on(socket, 'open', function() {
          self.onopen();
          fn && fn();
        });
        var errorSub = on(socket, 'error', function(data) {
          debug('connect_error');
          self.cleanup();
          self.readyState = 'closed';
          self.emitAll('connect_error', data);
          if (fn) {
            var err = new Error('Connection error');
            err.data = data;
            fn(err);
          } else {
            self.maybeReconnectOnOpen();
          }
        });
        if (false !== this._timeout) {
          var timeout = this._timeout;
          debug('connect attempt will timeout after %d', timeout);
          var timer = setTimeout(function() {
            debug('connect attempt timed out after %d', timeout);
            openSub.destroy();
            socket.close();
            socket.emit('error', 'timeout');
            self.emitAll('connect_timeout', timeout);
          }, timeout);
          this.subs.push({destroy: function() {
              clearTimeout(timer);
            }});
        }
        this.subs.push(openSub);
        this.subs.push(errorSub);
        return this;
      };
      Manager.prototype.onopen = function() {
        debug('open');
        this.cleanup();
        this.readyState = 'open';
        this.emit('open');
        var socket = this.engine;
        this.subs.push(on(socket, 'data', bind(this, 'ondata')));
        this.subs.push(on(socket, 'ping', bind(this, 'onping')));
        this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
        this.subs.push(on(socket, 'error', bind(this, 'onerror')));
        this.subs.push(on(socket, 'close', bind(this, 'onclose')));
        this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
      };
      Manager.prototype.onping = function() {
        this.lastPing = new Date;
        this.emitAll('ping');
      };
      Manager.prototype.onpong = function() {
        this.emitAll('pong', new Date - this.lastPing);
      };
      Manager.prototype.ondata = function(data) {
        this.decoder.add(data);
      };
      Manager.prototype.ondecoded = function(packet) {
        this.emit('packet', packet);
      };
      Manager.prototype.onerror = function(err) {
        debug('error', err);
        this.emitAll('error', err);
      };
      Manager.prototype.socket = function(nsp) {
        var socket = this.nsps[nsp];
        if (!socket) {
          socket = new Socket(this, nsp);
          this.nsps[nsp] = socket;
          var self = this;
          socket.on('connecting', onConnecting);
          socket.on('connect', function() {
            socket.id = self.engine.id;
          });
          if (this.autoConnect) {
            onConnecting();
          }
        }
        function onConnecting() {
          if (!~indexOf(self.connecting, socket)) {
            self.connecting.push(socket);
          }
        }
        return socket;
      };
      Manager.prototype.destroy = function(socket) {
        var index = indexOf(this.connecting, socket);
        if (~index)
          this.connecting.splice(index, 1);
        if (this.connecting.length)
          return;
        this.close();
      };
      Manager.prototype.packet = function(packet) {
        debug('writing packet %j', packet);
        var self = this;
        if (!self.encoding) {
          self.encoding = true;
          this.encoder.encode(packet, function(encodedPackets) {
            for (var i = 0; i < encodedPackets.length; i++) {
              self.engine.write(encodedPackets[i], packet.options);
            }
            self.encoding = false;
            self.processPacketQueue();
          });
        } else {
          self.packetBuffer.push(packet);
        }
      };
      Manager.prototype.processPacketQueue = function() {
        if (this.packetBuffer.length > 0 && !this.encoding) {
          var pack = this.packetBuffer.shift();
          this.packet(pack);
        }
      };
      Manager.prototype.cleanup = function() {
        debug('cleanup');
        var sub;
        while (sub = this.subs.shift())
          sub.destroy();
        this.packetBuffer = [];
        this.encoding = false;
        this.lastPing = null;
        this.decoder.destroy();
      };
      Manager.prototype.close = Manager.prototype.disconnect = function() {
        debug('disconnect');
        this.skipReconnect = true;
        this.reconnecting = false;
        if ('opening' == this.readyState) {
          this.cleanup();
        }
        this.backoff.reset();
        this.readyState = 'closed';
        if (this.engine)
          this.engine.close();
      };
      Manager.prototype.onclose = function(reason) {
        debug('onclose');
        this.cleanup();
        this.backoff.reset();
        this.readyState = 'closed';
        this.emit('close', reason);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      };
      Manager.prototype.reconnect = function() {
        if (this.reconnecting || this.skipReconnect)
          return this;
        var self = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug('reconnect failed');
          this.backoff.reset();
          this.emitAll('reconnect_failed');
          this.reconnecting = false;
        } else {
          var delay = this.backoff.duration();
          debug('will wait %dms before reconnect attempt', delay);
          this.reconnecting = true;
          var timer = setTimeout(function() {
            if (self.skipReconnect)
              return;
            debug('attempting reconnect');
            self.emitAll('reconnect_attempt', self.backoff.attempts);
            self.emitAll('reconnecting', self.backoff.attempts);
            if (self.skipReconnect)
              return;
            self.open(function(err) {
              if (err) {
                debug('reconnect attempt error');
                self.reconnecting = false;
                self.reconnect();
                self.emitAll('reconnect_error', err.data);
              } else {
                debug('reconnect success');
                self.onreconnect();
              }
            });
          }, delay);
          this.subs.push({destroy: function() {
              clearTimeout(timer);
            }});
        }
      };
      Manager.prototype.onreconnect = function() {
        var attempt = this.backoff.attempts;
        this.reconnecting = false;
        this.backoff.reset();
        this.updateSocketIds();
        this.emitAll('reconnect', attempt);
      };
    }, {
      "./on": 33,
      "./socket": 34,
      "backo2": 36,
      "component-bind": 37,
      "component-emitter": 38,
      "debug": 39,
      "engine.io-client": 1,
      "indexof": 42,
      "socket.io-parser": 47
    }],
    33: [function(_dereq_, module, exports) {
      module.exports = on;
      function on(obj, ev, fn) {
        obj.on(ev, fn);
        return {destroy: function() {
            obj.removeListener(ev, fn);
          }};
      }
    }, {}],
    34: [function(_dereq_, module, exports) {
      var parser = _dereq_('socket.io-parser');
      var Emitter = _dereq_('component-emitter');
      var toArray = _dereq_('to-array');
      var on = _dereq_('./on');
      var bind = _dereq_('component-bind');
      var debug = _dereq_('debug')('socket.io-client:socket');
      var hasBin = _dereq_('has-binary');
      module.exports = exports = Socket;
      var events = {
        connect: 1,
        connect_error: 1,
        connect_timeout: 1,
        connecting: 1,
        disconnect: 1,
        error: 1,
        reconnect: 1,
        reconnect_attempt: 1,
        reconnect_failed: 1,
        reconnect_error: 1,
        reconnecting: 1,
        ping: 1,
        pong: 1
      };
      var emit = Emitter.prototype.emit;
      function Socket(io, nsp) {
        this.io = io;
        this.nsp = nsp;
        this.json = this;
        this.ids = 0;
        this.acks = {};
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.connected = false;
        this.disconnected = true;
        if (this.io.autoConnect)
          this.open();
      }
      Emitter(Socket.prototype);
      Socket.prototype.subEvents = function() {
        if (this.subs)
          return;
        var io = this.io;
        this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
      };
      Socket.prototype.open = Socket.prototype.connect = function() {
        if (this.connected)
          return this;
        this.subEvents();
        this.io.open();
        if ('open' == this.io.readyState)
          this.onopen();
        this.emit('connecting');
        return this;
      };
      Socket.prototype.send = function() {
        var args = toArray(arguments);
        args.unshift('message');
        this.emit.apply(this, args);
        return this;
      };
      Socket.prototype.emit = function(ev) {
        if (events.hasOwnProperty(ev)) {
          emit.apply(this, arguments);
          return this;
        }
        var args = toArray(arguments);
        var parserType = parser.EVENT;
        if (hasBin(args)) {
          parserType = parser.BINARY_EVENT;
        }
        var packet = {
          type: parserType,
          data: args
        };
        packet.options = {};
        packet.options.compress = !this.flags || false !== this.flags.compress;
        if ('function' == typeof args[args.length - 1]) {
          debug('emitting packet with ack id %d', this.ids);
          this.acks[this.ids] = args.pop();
          packet.id = this.ids++;
        }
        if (this.connected) {
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        delete this.flags;
        return this;
      };
      Socket.prototype.packet = function(packet) {
        packet.nsp = this.nsp;
        this.io.packet(packet);
      };
      Socket.prototype.onopen = function() {
        debug('transport is open - connecting');
        if ('/' != this.nsp) {
          this.packet({type: parser.CONNECT});
        }
      };
      Socket.prototype.onclose = function(reason) {
        debug('close (%s)', reason);
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emit('disconnect', reason);
      };
      Socket.prototype.onpacket = function(packet) {
        if (packet.nsp != this.nsp)
          return;
        switch (packet.type) {
          case parser.CONNECT:
            this.onconnect();
            break;
          case parser.EVENT:
            this.onevent(packet);
            break;
          case parser.BINARY_EVENT:
            this.onevent(packet);
            break;
          case parser.ACK:
            this.onack(packet);
            break;
          case parser.BINARY_ACK:
            this.onack(packet);
            break;
          case parser.DISCONNECT:
            this.ondisconnect();
            break;
          case parser.ERROR:
            this.emit('error', packet.data);
            break;
        }
      };
      Socket.prototype.onevent = function(packet) {
        var args = packet.data || [];
        debug('emitting event %j', args);
        if (null != packet.id) {
          debug('attaching ack callback to event');
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          emit.apply(this, args);
        } else {
          this.receiveBuffer.push(args);
        }
      };
      Socket.prototype.ack = function(id) {
        var self = this;
        var sent = false;
        return function() {
          if (sent)
            return;
          sent = true;
          var args = toArray(arguments);
          debug('sending ack %j', args);
          var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
          self.packet({
            type: type,
            id: id,
            data: args
          });
        };
      };
      Socket.prototype.onack = function(packet) {
        var ack = this.acks[packet.id];
        if ('function' == typeof ack) {
          debug('calling ack %s with %j', packet.id, packet.data);
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {
          debug('bad ack %s', packet.id);
        }
      };
      Socket.prototype.onconnect = function() {
        this.connected = true;
        this.disconnected = false;
        this.emit('connect');
        this.emitBuffered();
      };
      Socket.prototype.emitBuffered = function() {
        var i;
        for (i = 0; i < this.receiveBuffer.length; i++) {
          emit.apply(this, this.receiveBuffer[i]);
        }
        this.receiveBuffer = [];
        for (i = 0; i < this.sendBuffer.length; i++) {
          this.packet(this.sendBuffer[i]);
        }
        this.sendBuffer = [];
      };
      Socket.prototype.ondisconnect = function() {
        debug('server disconnect (%s)', this.nsp);
        this.destroy();
        this.onclose('io server disconnect');
      };
      Socket.prototype.destroy = function() {
        if (this.subs) {
          for (var i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
          }
          this.subs = null;
        }
        this.io.destroy(this);
      };
      Socket.prototype.close = Socket.prototype.disconnect = function() {
        if (this.connected) {
          debug('performing disconnect (%s)', this.nsp);
          this.packet({type: parser.DISCONNECT});
        }
        this.destroy();
        if (this.connected) {
          this.onclose('io client disconnect');
        }
        return this;
      };
      Socket.prototype.compress = function(compress) {
        this.flags = this.flags || {};
        this.flags.compress = compress;
        return this;
      };
    }, {
      "./on": 33,
      "component-bind": 37,
      "component-emitter": 38,
      "debug": 39,
      "has-binary": 41,
      "socket.io-parser": 47,
      "to-array": 51
    }],
    35: [function(_dereq_, module, exports) {
      (function(global) {
        var parseuri = _dereq_('parseuri');
        var debug = _dereq_('debug')('socket.io-client:url');
        module.exports = url;
        function url(uri, loc) {
          var obj = uri;
          var loc = loc || global.location;
          if (null == uri)
            uri = loc.protocol + '//' + loc.host;
          if ('string' == typeof uri) {
            if ('/' == uri.charAt(0)) {
              if ('/' == uri.charAt(1)) {
                uri = loc.protocol + uri;
              } else {
                uri = loc.host + uri;
              }
            }
            if (!/^(https?|wss?):\/\//.test(uri)) {
              debug('protocol-less url %s', uri);
              if ('undefined' != typeof loc) {
                uri = loc.protocol + '//' + uri;
              } else {
                uri = 'https://' + uri;
              }
            }
            debug('parse %s', uri);
            obj = parseuri(uri);
          }
          if (!obj.port) {
            if (/^(http|ws)$/.test(obj.protocol)) {
              obj.port = '80';
            } else if (/^(http|ws)s$/.test(obj.protocol)) {
              obj.port = '443';
            }
          }
          obj.path = obj.path || '/';
          var ipv6 = obj.host.indexOf(':') !== -1;
          var host = ipv6 ? '[' + obj.host + ']' : obj.host;
          obj.id = obj.protocol + '://' + host + ':' + obj.port;
          obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : (':' + obj.port));
          return obj;
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "debug": 39,
      "parseuri": 45
    }],
    36: [function(_dereq_, module, exports) {
      module.exports = Backoff;
      function Backoff(opts) {
        opts = opts || {};
        this.ms = opts.min || 100;
        this.max = opts.max || 10000;
        this.factor = opts.factor || 2;
        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
        this.attempts = 0;
      }
      Backoff.prototype.duration = function() {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var rand = Math.random();
          var deviation = Math.floor(rand * this.jitter * ms);
          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
      };
      Backoff.prototype.reset = function() {
        this.attempts = 0;
      };
      Backoff.prototype.setMin = function(min) {
        this.ms = min;
      };
      Backoff.prototype.setMax = function(max) {
        this.max = max;
      };
      Backoff.prototype.setJitter = function(jitter) {
        this.jitter = jitter;
      };
    }, {}],
    37: [function(_dereq_, module, exports) {
      var slice = [].slice;
      module.exports = function(obj, fn) {
        if ('string' == typeof fn)
          fn = obj[fn];
        if ('function' != typeof fn)
          throw new Error('bind() requires a function');
        var args = slice.call(arguments, 2);
        return function() {
          return fn.apply(obj, args.concat(slice.call(arguments)));
        };
      };
    }, {}],
    38: [function(_dereq_, module, exports) {
      module.exports = Emitter;
      function Emitter(obj) {
        if (obj)
          return mixin(obj);
      }
      ;
      function mixin(obj) {
        for (var key in Emitter.prototype) {
          obj[key] = Emitter.prototype[key];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event, fn) {
        function on() {
          this.off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
        this._callbacks = this._callbacks || {};
        if (0 == arguments.length) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks['$' + event];
        if (!callbacks)
          return this;
        if (1 == arguments.length) {
          delete this._callbacks['$' + event];
          return this;
        }
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        return this;
      };
      Emitter.prototype.emit = function(event) {
        this._callbacks = this._callbacks || {};
        var args = [].slice.call(arguments, 1),
            callbacks = this._callbacks['$' + event];
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0,
              len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event) {
        this._callbacks = this._callbacks || {};
        return this._callbacks['$' + event] || [];
      };
      Emitter.prototype.hasListeners = function(event) {
        return !!this.listeners(event).length;
      };
    }, {}],
    39: [function(_dereq_, module, exports) {
      arguments[4][17][0].apply(exports, arguments);
    }, {
      "./debug": 40,
      "dup": 17
    }],
    40: [function(_dereq_, module, exports) {
      arguments[4][18][0].apply(exports, arguments);
    }, {
      "dup": 18,
      "ms": 44
    }],
    41: [function(_dereq_, module, exports) {
      (function(global) {
        var isArray = _dereq_('isarray');
        module.exports = hasBinary;
        function hasBinary(data) {
          function _hasBinary(obj) {
            if (!obj)
              return false;
            if ((global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer) || (global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
              return true;
            }
            if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                if (_hasBinary(obj[i])) {
                  return true;
                }
              }
            } else if (obj && 'object' == typeof obj) {
              if (obj.toJSON && 'function' == typeof obj.toJSON) {
                obj = obj.toJSON();
              }
              for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
                  return true;
                }
              }
            }
            return false;
          }
          return _hasBinary(data);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {"isarray": 43}],
    42: [function(_dereq_, module, exports) {
      arguments[4][23][0].apply(exports, arguments);
    }, {"dup": 23}],
    43: [function(_dereq_, module, exports) {
      arguments[4][24][0].apply(exports, arguments);
    }, {"dup": 24}],
    44: [function(_dereq_, module, exports) {
      arguments[4][25][0].apply(exports, arguments);
    }, {"dup": 25}],
    45: [function(_dereq_, module, exports) {
      arguments[4][28][0].apply(exports, arguments);
    }, {"dup": 28}],
    46: [function(_dereq_, module, exports) {
      (function(global) {
        var isArray = _dereq_('isarray');
        var isBuf = _dereq_('./is-buffer');
        exports.deconstructPacket = function(packet) {
          var buffers = [];
          var packetData = packet.data;
          function _deconstructPacket(data) {
            if (!data)
              return data;
            if (isBuf(data)) {
              var placeholder = {
                _placeholder: true,
                num: buffers.length
              };
              buffers.push(data);
              return placeholder;
            } else if (isArray(data)) {
              var newData = new Array(data.length);
              for (var i = 0; i < data.length; i++) {
                newData[i] = _deconstructPacket(data[i]);
              }
              return newData;
            } else if ('object' == typeof data && !(data instanceof Date)) {
              var newData = {};
              for (var key in data) {
                newData[key] = _deconstructPacket(data[key]);
              }
              return newData;
            }
            return data;
          }
          var pack = packet;
          pack.data = _deconstructPacket(packetData);
          pack.attachments = buffers.length;
          return {
            packet: pack,
            buffers: buffers
          };
        };
        exports.reconstructPacket = function(packet, buffers) {
          var curPlaceHolder = 0;
          function _reconstructPacket(data) {
            if (data && data._placeholder) {
              var buf = buffers[data.num];
              return buf;
            } else if (isArray(data)) {
              for (var i = 0; i < data.length; i++) {
                data[i] = _reconstructPacket(data[i]);
              }
              return data;
            } else if (data && 'object' == typeof data) {
              for (var key in data) {
                data[key] = _reconstructPacket(data[key]);
              }
              return data;
            }
            return data;
          }
          packet.data = _reconstructPacket(packet.data);
          packet.attachments = undefined;
          return packet;
        };
        exports.removeBlobs = function(data, callback) {
          function _removeBlobs(obj, curKey, containingObject) {
            if (!obj)
              return obj;
            if ((global.Blob && obj instanceof Blob) || (global.File && obj instanceof File)) {
              pendingBlobs++;
              var fileReader = new FileReader();
              fileReader.onload = function() {
                if (containingObject) {
                  containingObject[curKey] = this.result;
                } else {
                  bloblessData = this.result;
                }
                if (!--pendingBlobs) {
                  callback(bloblessData);
                }
              };
              fileReader.readAsArrayBuffer(obj);
            } else if (isArray(obj)) {
              for (var i = 0; i < obj.length; i++) {
                _removeBlobs(obj[i], i, obj);
              }
            } else if (obj && 'object' == typeof obj && !isBuf(obj)) {
              for (var key in obj) {
                _removeBlobs(obj[key], key, obj);
              }
            }
          }
          var pendingBlobs = 0;
          var bloblessData = data;
          _removeBlobs(bloblessData);
          if (!pendingBlobs) {
            callback(bloblessData);
          }
        };
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {
      "./is-buffer": 48,
      "isarray": 43
    }],
    47: [function(_dereq_, module, exports) {
      var debug = _dereq_('debug')('socket.io-parser');
      var json = _dereq_('json3');
      var isArray = _dereq_('isarray');
      var Emitter = _dereq_('component-emitter');
      var binary = _dereq_('./binary');
      var isBuf = _dereq_('./is-buffer');
      exports.protocol = 4;
      exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'BINARY_EVENT', 'ACK', 'BINARY_ACK', 'ERROR'];
      exports.CONNECT = 0;
      exports.DISCONNECT = 1;
      exports.EVENT = 2;
      exports.ACK = 3;
      exports.ERROR = 4;
      exports.BINARY_EVENT = 5;
      exports.BINARY_ACK = 6;
      exports.Encoder = Encoder;
      exports.Decoder = Decoder;
      function Encoder() {}
      Encoder.prototype.encode = function(obj, callback) {
        debug('encoding packet %j', obj);
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          encodeAsBinary(obj, callback);
        } else {
          var encoding = encodeAsString(obj);
          callback([encoding]);
        }
      };
      function encodeAsString(obj) {
        var str = '';
        var nsp = false;
        str += obj.type;
        if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
          str += obj.attachments;
          str += '-';
        }
        if (obj.nsp && '/' != obj.nsp) {
          nsp = true;
          str += obj.nsp;
        }
        if (null != obj.id) {
          if (nsp) {
            str += ',';
            nsp = false;
          }
          str += obj.id;
        }
        if (null != obj.data) {
          if (nsp)
            str += ',';
          str += json.stringify(obj.data);
        }
        debug('encoded %j as %s', obj, str);
        return str;
      }
      function encodeAsBinary(obj, callback) {
        function writeEncoding(bloblessData) {
          var deconstruction = binary.deconstructPacket(bloblessData);
          var pack = encodeAsString(deconstruction.packet);
          var buffers = deconstruction.buffers;
          buffers.unshift(pack);
          callback(buffers);
        }
        binary.removeBlobs(obj, writeEncoding);
      }
      function Decoder() {
        this.reconstructor = null;
      }
      Emitter(Decoder.prototype);
      Decoder.prototype.add = function(obj) {
        var packet;
        if ('string' == typeof obj) {
          packet = decodeString(obj);
          if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
            this.reconstructor = new BinaryReconstructor(packet);
            if (this.reconstructor.reconPack.attachments === 0) {
              this.emit('decoded', packet);
            }
          } else {
            this.emit('decoded', packet);
          }
        } else if (isBuf(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error('got binary data when not reconstructing a packet');
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              this.emit('decoded', packet);
            }
          }
        } else {
          throw new Error('Unknown type: ' + obj);
        }
      };
      function decodeString(str) {
        var p = {};
        var i = 0;
        p.type = Number(str.charAt(0));
        if (null == exports.types[p.type])
          return error();
        if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
          var buf = '';
          while (str.charAt(++i) != '-') {
            buf += str.charAt(i);
            if (i == str.length)
              break;
          }
          if (buf != Number(buf) || str.charAt(i) != '-') {
            throw new Error('Illegal attachments');
          }
          p.attachments = Number(buf);
        }
        if ('/' == str.charAt(i + 1)) {
          p.nsp = '';
          while (++i) {
            var c = str.charAt(i);
            if (',' == c)
              break;
            p.nsp += c;
            if (i == str.length)
              break;
          }
        } else {
          p.nsp = '/';
        }
        var next = str.charAt(i + 1);
        if ('' !== next && Number(next) == next) {
          p.id = '';
          while (++i) {
            var c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            p.id += str.charAt(i);
            if (i == str.length)
              break;
          }
          p.id = Number(p.id);
        }
        if (str.charAt(++i)) {
          try {
            p.data = json.parse(str.substr(i));
          } catch (e) {
            return error();
          }
        }
        debug('decoded %s as %j', str, p);
        return p;
      }
      Decoder.prototype.destroy = function() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      };
      function BinaryReconstructor(packet) {
        this.reconPack = packet;
        this.buffers = [];
      }
      BinaryReconstructor.prototype.takeBinaryData = function(binData) {
        this.buffers.push(binData);
        if (this.buffers.length == this.reconPack.attachments) {
          var packet = binary.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      };
      BinaryReconstructor.prototype.finishedReconstruction = function() {
        this.reconPack = null;
        this.buffers = [];
      };
      function error(data) {
        return {
          type: exports.ERROR,
          data: 'parser error'
        };
      }
    }, {
      "./binary": 46,
      "./is-buffer": 48,
      "component-emitter": 49,
      "debug": 39,
      "isarray": 43,
      "json3": 50
    }],
    48: [function(_dereq_, module, exports) {
      (function(global) {
        module.exports = isBuf;
        function isBuf(obj) {
          return (global.Buffer && global.Buffer.isBuffer(obj)) || (global.ArrayBuffer && obj instanceof ArrayBuffer);
        }
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}],
    49: [function(_dereq_, module, exports) {
      arguments[4][15][0].apply(exports, arguments);
    }, {"dup": 15}],
    50: [function(_dereq_, module, exports) {
      (function(global) {
        ;
        (function() {
          var isLoader = typeof define === "function" && define.amd;
          var objectTypes = {
            "function": true,
            "object": true
          };
          var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
          var root = objectTypes[typeof window] && window || this,
              freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;
          if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
            root = freeGlobal;
          }
          function runInContext(context, exports) {
            context || (context = root["Object"]());
            exports || (exports = root["Object"]());
            var Number = context["Number"] || root["Number"],
                String = context["String"] || root["String"],
                Object = context["Object"] || root["Object"],
                Date = context["Date"] || root["Date"],
                SyntaxError = context["SyntaxError"] || root["SyntaxError"],
                TypeError = context["TypeError"] || root["TypeError"],
                Math = context["Math"] || root["Math"],
                nativeJSON = context["JSON"] || root["JSON"];
            if (typeof nativeJSON == "object" && nativeJSON) {
              exports.stringify = nativeJSON.stringify;
              exports.parse = nativeJSON.parse;
            }
            var objectProto = Object.prototype,
                getClass = objectProto.toString,
                isProperty,
                forEach,
                undef;
            var isExtended = new Date(-3509827334573292);
            try {
              isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 && isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
            } catch (exception) {}
            function has(name) {
              if (has[name] !== undef) {
                return has[name];
              }
              var isSupported;
              if (name == "bug-string-char-index") {
                isSupported = "a"[0] != "a";
              } else if (name == "json") {
                isSupported = has("json-stringify") && has("json-parse");
              } else {
                var value,
                    serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                if (name == "json-stringify") {
                  var stringify = exports.stringify,
                      stringifySupported = typeof stringify == "function" && isExtended;
                  if (stringifySupported) {
                    (value = function() {
                      return 1;
                    }).toJSON = value;
                    try {
                      stringifySupported = stringify(0) === "0" && stringify(new Number()) === "0" && stringify(new String()) == '""' && stringify(getClass) === undef && stringify(undef) === undef && stringify() === undef && stringify(value) === "1" && stringify([value]) == "[1]" && stringify([undef]) == "[null]" && stringify(null) == "null" && stringify([undef, getClass, null]) == "[null,null,null]" && stringify({"a": [value, true, false, null, "\x00\b\n\f\r\t"]}) == serialized && stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" && stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' && stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' && stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' && stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
                    } catch (exception) {
                      stringifySupported = false;
                    }
                  }
                  isSupported = stringifySupported;
                }
                if (name == "json-parse") {
                  var parse = exports.parse;
                  if (typeof parse == "function") {
                    try {
                      if (parse("0") === 0 && !parse(false)) {
                        value = parse(serialized);
                        var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                        if (parseSupported) {
                          try {
                            parseSupported = !parse('"\t"');
                          } catch (exception) {}
                          if (parseSupported) {
                            try {
                              parseSupported = parse("01") !== 1;
                            } catch (exception) {}
                          }
                          if (parseSupported) {
                            try {
                              parseSupported = parse("1.") !== 1;
                            } catch (exception) {}
                          }
                        }
                      }
                    } catch (exception) {
                      parseSupported = false;
                    }
                  }
                  isSupported = parseSupported;
                }
              }
              return has[name] = !!isSupported;
            }
            if (!has("json")) {
              var functionClass = "[object Function]",
                  dateClass = "[object Date]",
                  numberClass = "[object Number]",
                  stringClass = "[object String]",
                  arrayClass = "[object Array]",
                  booleanClass = "[object Boolean]";
              var charIndexBuggy = has("bug-string-char-index");
              if (!isExtended) {
                var floor = Math.floor;
                var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
                var getDay = function(year, month) {
                  return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
                };
              }
              if (!(isProperty = objectProto.hasOwnProperty)) {
                isProperty = function(property) {
                  var members = {},
                      constructor;
                  if ((members.__proto__ = null, members.__proto__ = {"toString": 1}, members).toString != getClass) {
                    isProperty = function(property) {
                      var original = this.__proto__,
                          result = property in (this.__proto__ = null, this);
                      this.__proto__ = original;
                      return result;
                    };
                  } else {
                    constructor = members.constructor;
                    isProperty = function(property) {
                      var parent = (this.constructor || constructor).prototype;
                      return property in this && !(property in parent && this[property] === parent[property]);
                    };
                  }
                  members = null;
                  return isProperty.call(this, property);
                };
              }
              forEach = function(object, callback) {
                var size = 0,
                    Properties,
                    members,
                    property;
                (Properties = function() {
                  this.valueOf = 0;
                }).prototype.valueOf = 0;
                members = new Properties();
                for (property in members) {
                  if (isProperty.call(members, property)) {
                    size++;
                  }
                }
                Properties = members = null;
                if (!size) {
                  members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
                  forEach = function(object, callback) {
                    var isFunction = getClass.call(object) == functionClass,
                        property,
                        length;
                    var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
                    for (property in object) {
                      if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                        callback(property);
                      }
                    }
                    for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property))
                      ;
                  };
                } else if (size == 2) {
                  forEach = function(object, callback) {
                    var members = {},
                        isFunction = getClass.call(object) == functionClass,
                        property;
                    for (property in object) {
                      if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                        callback(property);
                      }
                    }
                  };
                } else {
                  forEach = function(object, callback) {
                    var isFunction = getClass.call(object) == functionClass,
                        property,
                        isConstructor;
                    for (property in object) {
                      if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                        callback(property);
                      }
                    }
                    if (isConstructor || isProperty.call(object, (property = "constructor"))) {
                      callback(property);
                    }
                  };
                }
                return forEach(object, callback);
              };
              if (!has("json-stringify")) {
                var Escapes = {
                  92: "\\\\",
                  34: '\\"',
                  8: "\\b",
                  12: "\\f",
                  10: "\\n",
                  13: "\\r",
                  9: "\\t"
                };
                var leadingZeroes = "000000";
                var toPaddedString = function(width, value) {
                  return (leadingZeroes + (value || 0)).slice(-width);
                };
                var unicodePrefix = "\\u00";
                var quote = function(value) {
                  var result = '"',
                      index = 0,
                      length = value.length,
                      useCharIndex = !charIndexBuggy || length > 10;
                  var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
                  for (; index < length; index++) {
                    var charCode = value.charCodeAt(index);
                    switch (charCode) {
                      case 8:
                      case 9:
                      case 10:
                      case 12:
                      case 13:
                      case 34:
                      case 92:
                        result += Escapes[charCode];
                        break;
                      default:
                        if (charCode < 32) {
                          result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                          break;
                        }
                        result += useCharIndex ? symbols[index] : value.charAt(index);
                    }
                  }
                  return result + '"';
                };
                var serialize = function(property, object, callback, properties, whitespace, indentation, stack) {
                  var value,
                      className,
                      year,
                      month,
                      date,
                      time,
                      hours,
                      minutes,
                      seconds,
                      milliseconds,
                      results,
                      element,
                      index,
                      length,
                      prefix,
                      result;
                  try {
                    value = object[property];
                  } catch (exception) {}
                  if (typeof value == "object" && value) {
                    className = getClass.call(value);
                    if (className == dateClass && !isProperty.call(value, "toJSON")) {
                      if (value > -1 / 0 && value < 1 / 0) {
                        if (getDay) {
                          date = floor(value / 864e5);
                          for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++)
                            ;
                          for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++)
                            ;
                          date = 1 + date - getDay(year, month);
                          time = (value % 864e5 + 864e5) % 864e5;
                          hours = floor(time / 36e5) % 24;
                          minutes = floor(time / 6e4) % 60;
                          seconds = floor(time / 1e3) % 60;
                          milliseconds = time % 1e3;
                        } else {
                          year = value.getUTCFullYear();
                          month = value.getUTCMonth();
                          date = value.getUTCDate();
                          hours = value.getUTCHours();
                          minutes = value.getUTCMinutes();
                          seconds = value.getUTCSeconds();
                          milliseconds = value.getUTCMilliseconds();
                        }
                        value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) + "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) + "." + toPaddedString(3, milliseconds) + "Z";
                      } else {
                        value = null;
                      }
                    } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
                      value = value.toJSON(property);
                    }
                  }
                  if (callback) {
                    value = callback.call(object, property, value);
                  }
                  if (value === null) {
                    return "null";
                  }
                  className = getClass.call(value);
                  if (className == booleanClass) {
                    return "" + value;
                  } else if (className == numberClass) {
                    return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
                  } else if (className == stringClass) {
                    return quote("" + value);
                  }
                  if (typeof value == "object") {
                    for (length = stack.length; length--; ) {
                      if (stack[length] === value) {
                        throw TypeError();
                      }
                    }
                    stack.push(value);
                    results = [];
                    prefix = indentation;
                    indentation += whitespace;
                    if (className == arrayClass) {
                      for (index = 0, length = value.length; index < length; index++) {
                        element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                        results.push(element === undef ? "null" : element);
                      }
                      result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
                    } else {
                      forEach(properties || value, function(property) {
                        var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                        if (element !== undef) {
                          results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                        }
                      });
                      result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
                    }
                    stack.pop();
                    return result;
                  }
                };
                exports.stringify = function(source, filter, width) {
                  var whitespace,
                      callback,
                      properties,
                      className;
                  if (objectTypes[typeof filter] && filter) {
                    if ((className = getClass.call(filter)) == functionClass) {
                      callback = filter;
                    } else if (className == arrayClass) {
                      properties = {};
                      for (var index = 0,
                          length = filter.length,
                          value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1))
                        ;
                    }
                  }
                  if (width) {
                    if ((className = getClass.call(width)) == numberClass) {
                      if ((width -= width % 1) > 0) {
                        for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ")
                          ;
                      }
                    } else if (className == stringClass) {
                      whitespace = width.length <= 10 ? width : width.slice(0, 10);
                    }
                  }
                  return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
                };
              }
              if (!has("json-parse")) {
                var fromCharCode = String.fromCharCode;
                var Unescapes = {
                  92: "\\",
                  34: '"',
                  47: "/",
                  98: "\b",
                  116: "\t",
                  110: "\n",
                  102: "\f",
                  114: "\r"
                };
                var Index,
                    Source;
                var abort = function() {
                  Index = Source = null;
                  throw SyntaxError();
                };
                var lex = function() {
                  var source = Source,
                      length = source.length,
                      value,
                      begin,
                      position,
                      isSigned,
                      charCode;
                  while (Index < length) {
                    charCode = source.charCodeAt(Index);
                    switch (charCode) {
                      case 9:
                      case 10:
                      case 13:
                      case 32:
                        Index++;
                        break;
                      case 123:
                      case 125:
                      case 91:
                      case 93:
                      case 58:
                      case 44:
                        value = charIndexBuggy ? source.charAt(Index) : source[Index];
                        Index++;
                        return value;
                      case 34:
                        for (value = "@", Index++; Index < length; ) {
                          charCode = source.charCodeAt(Index);
                          if (charCode < 32) {
                            abort();
                          } else if (charCode == 92) {
                            charCode = source.charCodeAt(++Index);
                            switch (charCode) {
                              case 92:
                              case 34:
                              case 47:
                              case 98:
                              case 116:
                              case 110:
                              case 102:
                              case 114:
                                value += Unescapes[charCode];
                                Index++;
                                break;
                              case 117:
                                begin = ++Index;
                                for (position = Index + 4; Index < position; Index++) {
                                  charCode = source.charCodeAt(Index);
                                  if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                                    abort();
                                  }
                                }
                                value += fromCharCode("0x" + source.slice(begin, Index));
                                break;
                              default:
                                abort();
                            }
                          } else {
                            if (charCode == 34) {
                              break;
                            }
                            charCode = source.charCodeAt(Index);
                            begin = Index;
                            while (charCode >= 32 && charCode != 92 && charCode != 34) {
                              charCode = source.charCodeAt(++Index);
                            }
                            value += source.slice(begin, Index);
                          }
                        }
                        if (source.charCodeAt(Index) == 34) {
                          Index++;
                          return value;
                        }
                        abort();
                      default:
                        begin = Index;
                        if (charCode == 45) {
                          isSigned = true;
                          charCode = source.charCodeAt(++Index);
                        }
                        if (charCode >= 48 && charCode <= 57) {
                          if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                            abort();
                          }
                          isSigned = false;
                          for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++)
                            ;
                          if (source.charCodeAt(Index) == 46) {
                            position = ++Index;
                            for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                              ;
                            if (position == Index) {
                              abort();
                            }
                            Index = position;
                          }
                          charCode = source.charCodeAt(Index);
                          if (charCode == 101 || charCode == 69) {
                            charCode = source.charCodeAt(++Index);
                            if (charCode == 43 || charCode == 45) {
                              Index++;
                            }
                            for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++)
                              ;
                            if (position == Index) {
                              abort();
                            }
                            Index = position;
                          }
                          return +source.slice(begin, Index);
                        }
                        if (isSigned) {
                          abort();
                        }
                        if (source.slice(Index, Index + 4) == "true") {
                          Index += 4;
                          return true;
                        } else if (source.slice(Index, Index + 5) == "false") {
                          Index += 5;
                          return false;
                        } else if (source.slice(Index, Index + 4) == "null") {
                          Index += 4;
                          return null;
                        }
                        abort();
                    }
                  }
                  return "$";
                };
                var get = function(value) {
                  var results,
                      hasMembers;
                  if (value == "$") {
                    abort();
                  }
                  if (typeof value == "string") {
                    if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
                      return value.slice(1);
                    }
                    if (value == "[") {
                      results = [];
                      for (; ; hasMembers || (hasMembers = true)) {
                        value = lex();
                        if (value == "]") {
                          break;
                        }
                        if (hasMembers) {
                          if (value == ",") {
                            value = lex();
                            if (value == "]") {
                              abort();
                            }
                          } else {
                            abort();
                          }
                        }
                        if (value == ",") {
                          abort();
                        }
                        results.push(get(value));
                      }
                      return results;
                    } else if (value == "{") {
                      results = {};
                      for (; ; hasMembers || (hasMembers = true)) {
                        value = lex();
                        if (value == "}") {
                          break;
                        }
                        if (hasMembers) {
                          if (value == ",") {
                            value = lex();
                            if (value == "}") {
                              abort();
                            }
                          } else {
                            abort();
                          }
                        }
                        if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                          abort();
                        }
                        results[value.slice(1)] = get(lex());
                      }
                      return results;
                    }
                    abort();
                  }
                  return value;
                };
                var update = function(source, property, callback) {
                  var element = walk(source, property, callback);
                  if (element === undef) {
                    delete source[property];
                  } else {
                    source[property] = element;
                  }
                };
                var walk = function(source, property, callback) {
                  var value = source[property],
                      length;
                  if (typeof value == "object" && value) {
                    if (getClass.call(value) == arrayClass) {
                      for (length = value.length; length--; ) {
                        update(value, length, callback);
                      }
                    } else {
                      forEach(value, function(property) {
                        update(value, property, callback);
                      });
                    }
                  }
                  return callback.call(source, property, value);
                };
                exports.parse = function(source, callback) {
                  var result,
                      value;
                  Index = 0;
                  Source = "" + source;
                  result = get(lex());
                  if (lex() != "$") {
                    abort();
                  }
                  Index = Source = null;
                  return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
                };
              }
            }
            exports["runInContext"] = runInContext;
            return exports;
          }
          if (freeExports && !isLoader) {
            runInContext(root, freeExports);
          } else {
            var nativeJSON = root.JSON,
                previousJSON = root["JSON3"],
                isRestored = false;
            var JSON3 = runInContext(root, (root["JSON3"] = {"noConflict": function() {
                if (!isRestored) {
                  isRestored = true;
                  root.JSON = nativeJSON;
                  root["JSON3"] = previousJSON;
                  nativeJSON = previousJSON = null;
                }
                return JSON3;
              }}));
            root.JSON = {
              "parse": JSON3.parse,
              "stringify": JSON3.stringify
            };
          }
          if (isLoader) {
            define(function() {
              return JSON3;
            });
          }
        }).call(this);
      }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    }, {}],
    51: [function(_dereq_, module, exports) {
      module.exports = toArray;
      function toArray(list, index) {
        var array = [];
        index = index || 0;
        for (var i = index || 0; i < list.length; i++) {
          array[i - index] = list[i];
        }
        return array;
      }
    }, {}]
  }, {}, [31])(31);
});

_removeDefine();
})();
System.registerDynamic("npm:core-js@1.2.6/library/modules/$.object-sap.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      fails = $__require('npm:core-js@1.2.6/library/modules/$.fails.js');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor.js", ["npm:core-js@1.2.6/library/modules/$.to-iobject.js", "npm:core-js@1.2.6/library/modules/$.object-sap.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject.js');
  $__require('npm:core-js@1.2.6/library/modules/$.object-sap.js')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.object.get-own-property-descriptor.js');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/get-own-property-descriptor.js", ["npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/get-own-property-descriptor.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/get.js", ["npm:babel-runtime@5.8.35/core-js/object/get-own-property-descriptor.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$getOwnPropertyDescriptor = $__require('npm:babel-runtime@5.8.35/core-js/object/get-own-property-descriptor.js')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/create.js", ["npm:core-js@1.2.6/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/create.js", ["npm:core-js@1.2.6/library/fn/object/create.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/create.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of.js", ["npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.set-proto.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js');
  $export($export.S, 'Object', {setPrototypeOf: $__require('npm:core-js@1.2.6/library/modules/$.set-proto.js').set});
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/set-prototype-of.js", ["npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.set-prototype-of.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/set-prototype-of.js", ["npm:core-js@1.2.6/library/fn/object/set-prototype-of.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/set-prototype-of.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/inherits.js", ["npm:babel-runtime@5.8.35/core-js/object/create.js", "npm:babel-runtime@5.8.35/core-js/object/set-prototype-of.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$create = $__require('npm:babel-runtime@5.8.35/core-js/object/create.js')["default"];
  var _Object$setPrototypeOf = $__require('npm:babel-runtime@5.8.35/core-js/object/set-prototype-of.js')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/object/define-property.js", ["npm:core-js@1.2.6/library/modules/$.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/object/define-property.js", ["npm:core-js@1.2.6/library/fn/object/define-property.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/object/define-property.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/create-class.js", ["npm:babel-runtime@5.8.35/core-js/object/define-property.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var _Object$defineProperty = $__require('npm:babel-runtime@5.8.35/core-js/object/define-property.js')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/helpers/class-call-check.js", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.object.to-string.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.string-at.js", ["npm:core-js@1.2.6/library/modules/$.to-integer.js", "npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer.js'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.string.iterator.js", ["npm:core-js@1.2.6/library/modules/$.string-at.js", "npm:core-js@1.2.6/library/modules/$.iter-define.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $at = $__require('npm:core-js@1.2.6/library/modules/$.string-at.js')(true);
  $__require('npm:core-js@1.2.6/library/modules/$.iter-define.js')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.add-to-unscopables.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-step.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iobject.js", ["npm:core-js@1.2.6/library/modules/$.cof.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof.js');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.defined.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-iobject.js", ["npm:core-js@1.2.6/library/modules/$.iobject.js", "npm:core-js@1.2.6/library/modules/$.defined.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = $__require('npm:core-js@1.2.6/library/modules/$.iobject.js'),
      defined = $__require('npm:core-js@1.2.6/library/modules/$.defined.js');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-create.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.property-desc.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.hide.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      descriptor = $__require('npm:core-js@1.2.6/library/modules/$.property-desc.js'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js'),
      IteratorPrototype = {};
  $__require('npm:core-js@1.2.6/library/modules/$.hide.js')(IteratorPrototype, $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-define.js", ["npm:core-js@1.2.6/library/modules/$.library.js", "npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.redefine.js", "npm:core-js@1.2.6/library/modules/$.hide.js", "npm:core-js@1.2.6/library/modules/$.has.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.iter-create.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library.js'),
      $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
      redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine.js'),
      hide = $__require('npm:core-js@1.2.6/library/modules/$.hide.js'),
      has = $__require('npm:core-js@1.2.6/library/modules/$.has.js'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js'),
      $iterCreate = $__require('npm:core-js@1.2.6/library/modules/$.iter-create.js'),
      setToStringTag = $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js'),
      getProto = $__require('npm:core-js@1.2.6/library/modules/$.js').getProto,
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.array.iterator.js", ["npm:core-js@1.2.6/library/modules/$.add-to-unscopables.js", "npm:core-js@1.2.6/library/modules/$.iter-step.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.to-iobject.js", "npm:core-js@1.2.6/library/modules/$.iter-define.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var addToUnscopables = $__require('npm:core-js@1.2.6/library/modules/$.add-to-unscopables.js'),
      step = $__require('npm:core-js@1.2.6/library/modules/$.iter-step.js'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js'),
      toIObject = $__require('npm:core-js@1.2.6/library/modules/$.to-iobject.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.iter-define.js')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/web.dom.iterable.js", ["npm:core-js@1.2.6/library/modules/es6.array.iterator.js", "npm:core-js@1.2.6/library/modules/$.iterators.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.array.iterator.js');
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.library.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.export.js", ["npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
      core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.strict-new.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-call.js", ["npm:core-js@1.2.6/library/modules/$.an-object.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-array-iter.js", ["npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-integer.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.to-length.js", ["npm:core-js@1.2.6/library/modules/$.to-integer.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = $__require('npm:core-js@1.2.6/library/modules/$.to-integer.js'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.classof.js", ["npm:core-js@1.2.6/library/modules/$.cof.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = $__require('npm:core-js@1.2.6/library/modules/$.cof.js'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iterators.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/core.get-iterator-method.js", ["npm:core-js@1.2.6/library/modules/$.classof.js", "npm:core-js@1.2.6/library/modules/$.wks.js", "npm:core-js@1.2.6/library/modules/$.iterators.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = $__require('npm:core-js@1.2.6/library/modules/$.classof.js'),
      ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      Iterators = $__require('npm:core-js@1.2.6/library/modules/$.iterators.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.for-of.js", ["npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.iter-call.js", "npm:core-js@1.2.6/library/modules/$.is-array-iter.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.to-length.js", "npm:core-js@1.2.6/library/modules/core.get-iterator-method.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
      call = $__require('npm:core-js@1.2.6/library/modules/$.iter-call.js'),
      isArrayIter = $__require('npm:core-js@1.2.6/library/modules/$.is-array-iter.js'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
      toLength = $__require('npm:core-js@1.2.6/library/modules/$.to-length.js'),
      getIterFn = $__require('npm:core-js@1.2.6/library/modules/core.get-iterator-method.js');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-proto.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.ctx.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = $__require('npm:core-js@1.2.6/library/modules/$.js').getDesc,
      isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.same-value.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.an-object.js", ["npm:core-js@1.2.6/library/modules/$.is-object.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.species-constructor.js", ["npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.a-function.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
      aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js'),
      SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.a-function.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.ctx.js", ["npm:core-js@1.2.6/library/modules/$.a-function.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.invoke.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.html.js", ["npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.global.js').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.is-object.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.dom-create.js", ["npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
      document = $__require('npm:core-js@1.2.6/library/modules/$.global.js').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.task.js", ["npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.invoke.js", "npm:core-js@1.2.6/library/modules/$.html.js", "npm:core-js@1.2.6/library/modules/$.dom-create.js", "npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.cof.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
        invoke = $__require('npm:core-js@1.2.6/library/modules/$.invoke.js'),
        html = $__require('npm:core-js@1.2.6/library/modules/$.html.js'),
        cel = $__require('npm:core-js@1.2.6/library/modules/$.dom-create.js'),
        global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if ($__require('npm:core-js@1.2.6/library/modules/$.cof.js')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.cof.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.microtask.js", ["npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.task.js", "npm:core-js@1.2.6/library/modules/$.cof.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
        macrotask = $__require('npm:core-js@1.2.6/library/modules/$.task.js').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = $__require('npm:core-js@1.2.6/library/modules/$.cof.js')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.property-desc.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.hide.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.property-desc.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      createDesc = $__require('npm:core-js@1.2.6/library/modules/$.property-desc.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine.js", ["npm:core-js@1.2.6/library/modules/$.hide.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.hide.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.redefine-all.js", ["npm:core-js@1.2.6/library/modules/$.redefine.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = $__require('npm:core-js@1.2.6/library/modules/$.redefine.js');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.has.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.has.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = $__require('npm:core-js@1.2.6/library/modules/$.js').setDesc,
      has = $__require('npm:core-js@1.2.6/library/modules/$.has.js'),
      TAG = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.fails.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.descriptors.js", ["npm:core-js@1.2.6/library/modules/$.fails.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !$__require('npm:core-js@1.2.6/library/modules/$.fails.js')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.set-species.js", ["npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js", "npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  "use strict";
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = $__require('npm:core-js@1.2.6/library/modules/$.core.js'),
      $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
      DESCRIPTORS = $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js'),
      SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.shared.js", ["npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.uid.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.global.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.wks.js", ["npm:core-js@1.2.6/library/modules/$.shared.js", "npm:core-js@1.2.6/library/modules/$.uid.js", "npm:core-js@1.2.6/library/modules/$.global.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = $__require('npm:core-js@1.2.6/library/modules/$.shared.js')('wks'),
      uid = $__require('npm:core-js@1.2.6/library/modules/$.uid.js'),
      Symbol = $__require('npm:core-js@1.2.6/library/modules/$.global.js').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.iter-detect.js", ["npm:core-js@1.2.6/library/modules/$.wks.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2/browser.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2.js", ["npm:process@0.11.2/browser.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('npm:process@0.11.2/browser.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index.js", ["npm:process@0.11.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : $__require('npm:process@0.11.2.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2.js", ["github:jspm/nodelibs-process@0.1.2/index.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__require('github:jspm/nodelibs-process@0.1.2/index.js');
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/es6.promise.js", ["npm:core-js@1.2.6/library/modules/$.js", "npm:core-js@1.2.6/library/modules/$.library.js", "npm:core-js@1.2.6/library/modules/$.global.js", "npm:core-js@1.2.6/library/modules/$.ctx.js", "npm:core-js@1.2.6/library/modules/$.classof.js", "npm:core-js@1.2.6/library/modules/$.export.js", "npm:core-js@1.2.6/library/modules/$.is-object.js", "npm:core-js@1.2.6/library/modules/$.an-object.js", "npm:core-js@1.2.6/library/modules/$.a-function.js", "npm:core-js@1.2.6/library/modules/$.strict-new.js", "npm:core-js@1.2.6/library/modules/$.for-of.js", "npm:core-js@1.2.6/library/modules/$.set-proto.js", "npm:core-js@1.2.6/library/modules/$.same-value.js", "npm:core-js@1.2.6/library/modules/$.wks.js", "npm:core-js@1.2.6/library/modules/$.species-constructor.js", "npm:core-js@1.2.6/library/modules/$.microtask.js", "npm:core-js@1.2.6/library/modules/$.descriptors.js", "npm:core-js@1.2.6/library/modules/$.redefine-all.js", "npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js", "npm:core-js@1.2.6/library/modules/$.set-species.js", "npm:core-js@1.2.6/library/modules/$.core.js", "npm:core-js@1.2.6/library/modules/$.iter-detect.js", "github:jspm/nodelibs-process@0.1.2.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = $__require('npm:core-js@1.2.6/library/modules/$.js'),
        LIBRARY = $__require('npm:core-js@1.2.6/library/modules/$.library.js'),
        global = $__require('npm:core-js@1.2.6/library/modules/$.global.js'),
        ctx = $__require('npm:core-js@1.2.6/library/modules/$.ctx.js'),
        classof = $__require('npm:core-js@1.2.6/library/modules/$.classof.js'),
        $export = $__require('npm:core-js@1.2.6/library/modules/$.export.js'),
        isObject = $__require('npm:core-js@1.2.6/library/modules/$.is-object.js'),
        anObject = $__require('npm:core-js@1.2.6/library/modules/$.an-object.js'),
        aFunction = $__require('npm:core-js@1.2.6/library/modules/$.a-function.js'),
        strictNew = $__require('npm:core-js@1.2.6/library/modules/$.strict-new.js'),
        forOf = $__require('npm:core-js@1.2.6/library/modules/$.for-of.js'),
        setProto = $__require('npm:core-js@1.2.6/library/modules/$.set-proto.js').set,
        same = $__require('npm:core-js@1.2.6/library/modules/$.same-value.js'),
        SPECIES = $__require('npm:core-js@1.2.6/library/modules/$.wks.js')('species'),
        speciesConstructor = $__require('npm:core-js@1.2.6/library/modules/$.species-constructor.js'),
        asap = $__require('npm:core-js@1.2.6/library/modules/$.microtask.js'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && $__require('npm:core-js@1.2.6/library/modules/$.descriptors.js')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      $__require('npm:core-js@1.2.6/library/modules/$.redefine-all.js')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    $__require('npm:core-js@1.2.6/library/modules/$.set-to-string-tag.js')(P, PROMISE);
    $__require('npm:core-js@1.2.6/library/modules/$.set-species.js')(PROMISE);
    Wrapper = $__require('npm:core-js@1.2.6/library/modules/$.core.js')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && $__require('npm:core-js@1.2.6/library/modules/$.iter-detect.js')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })($__require('github:jspm/nodelibs-process@0.1.2.js'));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/modules/$.core.js", [], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/library/fn/promise.js", ["npm:core-js@1.2.6/library/modules/es6.object.to-string.js", "npm:core-js@1.2.6/library/modules/es6.string.iterator.js", "npm:core-js@1.2.6/library/modules/web.dom.iterable.js", "npm:core-js@1.2.6/library/modules/es6.promise.js", "npm:core-js@1.2.6/library/modules/$.core.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  $__require('npm:core-js@1.2.6/library/modules/es6.object.to-string.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.string.iterator.js');
  $__require('npm:core-js@1.2.6/library/modules/web.dom.iterable.js');
  $__require('npm:core-js@1.2.6/library/modules/es6.promise.js');
  module.exports = $__require('npm:core-js@1.2.6/library/modules/$.core.js').Promise;
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:babel-runtime@5.8.35/core-js/promise.js", ["npm:core-js@1.2.6/library/fn/promise.js"], true, function($__require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": $__require('npm:core-js@1.2.6/library/fn/promise.js'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

System.register('lib/custom.ES2015.helpers/helper.js', ['npm:babel-runtime@5.8.35/helpers/get.js', 'npm:babel-runtime@5.8.35/helpers/inherits.js', 'npm:babel-runtime@5.8.35/helpers/create-class.js', 'npm:babel-runtime@5.8.35/helpers/class-call-check.js', 'npm:babel-runtime@5.8.35/core-js/promise.js'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, _Promise, ExtArray;

  return {
    setters: [function (_npmBabelRuntime5835HelpersGetJs) {
      _get = _npmBabelRuntime5835HelpersGetJs['default'];
    }, function (_npmBabelRuntime5835HelpersInheritsJs) {
      _inherits = _npmBabelRuntime5835HelpersInheritsJs['default'];
    }, function (_npmBabelRuntime5835HelpersCreateClassJs) {
      _createClass = _npmBabelRuntime5835HelpersCreateClassJs['default'];
    }, function (_npmBabelRuntime5835HelpersClassCallCheckJs) {
      _classCallCheck = _npmBabelRuntime5835HelpersClassCallCheckJs['default'];
    }, function (_npmBabelRuntime5835CoreJsPromiseJs) {
      _Promise = _npmBabelRuntime5835CoreJsPromiseJs['default'];
    }],
    execute: function () {
      'use strict';

      ExtArray = (function (_Array) {
        _inherits(ExtArray, _Array);

        function ExtArray() {
          _classCallCheck(this, ExtArray);

          _get(Object.getPrototypeOf(ExtArray.prototype), 'constructor', this).call(this);
        }

        _createClass(ExtArray, [{
          key: 'shiftAll',
          value: function shiftAll() {
            var len = this.length;

            while (len--) {
              this.shift();
            }
          }
        }, {
          key: 'pushAll',
          value: function pushAll(data) {
            var _this = this;

            var len = data.length;

            return new _Promise(function (resolve, reject) {
              while (len--) {
                _this.push(data[len]);
              }

              resolve('ready');
            });
          }
        }]);

        return ExtArray;
      })(Array);

      _export('ExtArray', ExtArray);
    }
  };
});
System.register('services/ChatService.js', ['npm:babel-runtime@5.8.35/core-js/promise.js', 'lib/socket.io-client/socket.io.js', 'lib/custom.ES2015.helpers/helper.js'], function (_export) {
    var _Promise, io, ExtArray;

    return {
        setters: [function (_npmBabelRuntime5835CoreJsPromiseJs) {
            _Promise = _npmBabelRuntime5835CoreJsPromiseJs['default'];
        }, function (_libSocketIoClientSocketIoJs) {
            io = _libSocketIoClientSocketIoJs['default'];
        }, function (_libCustomES2015HelpersHelperJs) {
            ExtArray = _libCustomES2015HelpersHelperJs.ExtArray;
        }],
        execute: function () {
            /**
             * Those dependencies are global....
             */
            'use strict';

            _export('default', function ($http, $timeout) {
                var URL = "";
                var chats = [{
                    id: 0,
                    name: 'Ben Sparrow',
                    lastText: 'You on your way?',
                    face: 'img/ben.png'
                }, {
                    id: 1,
                    name: 'Max Lynx',
                    lastText: 'Hey, it\'s me',
                    face: 'img/max.png'
                }, {
                    id: 2,
                    name: 'Adam Bradleyson',
                    lastText: 'I should buy a boat',
                    face: 'img/adam.jpg'
                }, {
                    id: 3,
                    name: 'Perry Governor',
                    lastText: 'Look at my mukluks!',
                    face: 'img/perry.png'
                }, {
                    id: 4,
                    name: 'Mike Harrington',
                    lastText: 'This is wicked good ice cream.',
                    face: 'img/mike.png'
                }];

                var lostAnimals = new ExtArray();
                var foundAnimals = new ExtArray();
                var messages = new ExtArray();

                var socket = io.connect('10.0.1.2:3003');

                socket.on('connection', function (data) {
                    console.log(data);
                    //socket.emit('my other event', { my: 'data' });
                });

                socket.on('broadcastMsg', function (data) {
                    if (data.secondaryId === currentCategory) {
                        $timeout(function () {
                            messages.unshift(data);
                        });
                    } else {
                        console.log('mseg: ' + JSON.stringify(data));
                    }
                });

                socket.on('disconnect', function () {
                    console.log('disconnected');
                });

                var currentCategory = undefined;

                var service = {
                    all: function all() {
                        return chats;
                    },
                    remove: function remove(chat) {
                        chats.splice(chats.indexOf(chat), 1);
                    },
                    /**
                     * TODO: implementation
                     * @returns {*[]}
                     */
                    getCategory: function getCategory(animal) {
                        switch (animal) {
                            default:
                                return [{
                                    id: 0,
                                    name: 'Lost dog ...',
                                    lastText: 'Lorem ipsum ...',
                                    face: 'img/ben.png'
                                }];
                        }
                    },
                    get: function get(chatId) {
                        for (var i = 0; i < chats.length; i++) {
                            if (chats[i].id === parseInt(chatId)) {
                                return chats[i];
                            }
                        }
                        return null;
                    },
                    getDogs: function getDogs() {
                        return [{
                            id: 0,
                            name: 'Lost dog ...',
                            lastText: 'Lorem ipsum ...',
                            face: 'img/ben.png'
                        }];
                    },

                    getCategoriesLostAnimals: function getCategoriesLostAnimals() {
                        // Categories
                        return new _Promise(function (resolve, reject) {
                            /*let res = [
                             {
                             cat: "cats",
                             categoryDescription: "Lorem ipsum ..."
                             },
                             {
                             cat: "dogs",
                             categoryDescription: "Lorem ipsum ..."
                             },
                             {
                             cat: "aa",
                             categoryDescription: "dsfsdfsfdsf"
                             }
                             ];*/

                            setTimeout(function () {
                                resolve(res);
                            }, 0);
                        });
                    },

                    lostAnimals: lostAnimals,
                    get_lostAnimals: function get_lostAnimals(category) {
                        return new _Promise(function (resolve, reject) {
                            lostAnimals.shiftAll();

                            $http.get('http://10.0.1.2:3003/api/lost-animals/' + category).then(function (res) {

                                lostAnimals.pushAll(res.data).then(function () {
                                    resolve(lostAnimals);
                                });
                            }, function (error) {
                                reject(error);
                            });
                        });
                    },

                    foundAnimals: foundAnimals,
                    get_foundAnimals: function get_foundAnimals(category) {
                        foundAnimals.shiftAll();

                        return new _Promise(function (resolve, reject) {
                            $http.get('http://10.0.1.2:3003/api/found-animals/' + category).then(function (res) {

                                foundAnimals.pushAll(res.data).then(function () {
                                    resolve(foundAnimals);
                                });
                            }, function (error) {
                                reject(error);
                            });
                        });
                    },

                    add_lostAnimals: function add_lostAnimals(category, data) {
                        data.animal = category;
                        data.user = "tiulenski";

                        return $http({
                            url: 'http://10.0.1.2:3003/api/lost-animals/' + category,
                            method: "POST",
                            data: data,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    },

                    add_foundAnimals: function add_foundAnimals(category, data) {
                        data.animal = category;
                        data.user = "tiulenski";

                        return $http({
                            url: 'http://10.0.1.2:3003/api/found-animals/' + category,
                            method: "POST",
                            data: data,
                            headers: { 'Content-Type': 'application/json' }
                        });
                    },

                    messages: messages,
                    getMessages: function getMessages(category) {
                        currentCategory = category;
                        messages.shiftAll();

                        return new _Promise(function (resolve, reject) {
                            $http({
                                url: 'http://10.0.1.2:3003/api/messages/' + category,
                                method: "GET",
                                headers: { 'Content-Type': 'application/json' }
                            }).success(function (res) {

                                messages.pushAll(res, true).then(function () {
                                    resolve(messages);
                                });
                            }).error(function (error) {
                                console.log(error);
                            });
                        });
                    },
                    sendMessages: function sendMessages(category, message, callBack) {
                        $http({
                            url: 'http://10.0.1.2:3003/api/messages/' + category,
                            method: "POST",
                            data: {
                                message: message,
                                user: 'tiulenski'
                            },
                            headers: { 'Content-Type': 'application/json' }
                        }).success(function (res) {
                            socket.emit('message', res); //TODO: should be service
                            callBack.call();
                        }).error(function () {
                            //TODO: implement errors
                        });
                    }

                };

                return service;
            });
        }
    };
});
System.register("services/InternationalizationService.js", [], function (_export) {
    "use strict";

    return {
        setters: [],
        execute: function () {
            _export("default", function ($rootScope) {
                var defaultLang = "bg-BG";

                var langs = {
                    "bg-BG": {
                        "home": "",
                        "lost-animals": " ",
                        "found-animals": " ",
                        "lost-dogs": " ",
                        "lost-cats": " ",
                        "found-dogs": " ",
                        "found-cats": " ",
                        "leave-message": " ",
                        "submit": "",
                        "created-on": " ",
                        "add-new": " ",
                        "Dogs": "K",
                        "Cats": "",
                        "Back": "",
                        "loading": ""
                    },
                    "en-GB": {
                        "lost-animals": "Lost animals"
                    }
                };

                return {
                    defaultLanguage: function defaultLanguage() {
                        $rootScope.i18n = langs[defaultLang];
                    },
                    changeLanguage: function changeLanguage(lang) {
                        if (langs.hasOwnProperty(lang)) {
                            $rootScope.i18n = langs[lang];
                        } else {
                            $log.warn(lang + ' do not exist');
                        }
                    }
                };
            });
        }
    };
});
System.register('app.service.js', ['services/User.js', 'services/ChatService.js', 'services/InternationalizationService.js'], function (_export) {
  /**
   * Created by milenstanev on 2/13/16.
   */

  'use strict';

  var UserService, ChatsService, InternationalizationService;
  return {
    setters: [function (_servicesUserJs) {
      UserService = _servicesUserJs['default'];
    }, function (_servicesChatServiceJs) {
      ChatsService = _servicesChatServiceJs['default'];
    }, function (_servicesInternationalizationServiceJs) {
      InternationalizationService = _servicesInternationalizationServiceJs['default'];
    }],
    execute: function () {
      _export('ChatsService', ChatsService);

      _export('UserService', UserService);

      _export('InternationalizationService', InternationalizationService);
    }
  };
});
System.register('app.js', ['lib/ionic/js/ionic.bundle.js', 'modules/tabsModule/tabs.module.js', 'modules/homeModule/homeModule.js', 'modules/lostAnimalsModule/lostAnimals.module.js', 'modules/foundAnimalsModule/foundAnimals.module.js', 'app.service.js'], function (_export) {
    /**
     * Compile:
     *  babel --presets es2015 app.js --out-file app.compiled.js
     *  babel --presets es2015 app.js --out-file app.compiled.js --modules system
     * Bundle:
     *  jspm bundle app.js app.bundle.js
     */

    //region imports

    //endregion

    'use strict';

    //global services
    var UserService, ChatsService, InternationalizationService;
    return {
        setters: [function (_libIonicJsIonicBundleJs) {}, function (_modulesTabsModuleTabsModuleJs) {}, function (_modulesHomeModuleHomeModuleJs) {}, function (_modulesLostAnimalsModuleLostAnimalsModuleJs) {}, function (_modulesFoundAnimalsModuleFoundAnimalsModuleJs) {}, function (_appServiceJs) {
            UserService = _appServiceJs.UserService;
            ChatsService = _appServiceJs.ChatsService;
            InternationalizationService = _appServiceJs.InternationalizationService;
        }],
        execute: function () {
            (function () {
                angular.module('PAW', ['ionic', 'PAW.tabsModule', 'PAW.homeModule', 'PAW.lostAnimalsModule', 'PAW.foundAnimalsModule']).run(function ($ionicPlatform, i18n) {
                    $ionicPlatform.ready(function () {
                        if (window.cordova && window.cordova.plugins.Keyboard) {
                            // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
                            // for form inputs)
                            cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true);

                            // Don't remove this line unless you know what you are doing. It stops the viewport
                            // from snapping when text inputs are focused. Ionic handles this internally for
                            // a much nicer keyboard experience.
                            cordova.plugins.Keyboard.disableScroll(true);
                        }
                        if (window.StatusBar) {
                            StatusBar.styleDefault();
                        }
                    });

                    i18n.defaultLanguage();
                }).service('UserService', UserService).factory('Chats', ChatsService).factory('i18n', InternationalizationService);
            })();
        }
    };
});
//# sourceMappingURL=app.bundle.js.map